'*****************Curve Draw***************'     ***To Do***'***Disable palette for invisible lines--maybe'***protect palette on redraw. Clip.'***Add more "custom functions". Fix window changes.***''     This ZBasic source code was created'     using pGII ver 1.06'     Copyright 1990 Staz Software''     This program is Copyright 1991 David Friedman''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Configuration Remarks'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'         Default variable type:Integer'   Space req'd after key words:Yes'                  Array base 1:No'                     File Type:Cves'                  Creator Type:CDrw' DEF OPEN ="CvesCDrw" BUNDLE = 1'''WINDOW OFF:COORDINATE WINDOWDEF MOUSE=-1:CURSOR 4:WIDTH -2''''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Resources'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Hndl& = FN GETRESOURCE(CVI("CDrw"),0)IF Hndl& = 0 Then  ResRef = FN OPENRESFILE("CurveDraw.res")END IF'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Equates'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'***Save/Load Code***DIM FirstVar,FirstArray(1)'                     We must insure thatDIM VarSrcPtr&,VarLgth&'          these items are FIRST in the list'***Ends Save/Load Code***DIM T,L,B,R:'                                                 Generic rectanglesDIM HelpT,HelpL,HelpB,HelpR            :'The rect that the function will fitDIM TW2,LW2,BW2,RW2   '  Rectangle for WndHelp (Help window)DIM My,Mx,GlobalY,GlobalX,LocalY,LocalX,Myct,Mxct'                           Mouse pointsDIM Ft,Fl,Fb,Fr,Fy,Fx:'                               Rect & point for functions    True = NOT(False)DIM KeyRecord(7):'                             Record structure for keyboard mapDIM FAsc,FDes,FWid,FLead,Fht:'              Record structure for font dimensionsDIM 40 BtnName$,40 CtrlTitle$:'                   Simple string for button namesDIM 31 FileName$,FVolume%,FileType&DIM 1 Cr$:Cr$= CHR$(13):'                                       Return characterDIM 1 Q$ :Q$ = CHR$(34):'                                             Quote markDIM PenSpecs$:'                                           Holds current pen data'DIM ScrnT,ScrnL,ScrnB,ScrnR:'                                Rect of main screen    CALL GETWMGRPORT(WMgrPort&):'                        Ptr to desktop grafport    BLOCKMOVE WMgrPort&+8,VARPTR(ScrnT),8:'        Move its rect to my structure'    Arrow       =  0:IBeam     =  1:'                                    Cursors    CrossHair   =  2:Plus      =  3    Watch       =  4:Hand      = 1000    Glass=128'    ButtonAct   =  1:FieldAct  =  2:'                              Dialog events    WindowAct   =  3:CloseAct  =  4    RefreshAct  =  5:ReturnAct =  6    TabAct      =  7:ZoomInAct =  8    ZoomOutAct  =  9:ShTabAct  = 10    ClearAct    = 11:LeftAct   = 12    RightAct    = 13:UpAct     = 14    DownAct     = 15:KeyAct    = 16    DiskAct     = 17:    HelpBtn=3    Function=1:Derivative=2:Average=3    Math=1:Cost=2:Value=3:Revenue=4:Type=Math    Hunit=50:Speed=1000    FPatternPlus=21:'***21,22,23,24    FPatternMinus=34 '***31,32,34,35    DPatternPlus=25:DPatternMinus=40 '***- 40,41,38    APatternPlus=17:'***17-20    APatternMinus=27 '***27-30    DotPattern=5  '***For drawing a dotted horizontal line'''DIM Stak(20):'                                                    My event stack    StakHi = 20:'                                             Max items on stack    SP = 0:'                                                       Stack pointer    OpenEvent  = 1:'                                    Request to open a window    CloseEvent = 2:'                             Request that a window be closed    MenuEvent  = 3:'                         Request that menu be de-highlighted    BreakEvent = 4:'                          Request that program be terminated'    Wnd1 = 1: WndHelp=2:WndAbout = 3DIM MHndl&(9):'                                        Handles for toolbox menus'DIM PaletteRect(3,3),ScreenRect(3),ViewRect(3),WindowRect(3),DRect(3) '***My Dimension statementsDIM AverageRect(3),FunctionRect(3)DIM Curve(3,1400),CurveK&(3,1400)DIM ShowFlag(3),TypeName$(3,4)FOR Type=1 TO 4:FOR Curve=1 TO 3:READ TypeName$(Curve,Type):NEXT Curve:NEXT TypeDATA f(x),df/dx,f/x,TC,MC,AC,TV,MV,AV,TR,MR,D'GOTO Queue'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Functions'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥''                                                   1/0 - Is the shift key down?'LONG FN ShiftDown  CALL GETKEYS(KeyRecord(0))END FN = FN BITTST(VARPTR(KeyRecord(3)),15)''                                               Set the font and calc its height'LONG FN GetFht(GFFont,GFSize,GFFace,GFMode)  TEXT GFFont,GFSize,GFFace,GFMode  CALL GETFONTINFO(FAsc)END FN = FAsc+FDes+FLead''                                             Capture offset values from handles'DEF FN  GetWord(GWHndl&,GWOffSet)=PEEK WORD(PEEK LONG(GWHndl&)+GWOffSet)DEF FN GetLong&(GLHndl&,GLOffSet)=PEEK LONG(PEEK LONG(GLHndl&)+GLOffSet)''                                             Place an integer on my event stack'LONG FN Push(PushVal)  IF SP+1>StakHi THEN SP=StakHi-1  SP = SP + 1  Stak(SP) = PushValEND FN''                                                Remove an integer from my stack'LONG FN Pop  IF SP Then    PopVal = Stak(SP)    SP = SP - 1  ELSE    PopVal = 0  END IFEND FN = PopVal''                                   Refresh a window without bringing it forward'LONG FN Format(Wnd2Format)  IF Wnd2Format Then    OldOutPutWnd = WINDOW(1)    WINDOW OUTPUT Wnd2Format:DrawMode=13    GOSUB Format_Wnd    IF OldOutPutWnd THEN WINDOW OUTPUT OldOutPutWnd  END IFEND FN''                                                        Locate a button by name''                                                   Draw a frame around a button''                                 Handle event if it's an arrow in an edit field'''                                            Check 1 menu item & return its name'LONG FN Chk1Item$(MHndl&,ChkItem)  FOR F=1 TO FN COUNTMITEMS(MHndl&)    CALL CHECKITEM(MHndl&,F,(F=ChkItem))  NEXT  CALL GETITEM(MHndl&,ChkItem,ItemName$)END FN=ItemName$''LONG FN ScrollingHelp(RectPtr&,ResID,HelpBtn)                                       :'Load the help text resource                                       :'  ResHndl&=FN GETRESOURCE(CVI("HELP"),ResID)  ResPtr&=USR 3(ResHndl&)              :'Lock it & return the pointer  BLOCKMOVE RectPtr&,VARPTR(HelpT),8   :'Copy the rect rec'd as 1st argument  HelpR=HelpR-15                       :'Make room for scroll bar  CALL INSETRECT(HelpT,1,1)            :'Shrink it to allow for frameCALL SETRECT(DRect(0),HelpL,HelpT,HelpR,2450) '***my mod***  HelpHndl&=FN TENEW(HelpT,HelpT)      :'Build a new TE field  HelpLen=FN SIZERESOURCE(ResHndl&)    :'Get the length of the help text  CALL TEAUTOVIEW(True,HelpHndl&)      :'Enable scrolling                                       :'Copy the text into the edit field  CALL TESETTEXT(ResPtr&,HelpLen,HelpHndl&)  CALL TECALTEXT(HelpHndl&)            :'Let the toolbox calculate line starts  CALL TEUPDATE (HelpT,HelpHndl&)      :'Show it                                       :'The number of lines in the field is                                       :'stored in the 94th position from the                                       :'start of the TE recordOldline=0     '***my mod  NumLines=PEEK WORD(PEEK LONG(HelpHndl&)+94)  CALL INSETRECT(HelpT,-1,-1)          :'Enlarge the rect ' CALL PENNORMAL:CALL FRAMERECT(HelpT) :'Frame it                                       :'Find out how tall the lines are  LineHt=PEEK WORD(PEEK LONG(HelpHndl&)+24)  VisLines=(HelpB-HelpT)/LineHt        :'Set scroll bar to 1st line beyond                                       :'visible areaIF NumLines<VisLines THEN NumLines=0 ELSE NumLines=NumLines-VisLines '***My mod***  SCROLL BUTTON HelpBtn,0,0,NumLines,VisLines,(HelpR,HelpT)-(HelpR+16,HelpB),1 '***My Mod  ResPtr&=USR 7(ResHndl&)              :'Unlock the resourceEND FN'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Queue:'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ GOSUB Initialize:'                                     Execute set-up routines Count%=1:PrintFlag=FINDERINFO(Count%,FileName$,FileType&,FVolume%) FLUSHEVENTS:'                                   Remove any events since startup IF FileName$<>"" AND PrintFlag=0 THEN gosub Open2:FN Push(1):FN Push(OpenEvent)  ON BREAK GOSUB Break:'                                        Set up handlers ON DIALOG GOSUB Dialog ON MOUSE GOSUB Mouse ON MENU  GOSUB Menu CURSOR Arrow:'                                             Restore arrow cursor''''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Loop:'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥' DIALOG ON :MOUSE ON :BREAK ON :MENU ON DIALOG OFF:MOUSE OFF:BREAK OFF:MENU OFF:'     The only place events are trapped' '                                                      Handle events on my stack'WHILE SP:'                                      Is the stack pointer above zero?  MyEvent=FN Pop:'                                  Pop the event from the stack  SELECT CASE CASE MyEvent:'                                            React to the event    CASE OpenEvent:'                                   Request to build a window      GOSUB Build    CASE CloseEvent:'                                  Request to close a window      Wnd2Close = FN Pop:'                   Pop # of window to close from stack '                                 Bring it to the front for the capture routines      IF WINDOW(0)<>Wnd2Close THEN WINDOW Wnd2Close      GOSUB Capture:'                               Capture data before closing      WINDOW CLOSE Wnd2Close:'                                          Close it    CASE MenuEvent:'                                 Request to de-hilite a menu      MENU    CASE ButtonEvent'***Next four lines are the Fn Junction version, then my modification***Newline=BUTTON(HelpBtn)LinesUp=(Oldline-Newline):IF LinesUp<>0 THEN Oldline=Newline:CALL TESCROLL(0,LineHt*LinesUp,HelpHndl&)    CASE BreakEvent:'                                       Request to terminate      IF WINDOW(0) Then'                          Close open windows 1st to handle list/region disposal        FN Push(BreakEvent)        FN Push(WINDOW(0))        FN Push(CloseEvent)      ELSE        PleaseTerminate=True      END IF  END SELECT:'                                             End of event handlers  IF PleaseTerminate=True THEN "Break":'    Cont while events remain on my stackWEND''                                                   Set cursor by mouse position' CALL GETMOUSE(My):'                                         Where is the mouse?'IF WINDOW(0)=Wnd1 ThenHitFlag=False   FOR I=1 TO 3:      IF FN PTINRECT(My,PaletteRect(I,0)) Then         IF Mact<>0 THEN gosub ChangePalette ELSE NewCsr= CrossHair         HitFlag=True      END IF   NEXT I   X=Mx-X0   FOR I=2 TO 3      IF (ABS(My-Curve(I,X))<5) AND (Mx<(XendG-2)) AND (Mx>X0) AND (My<Ymin) AND (My>Ymax) AND ShowFlag(I) Then         NewCsr= Glass         HitFlag=True      END IF   NEXT I   IF NOT HitFlag THEN NewCsr=Arrow:   CURSOR NewCsr    Mact=0END IF''                                                   Check clipboard for new text'GOTO Loop'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Dialog:'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ Act=DIALOG(0):Ref=DIALOG(Act)' IF Act=CloseAct THEN   FN Push(Ref):FN Push(CloseEvent)   RETURN END IF' IF Act=RefreshAct  Then    FN Format(Ref):    SELECT CASE WINDOW(0)      CASE Wnd1         gosub Enable_Menus      CASE WndHelp         gosub Disable_Menus    END SELECT RETURN END IF' IF Act=ClearAct THEN EDIT FIELD Ref,"":RETURN' IF Act=WindowAct Then   GOSUB Capture   WINDOW Ref   RETURN END IF' IF WINDOW(0) = Wnd1 Then'   <-- Insert WINDOW 1  DIALOG routines here   RETURN END IF''IF WINDOW(0)=WndHelp Then  IF Act=ButtonAct Then     IF Ref=HelpBtn  Then                  :'Scroll button from intro       FN Push (ButtonEvent)     END IF  END IFEND IF IF WINDOW(0) = WndAbout Then'   <-- Insert WINDOW 3  DIALOG routines here   RETURN END IFRETURN'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Mouse:'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ Mact=MOUSE(0):Mx=MOUSE(1):My=MOUSE(2)'   IF WINDOW(0)=WndAbout Then     FN Push(WndAbout):FN Push(CloseEvent)     RETURN   END IF     'IF FN PTINRECT(My,ScreenRect(0)) Then   IF BlankFlag Then      BlankFlag=False:    SaveFile.Enabled=True:SaveAsFile.Enabled=True      FnMenu.Enabled=False:CALL DRAWMENUBAR      Curve(Palette,0)=My:CurveK&(Palette,0)=My<<10      Xend=0:XendG=X0:StartCurve=Palette      IF ShowFlag(Function) THEN gosub Function:_f      IF ShowFlag(Derivative) THEN gosub Derivative:_f'      IF ShowFlag(Average) THEN gosub Average:_f/x      PSet ( X0+1,My)   ELSE      SELECT CASE Mx         CASE >XendG+2            DrawFlag=True:ShowFlag=False         CASE <XendG-2            DrawFlag=False:ShowFlag=True    Near=5:Nearest=0    FOR I=1 TO 3: '***Finds which curve is closest to point clicked***       IF ShowFlag(I)   Then  'I<>Palette          Distance=ABS(Curve(I,Mx-X0)-My)          IF (Distance<Near) THEN Near=Distance:Nearest=I       END IF    NEXT I      EndingFlag=False:ShowingFlag=False:StuckFlag=False         CASE ELSE             DrawWidth=1:DrawMode=13:PEN ,,,,0             FOR I=1 TO 3                IF ABS(Curve(I,Xend)-My)<3 THEN gosub ChangePalette             NEXT I         END SELECTDrawMode=13   END IFEND IFCALL CLIPRECT(ViewRect(0)):MxctOld=-1DO:  IF FN PTINRECT(My,ScreenRect(0)) Then    IF (Mxct>X0) AND (Mxct<XendG) THEN MxctOld1=Mxct    Mxct=MOUSE(1):Myct=MOUSE(2)    IF Mxct<>MxctOld1 OR FirstFlag THEN ChangeFlag=True ELSE ChangeFlag=False    FirstFlag=False '***To handle case of Mouse still, but new click***    IF DrawFlag Then      DelX=Mxct-XendG:      IF Xend=0 Then        SELECT CASE StartCurve          CASE=Function            CurveK&(Average,0)=Y0K&+Hunit*(CurveK&(Function,0)-Y0K&)            IF Palette=Derivative Then               CurveK&(Derivative,0)=Myct<<10            ELSE               CurveK&(Derivative,0)=Y0K&+Hunit*(((Myct<<10)-CurveK&(Palette,Xend))/DelX)            END IF          CASE=Derivative            IF Palette=Function Then                CurveK&(Function,0)=(Myct<<10)-(DelX*((CurveK&(Derivative,0)-Y0K&)/Hunit))                CurveK&(Average,0)=Y0K&+Hunit*(CurveK&(Function,0)-Y0K&)            ELSE                CurveK&(Function,0)=Y0K&:CurveK&(Average,0)=CurveK&(Derivative,0)            END IF          CASE=Average            CurveK&(Function,0)=Y0K&:CurveK&(Derivative,0)=CurveK&(Average,0)          CASE ELSE             BEEP:PRINT "StartCurve is ";StartCurve        END SELECT        FOR I=1 TO 3:Curve(I,0)=CurveK&(I,0)>>10:NEXT I      END IF      DelYK&=(Myct<<10)-CurveK&(Palette,Xend):    '  PEN 1,1,1,10 ' ***Next two lines draw and erase the rubber band***	DrawWidth=1:DrawStyle=0:DrawMode=7    LINE (Mxct,Myct) - (XendG,Curve(Palette,Xend)):DELAY 20     LINE (Mxct,Myct) - (XendG,Curve(Palette,Xend))      IF DelX>5 Then        CurveK&(Palette,Xend+1)=CurveK&(Palette,Xend)+DelYK&/DelX        SELECT CASE Palette          CASE =Function            CurveK&(Derivative,Xend+1)=Y0K&+(CurveK&(Function,Xend+1)-CurveK&(Function,Xend))*Hunit            CurveK&(Average,Xend+1)=Y0K&+Hunit*((CurveK&(Function,Xend+1)-Y0K&)/(Xend+1))          CASE =Derivative            CurveK&(Function,Xend+1)=CurveK&(Function,Xend)+((CurveK&(Derivative,Xend+1)-Y0K&)/Hunit)            CurveK&(Average,Xend+1)=Y0K&+Hunit*((CurveK&(Function,Xend+1)-Y0K&)/(Xend+1))          CASE =Average            CurveK&(Function,Xend+1)=Y0K&+(Xend+1)*((CurveK&(Average,Xend+1)-Y0K&)/Hunit)             CurveK&(Derivative,Xend+1)=(Xend+1)*CurveK&(Average,Xend+1)-(Xend)*CurveK&(Average,Xend)          CASE ELSE             BEEP:PRINT "OOPS  Palette'";Palette        END SELECT        IF ((Type<>Revenue) OR (CurveK&(Average,Xend+1)>CurveK&(Average,Xend))) AND XendG<Xmax Then           Xend=Xend+1:XendG=Xend+X0           FOR I=1 TO 3:             Curve(I,Xend)=CurveK&(I,Xend)>>10           NEXT I           gosub DrawCurves        END IF      END IF        DELAY (Speed/DelX)        IF DelX<-5 AND Xend>0 THEN gosub DrawCurves:Xend=Xend-1:XendG=Xend+X0    END IF    IF ShowFlag AND (Mxct>X0) AND (Mxct<XendG) AND ChangeFlag      Xct=Mxct-X0 THEN      'ON Nearest gosub From_Function,From_Derivative,From_Average      ShiftIsDown=FN ShiftDown:gosub Select_with_Shift    END IF  END IFUNTIL MOUSE(0)=0IF ShowFlag  THEN    EndingFlag=True    ' ON Nearest gosub From_Function,From_Derivative,From_Average    gosub Select_with_Shift    EndingFlag=False:ShowingFlag=FalseEND IFCALL CLIPRECT(ScrnT):DrawWidth=1:DrawMode=7'PEN 1,1,,10,0IF DrawFlag THEN   CALL MOVETO(X0,Curve(Derivative,0))   CALL OPENRGN:   FOR X=1 TO Xend:LINE - (X0+X,Curve(Derivative,X)):NEXT X   LINE - (XendG,Y0):LINE - (X0,Y0):LINE - (X0,Curve(Derivative,0))   CALL CLOSERGN(DRegion&)END IFFirstFlag=TrueRETURN'Select with Shift:    IF ShiftIsDown  THEN   '***FN ShiftDown       SELECT CASE Nearest          CASE =Derivative               gosub Function_from_Derivative          CASE =Average               gosub_Function_from_Average          CASE ELSE       END SELECT     ELSE       SELECT CASE Nearest          CASE =Derivative              gosub Derivative_from_Function          CASE =Average              gosub Average_from_Function          CASE ELSE       END SELECT     END IF RETURNDrawCurves:        IF ShowFlag(Function) THEN          DrawWidth=2:DrawMode=7:PEN ,,,,0:          PSet ( XendG-1,Curve(Function,Xend-1))         LINE (XendG-1,Curve(Function,Xend-1))- (XendG,Curve(Function,Xend)):           DrawWidth=1        END IF        IF ShowFlag(Derivative) THEN          PSet ( XendG-1,Curve(Derivative,Xend-1)):          LINE (XendG-1,Curve(Derivative,Xend-1)) - (XendG,Curve(Derivative,Xend))        END IF          IF (Xend MOD 2) AND ShowFlag(Average) THEN PSet ( XendG,Curve(Average,Xend))RETURN'ChangePalette:      CALL INVERTRECT(PaletteRect(Palette,0)):CALL FRAMERECT(PaletteRect(Palette,0))      CALL INVERTRECT(PaletteRect(I,0)):CALL FRAMERECT(PaletteRect(I,0))      Palette =IRETURNFrom_Function:   SELECT CASE Palette     CASE =Derivative        gosub Derivative_from_Function     CASE =Average        gosub Average_from_Function     CASE ELSE        BEEP:PRINT "Palette is";Palette   END SELECTRETURNDerivative_from_Function:   SlopeK&=(CurveK&(Function,Xct+1)-CurveK&(Function,Xct-1))/2   IF ShowingFlag THEN    '***erases last version***      DrawWidth=3:DrawMode=7:PEN ,,,,3   '***If no ChangeFlag code (i.e. flickering), should be 0 instead of 3    	LINE (Xright,Yright) - (Xleft,Yleft)      DrawWidth=1:Pen ,,,,7:LINE - (Xright,Yleft):      DrawWidth=2:PEN ,,,,6:LINE - (Xright,Yright)     LINE (MxctOld,Y0) -  (MxctOld,Curve(Derivative,MxctOld-X0))   ELSE      ShowingFlag=True   END IF   IF (NOT EndingFlag) THEN       XleftOld=Xleft:XrightOld=Xright:YleftOld=Yleft:YrightOld=Yright:      Xleft=Mxct-(Hunit>>1):IF Xleft<10 THEN Xleft=10       Xright=Xleft+Hunit:      IF Xright>XmaxPlus30 THEN Xright=XmaxPlus30:Xleft=Xright-Hunit      Yleft=Curve(Function,Xct)-(((Mxct-Xleft)*SlopeK&)>>10)-1      DeltaY=((Hunit*SlopeK&)>>10)-1      Yright=Yleft+DeltaY      IF (ABS(DeltaY)>(Ymin-Ymax)) THEN          SkipFlag=True '***The tangent won't fit verticaly--don't show it***      ELSE         SkipFlag=False         IF Yleft>Ymin OR Yleft<Ymax THEN            IF Yleft>Ymin THEN Yleft=Ymin ELSE IF Yleft<Ymax THEN Yleft=Ymax            Yright=Yleft+DeltaY:            Xleft=Mxct-(Hunit*(Curve(Function,Xct)-Yleft))/DeltaY:Xright=Xleft+Hunit         ELSE             IF Yright>Ymin OR Yright<Ymax THEN                 IF Yright>Ymin THEN Yright=Ymin ELSE IF Yright<Ymax THEN Yright=Ymax               Yleft=Yright-DeltaY:               Xleft=Mxct-(Hunit*(Curve(Function,Xct)-Yleft))/DeltaY:Xright=Xleft+Hunit            END IF         END IF      '***Yleft>Ymin OR ...      END IF   '***Abs(DeltaY)...      IF Xleft<10 OR Xright>XmaxPlus30 THEN SkipFlag=True '***Tangent won't fit horizontally***      IF SkipFlag THEN Xleft=XleftOld:Xright=XrightOld:Yleft=YleftOld:Yright=YrightOld:Mxct=MxctOld:Xct=Mxct-X0      DrawWidth=3:DrawMode=7:PEN ,,,,3	LINE (Xright,Yright) - (Xleft,Yleft)      DrawWidth=1:Pen ,,,,7:LINE - (Xright,Yleft):      DrawWidth=2:Pen ,,,,6:LINE - (Xright,Yright)  	LINE (Mxct,Y0) - (Mxct,Curve(Derivative,Xct))      MxctOld=Mxct   END IF          '***Not EndingFlagRETURNAverage_from_Function:   SlopeK&=(CurveK&(Function,Xct)-Y0K&)/Xct   IF ShowingFlag  THEN   '***erases last version***      DrawWidth=3:DrawMode=7:PEN ,,,,3   '***If no ChangeFlag code (i.e. flickering), should be 0 instead of 3	LINE (Xright,Yright) - (Xleft,Yleft)      DrawWidth=1:Pen ,,,,3:LINE - (X0,Y0):      DrawWidth=1:Pen ,,,,7:LINE (Xleft,Yleft) - (Xright,Yleft):      DrawWidth=2:Pen ,,,,6:LINE - (Xright,Yright)      LINE (MxctOld,Y0) - (MxctOld,Curve(Average,MxctOld-X0))   ELSE      ShowingFlag=True   END IF   IF (NOT EndingFlag) THEN       XleftOld=Xleft:XrightOld=Xright:YleftOld=Yleft:YrightOld=Yright:      Xleft=Mxct-(Hunit>>1):IF Xleft<10 THEN Xleft=10       Xright=Xleft+Hunit:      IF Xright>XmaxPlus30 THEN Xright=XmaxPlus30:Xleft=Xright-Hunit      Yleft=Curve(Function,Xct)-(((Mxct-Xleft)*SlopeK&)>>10)-1      DeltaY=((Hunit*SlopeK&)>>10)-1      Yright=Yleft+DeltaY      IF (ABS(DeltaY)>(Ymin-Ymax)) THEN         SkipFlag=True '***Line won't fit vertically--don't show it***      ELSE         SkipFlag=False         IF Yleft>Ymin OR Yleft<Ymax THEN           IF Yleft>Ymin THEN Yleft=Ymin ELSE IF Yleft<Ymax THEN Yleft=Ymax           Yright=Yleft+DeltaY:           Xleft=Mxct-(Hunit*(Curve(Function,Xct)-Yleft))/DeltaY:Xright=Xleft+Hunit         ELSE            IF Yright>Ymin OR Yright<Ymax THEN                IF Yright>Ymin THEN Yright=Ymin ELSE IF Yright<Ymax THEN Yright=Ymax              Yleft=Yright-DeltaY:              Xleft=Mxct-(Hunit*(Curve(Function,Xct)-Yleft))/DeltaY:Xright=Xleft+Hunit            END IF         END IF      '***Yleft>Ymin OR ...       END IF   '***Abs(DeltaY)...       IF Xleft<10 OR Xright>XmaxPlus30 THEN SkipFlag=True '***Line won't fit horizontally***       IF SkipFlag THEN Xleft=XleftOld:Xright=XrightOld:Yleft=YleftOld:Yright=YrightOld:Mxct=MxctOld:Xct=Mxct-X0       DrawWidth=3:DrawMode=7:PEN ,,,,3       LINE (Xright,Yright) - (Xleft,Yleft)       DrawWidth=1:Pen ,,,,3:LINE - (X0,Y0)       DrawWidth=1:Pen ,,,,7:LINE (Xleft,Yleft) - (Xright,Yleft):       DrawWidth=1:Pen ,,,,6:LINE - (Xright,Yright)       LINE (Mxct,Y0) - (Mxct,Curve(Average,Xct))       MxctOld=Mxct    END IF          '***Not EndingFlagRETURNFunction_from_Derivative:   DrawWidth=1:DrawMode=7   IF ShowingFlag THEN    '***erases last version***     gosub Paint_Regions_D   ELSE     ShowingFlag=True   END IF   IF (NOT EndingFlag) THEN     Tfn=Curve(Function,Xct)     IF ((Mxct+Hunit)<XmaxPlus30) AND (Tfn>Ymax) AND (Tfn<Ymin) THEN       T=Tfn:L=Mxct+1:B=Curve(Function,0):R=Mxct+Hunit       IF T>B THEN SWAP T,B:FPattern=FPatternMinus ELSE FPattern=FPatternPlus       CALL SETRECT(FunctionRect(0),L,T,R,B):       CALL SETRECTRGN(PlusRegion&,X0,Ymax,Mxct,Y0)       CALL SECTRGN(DRegion&,PlusRegion&,DPlusRegion&)       CALL SETRECTRGN(MinusRegion&,X0,Y0+5,Mxct,Ymin)       CALL SECTRGN(DRegion&,MinusRegion&,DMinusRegion&)     END IF         gosub Paint_Regions_D   END IF          '***Not EndingFlagRETURNPaint_Regions_D:    DrawWidth=1:DrawMode=7:Pen ,,,,0:     CALL FRAMERECT(FunctionRect(0))    PEN ,,,,DPatternPlus:CALL PAINTRGN(DPlusRegion&)    PEN ,,,,DPatternMinus:CALL PAINTRGN(DMinusRegion&)    PEN ,,,,FPattern:CALL PAINTRECT(FunctionRect(0))    DrawWidth=1:PEN ,,,,DotPattern:LINE (X0,Curve(Function,0)) - (FunctionRect(3),Curve(Function,0))RETURNFunction_from_Average:   DrawWidth=1:DrawMode=7   IF ShowingFlag THEN    '***erases last version***     gosub Paint_Regions_A     ELSE     ShowingFlag=True   END IF   IF (NOT EndingFlag) THEN     T=Curve(Average,Xct):Tfn=Curve(Function,Xct)     IF ((Mxct+Hunit)<Xmax+50) AND (T>Ymax) AND (T<Ymin) AND (Tfn>Ymax) AND (Tfn<Ymin) THEN       L=X0:B=Y0:R=Mxct-5       IF T>B THEN SWAP T,B:APattern=APatternMinus ELSE APattern=APatternPlus       CALL SETRECT(AverageRect(0),L,T,R,B)       T=Tfn:L=Mxct+4:B=Y0:R=Mxct+Hunit       IF T>B THEN SWAP T,B:FPattern=FPatternMinus ELSE FPattern=FPatternPlus       CALL SETRECT(FunctionRect(0),L,T,R,B)       M=Mxct     END IF       gosub Paint_Regions_A         PEN 3,1,,,3:   END IF          '***Not EndingFlagRETURNPaint_Regions_A:   DrawWidth=1:DrawMode=7:PEN ,,,,0:CALL FRAMERECT(AverageRect(0))   CALL FRAMERECT(FunctionRect(0))   PEN ,,,,APattern:CALL PAINTRECT(AverageRect(0))   PEN ,,,,FPattern:CALL PAINTRECT(FunctionRect(0))  LINE (M-4,Y0) - (M-4,Curve(Average,M-X0)), Color3    LINE (M,Y0) - (M,Curve(Function,M-X0)) RETURN'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥Menu:'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥   MenuID=MENU(0):ItemID=MENU(1)   FN Push(MenuEvent)   IF MenuID = 255 THEN:'                                           Apple menu    FN Push(WndAbout):FN Push(OpenEvent)    END IF   IF MenuID=255 THEN RETURN   ON MenuID GOTO File,Edit,Show,Type,Speed,Canned Functions,Help'"File" ON ItemID GOTO New","Open","X","Save","Save Asи","X","Page Setup","Print","X","Quit""New"    BlankFlag=True:DrawFlag=False:ShowFlag=False:CannedFlag=False  SaveFile.Enabled=False:SaveAsFile.Enabled=False   FnMenu.Enabled=True  '***enables Fn Menu***   CLS:Xend=0:XendG=X0   gosub Format Wnd"RETURN"Open" '***Add get file dialog commands***   FileName$=FILES$(1,"Cves",,FVolume%)Open2:   SELECT CASE FileName$      CASE ""         BEEP      CASE ELSE   ON ERROR GOSUB 65535'              This won't work on the first run   OPEN"I",#1,FileName$,,FVolume%'             Open the file (if it exists)   TheErr = ERROR'                            ERROR? Couldn't find it?   ON ERROR RETURN'                               reset error handling   IF TheErr THEN'                         If error exists, show alert      CALL PARAMTEXT("Couldn't locate variable file","","","")      X = FN NOTEALERT(1,0)      ERROR = 0   ELSE      INPUT#1,VarLgth&'                   No Error? Get simple var lgth      READ FILE#1,VARPTR(FirstVar),VarLgth&'                   and load      INPUT#1,VarLgth&'                                  Get array lgth      READ FILE#1,VARPTR(FirstArray(0)),VarLgth&'              and load      CLOSE #1'                                          That's a wrap!   END IF   END SELECTRETURN"Save"    IF FileName$="" THEN FileName$=FILES$(0,"Save curves as what?","Curves",FVolume%)   'FileNameFlag=True                     OPEN"R",#1,FileName$   gosub Get Simple Lgth"'                  Calc length of simple vars   PRINT #1,VarLgth&'                        Write lgth & data to file   WRITE FILE#1,VARPTR(FirstVar),VarLgth&   gosub Get_Array_Lgth'                   Repeat process for arrays   PRINT #1,VarLgth&   WRITE FILE#1,VARPTR(FirstArray(0)),VarLgth&   CLOSE #1RETURN"Save Asи"  '***Add put file dialog commands***   FileName$=FILES$(0,"Save curves as what?","Curves",FVolume%)   gosub Save             RETURN"Page Setup"DEF PAGE:IF NOT PRCANCEL THEN SetupFlag=True ELSE BEEPRETURN"Print" IF NOT SetupFlag THEN gosub Page_Setup:IF PRCANCEL THEN RETURN                DEF LPRINT : IF PRCANCEL THEN RETURNROUTE 128 : COORDINATE WINDOW:CLSCopyFlag=True:GOSUB  Format_Wnd:CopyFlag=FalseROUTE 0CLEAR LPRINT:CLOSE LPRINTRETURN"Quit" GOTO Break""Edit" 'ON ItemID GOTO Copy'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Copy"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥    CopyFlag=True   PICTURE ON (X0,Ymax)-(XendG,Ymin)      gosub Format_Wnd   PICTURE OFF,CPicture&   CopyFlag=False   L&=FN GETHANDLESIZE(CPicture&)   Scrap&=FN ZEROSCRAP   Scrap&=FN PUTSCRAP(L&,CVI("PICT"),PEEK LONG (CPicture&))   KILL PICTURE CPicture&RETURN"Show"   ShowFlag(ItemID)=NOT (ShowFlag(ItemID))   CALL CHECKITEM(MHndl&(MenuID),ItemID,ShowFlag(ItemID))   IF BlankFlag THEN RETURN   CALL CLIPRECT(ScreenRect(0))   ON ItemID GOTO Function:_f,Derivative:_f,Average:_f/xFunction:_f:   DrawWidth=2:DrawMode=7:PEN ,,,,0IF Xend>0 THEN   FOR X=X0 TO XendG-1      PSet ( X,Curve(Function,X-X0))      LINE (X,Curve(Function,X-X0))- (X+1,Curve(Function,X+1-X0)):    NEXT XEND IF     IF NOT CopyFlag THEN   CALL CLIPRECT(ScrnT)   LINE ( PaletteRect(Function,1)+3,SampleHeight) - (PaletteRect(Function,3)-4,SampleHeight)   END IF  DrawWidth=1RETURNDerivative:_f:IF Xend>0  THEN   DrawWidth=1:DrawMode=7:PEN ,,,,0   FOR X=X0 TO XendG-1                 PSet ( X,Curve(Derivative,X-X0)):           LINE (X,Curve(Derivative,X-X0)) - (X+1,Curve(Derivative,X+1-X0))   NEXT XEND IF   IF NOT CopyFlag  THEN      CALL CLIPRECT(ScrnT)      LINE ( PaletteRect(Derivative,1)+3,SampleHeight) - (PaletteRect(Derivative,3)-3,SampleHeight)   END IFRETURNAverage:_f/x:IF Xend>0 THEN              DrawWidth=1:DrawMode=7:PEN ,,,,0   FOR X=X0 TO XendG        Avge=Curve(Average,X-X0)        IF (X MOD 2) AND (Avge>Ymax) AND (Avge<Ymin) THEN PSet ( X,Avge)   NEXT XEND IF   IF NOT CopyFlag  THEN   CALL CLIPRECT(ScrnT)      FOR X=PaletteRect(Average,1)+3 TO PaletteRect(Average,3)-3 STEP 4:         PSet ( X,SampleHeight):      NEXT X   END IFRETURNType:   Type$=FN Chk1Item$(MHndl&(MenuID),ItemID)   OldType=Type:Type=ItemID:   XendTemp=Xend:Xend=0:gosub Draw_Type:Xend=XendTemp     FOR Curve=1 TO 3:        CALL SETITEM(MHndl&(ShowMenu),Curve,TypeName$(Curve,Type)):     NEXT CurveRETURNSpeed:ON ItemID GOTO Faster,Slower,Bigger,Smaller   '***,"Patterns"Faster:Speed=Speed/2:RETURNSlower:Speed=Speed*2:RETURNBigger:HunitOld=Hunit:Hunit=Hunit+10IF (Xmax-Xmin)/Hunit >4  THEN   gosub Function_Recalc   gosub Format_WndELSE   Hunit=Hunit-10END IFRETURNSmaller:HunitOld=Hunit:Hunit=Hunit-10IF (Xmax-Xmin)/Hunit <13  THEN   gosub Function_Recalc   gosub Format_WndELSE   Hunit=Hunit+10END IFRETURNFunction Recalc:   SizeFactor!=HunitOld/Hunit   FOR X=0 TO Xend      CurveK&(Function,X)=Y0K&+SizeFactor!*(CurveK&(Function,X)-Y0K&)      Curve(Function,X)=CurveK&(Function,X)>>10   NEXT XRETURNPatterns: 'Not used in VBasic version'PatNbr=1'FOR Y=100 TO 220 STEP 40:FOR X=100 TO 370 STEP 30:'DrawWidth=1:DrawMode=7:PEN ,,,,PatNbr:BOX FILL X,Y TO X+29,Y+40'PEN ,,,,0:PRINT% (X,Y+10) PatNbr:PatNbr=PatNbr+1'NEXT X:NEXT YRETURNCanned_Functions:    CannedFlag=True:CannedFn=ItemID:FirstX=0:Xend=Xmax-Xmin-30    XFactor!=1\Hunit            '****Only Calculate these things the first time    SinFactor!=1024*(1+Y0-Ymin)    ExpXFactor!=.5\Hunit:ExpFactor!=1024*(Ymax-Y0)/EXP(Xend*ExpXFactor!):    LnFactor!=1024*(Ymax-Y0)/LOG(Xend*XFactor!):    SqFactor!=1024*(Ymax-Y0)/((Xend*XFactor!)*(Xend*XFactor!)):Canned_Functions_2:    CURSOR 4:     XendG=Xend+X0    BlankFlag=False    ON CannedFn gosub Sin,Exp,Ln,Square    CurveK&(Average,0)=Y0K&+Hunit*(CurveK&(Function,0)-Y0K&)    FOR X=1 TO XendCurveK&(Function,X-1))*Hunit      CurveK&(Average,X)=Y0K&+Hunit*((CurveK&(Function,X)-Y0K&)/X)    NEXT X    CURSOR 0    IF FirstX=0 THEN gosub Format_WndRETURNSin: '***Slow but accurate version***   FOR X=FirstX TO Xend     CurveK&(Function,X)=Y0K&+SinFactor!*SIN(X*XFactor!)   NEXT X   CurveK&(Derivative,0)=Y0K&+SinFactor!   FOR X=FirstX TO Xend-1     CurveK&(Derivative,X+1)=Y0K&+(CurveK&(Function,X+1)-CurveK&(Function,X))*Hunit   NEXT X   RETURNExp:Y0)/EXP(Xend*ExpXFactor!):   FOR X=FirstX TO Xend      CurveK&(Function,X)=Y0K&+ExpFactor!*EXP(X*ExpXFactor!)      CurveK&(Derivative,X)=Y0K&+(CurveK&(Function,X)-Y0K&)/2   NEXT XRETURNLn:   FOR X=FirstX+1 TO Xend      CurveK&(Function,X)=Y0K&+LnFactor!*LOG(X*XFactor!)      CurveK&(Derivative,X)=Y0K&+LnFactor!/(X*XFactor!)   NEXT X      CurveK&(Function,0)=CurveK&(Function,1)      CurveK&(Derivative,0)=CurveK&(Derivative,1)RETURNSquare:   FOR X=FirstX TO Xend      CurveK&(Function,X)=Y0K&+SqFactor!*(X*XFactor!)*(X*XFactor!)      CurveK&(Derivative,X)=Y0K&+SqFactor!*2*(X*XFactor!)   NEXT XRETURNHelp:   FN Push(WndHelp):FN Push(OpenEvent)   '***The rest of this is from the apple menu version. Unnecessary?        windowX:                      RETURN''''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥Cut:'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ GOSUB Copy:GOTO Clear RETURN'''''''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Paste"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ GOSUB Clear CALL TEINSERT(VARPTR(Clip$)+1,LEN(Clip$),TEHANDLE(WINDOW(0)))RETURN''''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Clear"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ CALL TEDELETE(TEHANDLE(WINDOW(0)))RETURN'''''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Break"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥' IF WINDOW(0) THEN FN Push(BreakEvent):RETURN' IF ResRef>0 THEN CALL CLOSERESFILE(ResRef)' FOR X = 1 TO 9:'                                               Dispose of menus   CALL DISPOSEMENU(MHndl&(X)) NEXT'   IF DRegionFlag THEN CALL DISPOSERGN(DRegion&):'DRegionFlag=FalseCALL DISPOSERGN(PlusRegion&):CALL DISPOSERGN(MinusRegion&)CALL DISPOSERGN(DPlusRegion&):CALL DISPOSERGN(DMinusRegion&)'END''''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Window Routines'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥Build:'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ Wnd2Build = FN Pop:'                                    Pop window # from stack  SELECT CASE Wnd2Build   CASE Wnd1     T = 0:L = 0:B = 286:R = 484:'                       Set TLBR to window size'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2,(ScrnB/2+8)-B/2)     WINDOW Wnd2Build,"CurveDraw",(L,T)-(R,B),265 '257   '5   CASE WndHelp     WINDOW Wnd2Build,"Help",(LW2,TW2)-(RW2,BW2),9 '1   '5	     FirstHelpFlag=False     CASE WndAbout     WINDOW Wnd2Build,"About Curve Draw",( 30, 30)-( 277, 221),-4  END SELECTRETURN'Setup_Help_Window:    T=0:L=3:B=WINDOW(3)-2:R=WINDOW(2)+14        :'Build a rectangle that will be cleared    CALL PENNORMAL                     :'for the help field.    CALL ERASERECT(T)    TEXT 3,9,0,0                     :'Set to program font    FN ScrollingHelp(VARPTR(T),300,HelpBtn)  :'Have the function do the grunt workRETURN' '╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥Format_Wnd:'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥' CALL GETPENSTATE(PenSpecs$):'                      Record the current pen state' TxFont=PEEK WORD(WINDOW(14)+68):'                 Record the current font specs TxFace=PEEK WORD(WINDOW(14)+70) TxMode=PEEK WORD(WINDOW(14)+72) TxSize=PEEK WORD(WINDOW(14)+74)'' IF WINDOW(1) = Wnd1 THEN'   ***This chunk draws the axes and labels them***   IF NOT CopyFlag THEN gosub Screen_Size:CLS   T = Ymax:L = X0-6:B = Ymin-6:R = X0-6   DrawWidth=6:DrawMode=13:'   PEN ,,,,0:  LINE (L,T) - (R,B)   T = Y0:B = Y0:R = Xmax LINE (L,T) - (R,B)  DrawWidth=1:DrawMode=13: ' PEN ,,,,19   T = Y0+14:L = X0+Hunit:B = Y0:R = LDrawMode=13:  'PEN ,,,,0   FOR I=1 TO (Xmax-Xmin-20)/Hunit      LINE (L,T) - (R,B)      L = L+Hunit:R = L   NEXT I   T = Y0+10:L = X0+Hunit-10:B = T+12:R = L+20   TEXT 3,9,,0   FOR I=1 TO (Xmax-Xmin-20)/Hunit      Temp$ = STR$(I):      CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1)      CALL OFFSETRECT(T,Hunit,0):'    NEXT I   gosub Draw_TypeEND IF:'                                                     End of Wnd1 formatIF WINDOW(1) = WndHelp THEN   IF NOT FirstHelpFlag THEN gosub Cleanup_Help_Window   gosub Setup_Help_Window"END IF' IF WINDOW(1) = WndAbout THEN   T = 2:L = 83:B = 18:R = 166   TEXT 0,12,0,0   Temp$ = "Curve Draw"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 23:L = 6:B = 88:R = 241   TEXT 3,10,,0   Temp$ = "is intended to help"+Cr$+"mathematics students intuit the relations"+Cr$+"among a function, its derivative, and its average"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1)     T = 63:L = 23:B = 102:R = 217   Temp$ = "and economics students intuit the relations"+Cr$+"among Total, Marginal, and Average."   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1)   T = 103:L = 47:B = 145:R = 185   Temp$ = "Written for Living Paper"+Cr$+"by David Friedman."+Cr$+"╘David Friedman"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1) T = 152:L = 28:B = 188:R = 215   TEXT ,9,,0   Temp$ = "Thanks to Zedcor for ZBasic 5.0"+Cr$+"and Staz for Program Generator II"+Cr$+"I never would have done it without you."   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1) END IF:'                                                 End of WndAbout format''TEXT TxFont,TxSize,TxFace,TxMode:'                        Restore the font specs' CALL SETPENSTATE(PenSpecs$):'                                   Restore the pen'RETURN'Draw_Type:   TEXT 0,12,,0   IF Type=Math THEN Temp$ = "X" ELSE Temp$="Q"   T = Y0-5:L = Xmax+10:B = T+16:R = L+14   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)IF NOT CopyFlag THEN '***Don't do this if you are copying to the clipboard***   DrawWidth=2:DrawMode=7:PEN ,,,11:BOX FILL PaletteRect(Function,1)-4,1 TO PaletteRect(Average,3)+4,28   '***Frames Palette'   ***This chunk draws the palette***   gosub Palette_Size  DrawWidth=2:DrawMode=13: BOX PaletteRect(Function,1)-1,1 TO PaletteRect(Average,3)+1,27   '***Frames Palette   TEXT 0,12,0,0:DrawWidth=1:DrawMode=13:PEN ,,,,0   FOR Curve=1 TO 3         '***This labels the palette***      CALL TEXTBOX(VARPTR(TypeName$(Curve,Type))+1,LEN(TypeName$(Curve,Type)),PaletteRect(Curve,0), 1)   NEXT Curve   CALL INVERTRECT(PaletteRect(Palette,0))   FOR I=1 TO 3:CALL FRAMERECT(PaletteRect(I,0)):NEXT IEND IF   IF NOT BlankFlag THEN      IF ShowFlag(Function) THEN CALL CLIPRECT(ScreenRect(0)):gosub Function_f :      IF ShowFlag(Derivative) THEN CALL CLIPRECT(ScreenRect(0)):gosub Derivative_f:      IF ShowFlag(Average) THEN CALL CLIPRECT(ScreenRect(0)):gosub Average_f/x:   END IFRETURN''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥Capture:'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥''   IF WINDOW(0) = Wnd1 THEN'      <-- Insert WINDOW 1  capture routines here   END IF   IF WINDOW(0)=WndHelp THEN     gosub Cleanup_Help_Window  TW2 = -WINDOW(11):LW2 = -WINDOW(10):BW2 = TW2+WINDOW(3):RW2 = LW2+WINDOW(2):'      Set TLBR to window size   END IF IF WINDOW(0) = WndAbout THEN'   <-- Insert WINDOW 3  capture routines here END IFRETURNCleanup_Help_Window:	     FirstHelpFlag=True   IF HelpHndl& THEN              :'Is the handle valid?      CALL TEDISPOSE(HelpHndl&)    :'Dump the field we created      BUTTON CLOSE HelpBtn         :'Send the scroll button packin'      HelpHndl& = 0                :'Zero out the handle   END IFRETURN'''''''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥Initialize:'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ FN Push(1):'                                      Push first window on to stack FN Push(OpenEvent):'                   Tell my event manager to open the window APPLE MENU "About CurveDraw..." FileMenu = 1 MHndl&(FileMenu) = FN NEWMENU(FileMenu,"File")   CALL APPENDMENU(MHndl&(FileMenu),"New/N")   CALL APPENDMENU(MHndl&(FileMenu),"Open/O")   CALL APPENDMENU(MHndl&(FileMenu),"-")   CALL APPENDMENU(MHndl&(FileMenu),"(Save/S")   CALL APPENDMENU(MHndl&(FileMenu),"(Save Asи")   CALL APPENDMENU(MHndl&(FileMenu),"-")   CALL APPENDMENU(MHndl&(FileMenu),"Page Setup")   CALL APPENDMENU(MHndl&(FileMenu),"Print/P")   CALL APPENDMENU(MHndl&(FileMenu),"-")   CALL APPENDMENU(MHndl&(FileMenu),"Quit/Q")   CALL INSERTMENU(MHndl&(FileMenu),0)EditMenu=2 MHndl&(EditMenu) = FN NEWMENU(EditMenu,"Edit")   CALL APPENDMENU(MHndl&(EditMenu),"Copy/C") '***was Copy Screen***   CALL INSERTMENU(MHndl&(EditMenu),0) ShowMenu = 3 MHndl&(ShowMenu) = FN NEWMENU(ShowMenu,"Show")   ShowFunction = 1   CALL APPENDMENU(MHndl&(ShowMenu),"Function: f!/F")   ShowDerivative = 2   CALL APPENDMENU(MHndl&(ShowMenu),"Derivative:!/D")   CALL SETITEM(MHndl&(ShowMenu),ShowDerivative,"Derivative: df/dx")   ShowAverage = 3   CALL APPENDMENU(MHndl&(ShowMenu),"Average: !/A")   CALL SETITEM(MHndl&(ShowMenu),ShowAverage,Average_f/x)   CALL INSERTMENU(MHndl&(ShowMenu),0)   FOR I=1 TO 3:ShowFlag(I)=True:NEXT I TypeMenu = 4 MHndl&(TypeMenu) = FN NEWMENU(TypeMenu,"Type")   MathType = 1   CALL APPENDMENU(MHndl&(TypeMenu),"Math!")   CostType = 2   CALL APPENDMENU(MHndl&(TypeMenu),"Cost")   ValueType = 3   CALL APPENDMENU(MHndl&(TypeMenu),"Value")   RevenueType = 4   CALL APPENDMENU(MHndl&(TypeMenu),"Revenue")   CALL INSERTMENU(MHndl&(TypeMenu),0)   Type=MathType SpeedMenu = 5 MHndl&(SpeedMenu) = FN NEWMENU(SpeedMenu,"Options")   CALL APPENDMENU(MHndl&(SpeedMenu),"faster")   CALL APPENDMENU(MHndl&(SpeedMenu),"slower")   CALL APPENDMENU(MHndl&(SpeedMenu),"Bigger/+")   CALL APPENDMENU(MHndl&(SpeedMenu),"Smaller/-")  ' CALL APPENDMENU(MHndl&(SpeedMenu),"Patterns")   CALL INSERTMENU(MHndl&(SpeedMenu),0) FnMenu = 6 MHndl&(FnMenu) = FN NEWMENU(FnMenu,"f(x)=    ")   SinType = 1   CALL APPENDMENU(MHndl&(FnMenu)," ")   CALL SETITEM(MHndl&(FnMenu),SinType,"sin(x)")   ExpType = 2   CALL APPENDMENU(MHndl&(FnMenu)," ")   CALL SETITEM(MHndl&(FnMenu),ExpType,"Exp(x/2)")   LnType = 3   CALL APPENDMENU(MHndl&(FnMenu)," ")   CALL SETITEM(MHndl&(FnMenu),LnType,"ln(x)")   SqType = 4   CALL APPENDMENU(MHndl&(FnMenu)," ")   CALL SETITEM(MHndl&(FnMenu),SqType,"x*x")   CALL INSERTMENU(MHndl&(FnMenu),0) HelpMenu = 7 MHndl&(HelpMenu) = FN NEWMENU(HelpMenu,"Help")   HelpItem = 1   CALL APPENDMENU(MHndl&(HelpMenu),"Help")   CALL INSERTMENU(MHndl&(HelpMenu),0)  CALL DRAWMENUBAR  DRegion&=FN NEWRGN:PlusRegion&=FN NEWRGN:MinusRegion&=FN NEWRGN  DPlusRegion&=FN NEWRGN:DMinusRegion&=FN NEWRGN  gosub Palette_Size  gosub Screen_Size  TW2 = 0:LW2 = 0:BW2 = 260:RW2 = 464:'      Set TLBR to window size'             Offset the rect to the center of the screen  CALL OFFSETRECT(TW2,ScrnR/2-RW2/2,(ScrnB/2+8)-BW2/2)  Palette=Function   '***Function initially selected***   BlankFlag=True:FirstHelpFlag=True  CannedFlag=False:CopyFlag=False:SetupFlag=False RETURNPalette_Size:   PWidth=20:   FOR Curve=1 TO 3     W= 8+FN STRINGWIDTH(TypeName$(Curve,Type))     IF W>PWidth THEN PWidth=W   NEXT Curve   ScnCtr=WINDOW(2)/2:T=11:B=27:SampleHeight=T-5   L=ScnCtr-1.5*PWidth:R=L+PWidth   CALL SETRECT(PaletteRect(Function,0),L,T,R,B)   L=R-1:R=L+PWidth   CALL SETRECT(PaletteRect(Derivative,0),L,T,R,B)   L=R-1:R=L+PWidth   CALL SETRECT(PaletteRect(Average,0),L,T,R,B)RETURNScreen_Size:   XmaxOld=Xmax   X0=30:Xmax=WINDOW(2)-30:XmaxPlus30=Xmax+30   IF CannedFlag AND (XmaxOld<Xmax) THEN     FirstX=Xend:Xend=Xmax-Xmin-30     gosub Canned_Functions_2   END IF   Y0old=Y0	   Ymin=WINDOW(3)-20: Ymax=30:Y0=(Ymax+Ymin+Ymin)/3   Y0K&=Y0<<10   T = Ymax:L = X0:B = Ymin:R = Xmax+20   CALL SETRECT(ScreenRect(0),L,T,R,B)   T = Ymax:L = 10:B = Ymin:R = Xmax+40   CALL SETRECT(ViewRect(0),L,T,R,B)   gosub Function_Recalc_2 '***Add because Y0 changes.RETURN"Function Recalc 2"   DeltaY0K&=(Y0-Y0old)<<10   FOR X=0 TO Xend      FOR I=1 TO 3         CurveK&(I,X)=CurveK&(I,X)+DeltaY0K&         Curve(I,X)=CurveK&(I,X)>>10       NEXT I   NEXT X'***Next bit redefines DRegion&***   CALL MOVETO(X0,Curve(Derivative,0))   CALL OPENRGN:   FOR X=1 TO Xend:LINE - (X0+X,Curve(Derivative,X)):NEXT X   LINE - (XendG,Y0):LINE - (X0,Y0):LINE - (X0,Curve(Derivative,0))   CALL CLOSERGN(DRegion&)RETURNDisable_Menus:   FOR MenuType=FileMenu TO SpeedMenu      XXX.Enabled=False(MenuType),0)      NEXT MenuType   MENURETURNEnable_Menus:   FOR MenuType=FileMenu TO SpeedMenu      XXX.Enabled=True(MenuType),0)      NEXT MenuType   MENURETURN'***Save/Load Code***Get_Simple_Lgth:'                   get length of simple variables   VarLgth& = VARPTR(LastVar)-VARPTR(FirstVar)'     size is last-firstRETURNGet_Array_Lgth:   DIM LastArray(1)'       have to DIM here so array is at end of list   VarLgth& = VARPTR(LastArray(1))-VARPTR(FirstArray(0))'  calc lengthRETURN'***Ends Save/Load Code***'