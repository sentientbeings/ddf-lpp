' ЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗ'  PICT Window Filter'  by Ross W. Lambert & Spotz'  Copyright (c) 1992'  Ariel Publishing, Inc.' ЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗ'===============================================================================INCLUDE FILE _aplInclCOMPILE 0,_MacsbugLabels_strResource_caseInsensitive'set by PG:PROGLOBALS "PG PRO.GLBL"'include standard global fileEND GLOBALSDEFSTR LONG'needed for CVI'sINCLUDE "@Header.INCL"GOTO "PW:Start"'ALWAYS jump around functions'_________________________________________'нннр Functions сннннннннннннннннннннннннн'ббббббббббббббббббббббббббббббббббббббббб' makes an offscreen pix/bitmapLOCAL FN MakePort&(rect&,inColor,QD32)DIM t,l,b,rDIM portRect.8DIM red,green,bluet;8 = rect&OffPort& = 0CALL OFFSETRECT(t,-l,-t)' adjust for local coords nowCALL GETPORT(currPort&)portRect;8 = currPort&+_portRectLONG IF QD32CALL GETGWORLD(currPort&,currDev&)QDErr = FN NEWGWORLD(OffPort&,0,t,0,0,0)LONG IF NOT QDErrCALL SETGWORLD(OffPort&,0)red=0:green=0:blue=0CALL RGBFORECOLOR(red)red=-1:green=-1:blue=-1CALL RGBBACKCOLOR(red)CALL ERASERECT(t)END IFXELSEOffPort& = FN NEWPTR(192)LONG IF OffPort&LONG IF inColor' we've got Color QuickDrawmaxDevice& = FN GETMAXDEVICE(portRect)oldDevice& = FN GETGDEVICECALL SETGDEVICE(maxDevice&)CALL OPENCPORT(OffPort&)' copies info from active portpMapHndl& = [OffPort&+_portPixMap]OSErr = FN HLOCK(pMapHndl&)theDepth = {[pMapHndl&]+_PMpixelSize}XELSEtheDepth = 1' black & whiteCALL OPENPORT(OffPort&)' copies info from active portEND IFMemAvail& = FN FREEMEMRowBytes = ((theDepth*(r-l)+15)/8) AND &7FFEMapSz& = RowBytes * ((b-t)+1)' "Pre-flight" and check for enough RAM before asking for it.LONG IF MapSz& < MemAvail& + 25000'24K extra for window memory!BLOCKMOVE @t,OffPort&+_portRect,8' make port rect right sizeVisRgn& = [OffPort&+_visRgn]' get visible regionCALL RECTRGN(VisRgn&,t)' make it our rectClipRgn& = [OffPort&+_clipRgn]' do same for clip regionCALL RECTRGN(ClipRgn&,t)Map& = FN NEWPTR(MapSz&)' pointer for bitmap and screenbitsLONG IF inColor% [pMapHndl&]+_PMpixelSize,theDepth& [pMapHndl&]+_baseAddr,Map&% [pMapHndl&]+_rowBytes,RowBytes+&8000' bytes per rowBLOCKMOVE @t,[pMapHndl&]+_bounds,8XELSE& OffPort&+_portBits,Map&% OffPort&+_portBits+_rowBytes,RowBytesBLOCKMOVE @t,OffPort&+_portBits+_bounds,8END IFCALL ERASERECT(t)XELSE' out of memory!LONG IF inColorCALL CLOSECPORT(OffPort&)XELSECALL CLOSEPORT(OffPort&)END IFOSErr = FN DISPOSPTR(OffPort&)OffPort& = 0END IFEND IFIF inColor THEN CALL SETGDEVICE(oldDevice&)END IFIF QD32 THEN CALL SETGWORLD(currPort&,0) ELSE CALL SETPORT(currPort&)'point us where we wereEND FN = OffPort&'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN KillPort(Port&,inColor,QD32)LONG IF Port&LONG IF QD32CALL DISPOSEGWORLD(Port&)' it's really a GWORLDXELSELONG IF inColorpMapHndl& = [Port&+_portPixMap]portBits& = [[pMapHndl&]+_baseAddr]OSErr = FN HUNLOCK(pMapHndl&)CALL CLOSECPORT(Port&)' nukes visrgn & cliprgnOSErr = FN DISPOSPTR(portBits&)' we made it, we ditch itXELSEOSErr = FN DISPOSPTR([Port&+_portBits])' nukes our pointerCALL CLOSEPORT(Port&)' nukes visrgn & cliprgnEND IFOSErr = FN DISPOSPTR(Port&)' and the port's memoryEND IFEND IFEND FN	'клллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл_pG3wRefCon = 36LOCAL FN isPICTWnd' gets PG refcon value for windowisPICT = _FalseresHndl& = FN GETRESOURCE(_"pG3w",gWhichClass)LONG IF resHndl&type& = [[resHndl&]+_pG3wRefCon]LONG IF type& = _"PICT" OR type& = _"PIC2"isPICT = _ZTrueEND IFEND IFEND FN = isPICT'клллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл_pwOurRecSz = 14LOCAL FN initRecord(pHndl&,OffScrn)' initializes pict window recordpRecHndl& = FN NEWHANDLE(_pwOurRecSz)' allocate 10 byte recordLONG IF pRecHndl&' did we get it?& [pRecHndl&], pHndl&' first 4 bytes are PICT handle% [pRecHndl&]+4,1' x offset% [pRecHndl&]+6,1' y offsetOffPort& = 0LONG IF OffScrn' set up offscreen drawinginColor = (SYSTEM(_crntDepth) > 1)QD32    = (SYSTEM(_maxColors) = 32)pRect&  = [pHndl&]+2OffPort& = FN MakePort&(pRect&,inColor,QD32)LONG IF OffPort&CURSOR _watchCursorCALL GETPORT(currPort&)IF QD32 THEN CALL SETGWORLD(OffPort&,0) ELSE CALL SETPORT(OffPort&)PICTURE (0,0),pHndl&' draw offscreenIF QD32 THEN CALL SETGWORLD(currPort&,0) ELSE CALL SETPORT(currPort&)CURSOR _arrowCursorEND IFEND IF& [pRecHndl&]+8,OffPort&' offscreen cachehndlFlags = FN HGETSTATE(pHndl&)'save current handle infoOSErr = FN HNOPURGE(pHndl&)'don't allow purge% [pRecHndl&]+12,hndlFlags' save old handle flagsFN pGreplaceRes(pRecHndl&,_"wVar",WINDOW(1),"")END IFEND FN'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN getWPictpHndl& = 0pRecHndl& = FN GETRESOURCE(_"wVar",WINDOW(1))LONG IF pRecHndl&pHndl& = [[pRecHndl&]]XELSE' no "wVar" resource yetCALL GETWTITLE(WINDOW(14),wTitle$)' only possible if res pictpHndl& = FN GETNAMEDRESOURCE(_"PICT",wTitle$)bldOS = _False' build offscreen flagresHndl& = FN GETRESOURCE(_"pG3w",gWhichClass)LONG IF resHndl&IF [[resHndl&]+_pG3wRefCon] = _"PIC2" THEN bldOS = _ZTrueEND IFIF pHndl& THEN FN initRecord(pHndl&,bldOS)END IFEND FN = pHndl&'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN getOffsets(ptr&)' get last x and y offsetspRec& = FN GETRESOURCE(_"wVar",WINDOW(1))LONG IF pRec&& ptr&,[[pRec&]+4]' long = two shortsEND IFEND FNLOCAL FN setOffsets(ptr&)LONG IF ptr&pRec& = FN GETRESOURCE(_"wVar",WINDOW(1))LONG IF pRec&l& = [ptr&]' long = two shorts from caller& [pRec&]+4,l&' put into resourceFN pGreplaceRes(pRec&,_"wVar",WINDOW(1),"")' update chgsEND IFEND IFEND FN'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN getOS' fetch offscreen port/GWORLDOffPort& = 0' returns 0 if there isn't onepRec& = FN GETRESOURCE(_"wVar",WINDOW(1))LONG IF pRec&OffPort& = [[pRec&]+8]END IFEND FN = OffPort&'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN releasePICT' release all acquired memorypRecHndl& = FN GETRESOURCE(_"wVar",WINDOW(1))LONG IF pRecHndl&' handle to our wVar resourceoldFlags  = {[pRecHndl&]+12}pHndl&    = [[pRecHndl&]]OSErr = FN HSETSTATE(pHndl&,oldFlags)' restore MemMgr flagsOffPort& = FN getOSLONG IF OffPort&inColor = (SYSTEM(_crntDepth) > 1)QD32    = (SYSTEM(_maxColors) = 32)FN KillPort(OffPort&,inColor,QD32)END IFcurrRes = FN CURRESFILEhomeRes = FN HOMERESFILE(pRecHndl&)' find home of our recordCALL USERESFILE(homeRes)' make it the current res fileCALL RMVERESOURCE(pRecHndl&)' ditch wVar rez and its handleCALL USERESFILE(currRes)' restore old res file ptrOSErr = FN DISPOSHANDLE(pRecHndl&)END IFEND FN'клллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл_wndHScroll = 8000_wndVScroll = 8001_pwScrollAmt      = 15' adjust to change coarseness of scrollLOCAL FN updatePICTWndDIM winT,winL,winB,winRDIM dt,dl,db,drDIM pT,pL,pB,pRDIM oldX,oldY' scrolling offsetswinT = 0 : winL = 0winB = WINDOW(_height)-1winR = WINDOW(_width) -1upRgn& = FN NEWRGNpHndl& = FN getWPictLONG IF pHndl&hState = FN HGETSTATE(pHndl&)OSErr = FN HNOPURGE(pHndl&)LONG IF BUTTON&(_wndVScroll)vert = BUTTON(_wndVScroll):IF vert = 0 THEN vert = _pwMinhorz = BUTTON(_wndHScroll):IF horz = 0 THEN horz = _pwMinXELSEvert = _pwMinhorz = _pwMinEND IFFN getOffsets(@oldX)dx = (horz - oldX) * _pwScrollAmtdy = (vert - oldY) * _pwScrollAmtoldX = horz : oldY = vertFN setOffsets(@oldX)LONG IF dx <> 0 OR dy <> 0CALL SCROLLRECT(winT,-dx,-dy,upRgn&)CALL SETCLIP(upRgn&)' clip drawing to update regionXELSECALL CLIPRECT(winT)END IFx = -(horz-1)*_pwScrollAmt : IF x > 0 THEN x = 0y = -(vert-1)*_pwScrollAmt : IF y > 0 THEN y = 0offScrn& = FN getOSLONG IF offScrn&=0PICTURE (x,y),pHndl&XELSECALL GETPORT(curr&)dt;8 = @winTCALL OFFSETRECT(dt,-x,-y)pT;8 = [pHndl&]+2' get pict rectCALL OFFSETRECT(pT,-pL,-pT)' localize itOSErr = FN SECTRECT(dt,pT,dt)' don't copy junk beyond pictwinT;8 = @dtCALL OFFSETRECT(winT,-winL,-winT)' make source & dest the sameCALL COPYBITS(#offScrn&+2,#curr&+2,dt,winT,_srcCopy,0)END IFCALL DISPOSERGN(upRgn&)CALL VALIDRECT(winT)OSErr = FN HSETSTATE(pHndl&,hState)END IFEND FN'клллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл_pwMin = 1LOCAL FN setScrollbarsDIM t,l,b,rpHndl& = FN getWPictLONG IF pHndl&LONG IF BUTTON&(_wndVScroll)vert = BUTTON(_wndVScroll):IF vert = 0 THEN vert = _pwMinhorz = BUTTON(_wndHScroll):IF horz = 0 THEN horz = _pwMinXELSEvert = _pwMinhorz = _pwMinEND IFt;8 = [pHndl&]+2pHt = b-t : pWdth = r-lLONG IF pHt + (vert*_pwScrollAmt) > WINDOW(_height)pg = (WINDOW(_height)-10)/_pwScrollAmtmax = (pHt - pg + vert)/_pwScrollAmtSCROLL BUTTON _wndVScroll,vert,_pwMin,max,pg,,1XELSESCROLL BUTTON _wndVScroll,0,0,0,0,,1END IFLONG IF pWdth + (horz*_pwScrollAmt) > WINDOW(_width)pg = (WINDOW(_width)-10)/_pwScrollAmtmax = (pWdth - pg + horz)/_pwScrollAmtSCROLL BUTTON _wndHScroll,horz,_pwMin,max,pg,,2XELSESCROLL BUTTON _wndHScroll,0,0,0,0,,2END IFEND IFEND FN'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN attachPICT(pHndl&)DIM t,l,b,rt = 0 : l = 0 : b = 8192 : r = 8192resHndl& = FN GETRESOURCE(_"pG3w",gWhichClass)LONG IF resHndl&IF [[resHndl&]+_pG3wRefCon] = _"PIC2" THEN OffScrn = _ZTrue ELSE OffScrn=0FN initRecord(pHndl&,OffScrn)vHndl& = BUTTON&(_wndVScroll)LONG IF vHndl&' is there a vertical scrollbar?CALL SETCTLVALUE(vHndl&,_pwMin)' set it to minimumEND IFhHndl& = BUTTON&(_wndHScroll)LONG IF hHndl&' is there a horz scrollbar?CALL SETCTLVALUE(hHndl&,_pwMin)' set it to minimumEND IFCALL INVALRECT(t)' make sure we updateEND IFEND FN'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN attachPICTID(resID)' alternative to FN attachPICTpHndl& = FN GETPICTURE(resID)' ...get resource via resIDresHndl& = FN GETRESOURCE(_"pG3w",gWhichClass)LONG IF resHndl&IF [[resHndl&]+_pG3wRefCon] = _"PIC2" THEN OffScrn = _ZTrue ELSE OffScrn=0END IFIF pHndl& THEN FN attachPICT(pHndl&)END FN'кллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллLOCAL FN printPICTWndDEF LPRINTLONG IF NOT PRCANCELpHndl& = FN getWPictLONG IF pHndl&ROUTE 128PICTURE (0,0),pHndl&ROUTE 0CLOSE LPRINTEND IFEND IFEND FN'клллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл"PW:Start"LONG IF FN isPICTWndSELECT gActionCASE _buttonActionFN updatePICTWndCASE _windowActionSELECT gSubActionCASE _windowUpdateFN updatePICTWndFN setScrollbarsCASE _windowCloseFN releasePICTEND SELECTEND SELECTEND IF