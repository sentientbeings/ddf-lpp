'***To Do***'Levels--fine tune. Fix high level problem.'Main window not refreshing part at beginning.'Finish adding Snd code'Smoother scrolling of help screens''     This ZBasic source code was created'     using pGII ver 1.06'     Copyright 1990 Staz Software'' Line 10'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Configuration Remarks'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'         Default variable type:Integer'   Space req'd after key words:Yes'                  Array base 1:No'                     File Type:lFlx '                  Creator Type:Grgl' DEF OPEN ="lFlxGrgl" BUNDLE = 1''WINDOW OFF:COORDINATE WINDOWDEF MOUSE=-1:CURSOR 4:WIDTH -2'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Resources'╥╥╥оооооооооооооооооооline 30ооооооооооооооооооооооооооооооооо╥╥╥Hndl& = FN GETRESOURCE(CVI("Grgl"),0)LONG IF Hndl& = 0  ResRef = FN OPENRESFILE("grglflx 2.res")  IF ResRef=-1 THEN STOPXELSE   ResRef=-1END IF''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Equates'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥DIM FirstVar,FirstArray(1)'                     We must insure thatDIM VarSrcPtr&,VarLgth&'          these items are FIRST in the list'***Ends Save/Load Code***DIM T,L,B,R:'                                                 Generic rectanglesDIM HelpT,HelpL,HelpB,HelpR            :'The rect that the function will fitDIM TW2,LW2,BW2,RW2   '  Rectangle for WndHelp (Help window)DIM My,Mx,GlobalY,GlobalX,LocalY,LocalX:'                           Mouse pointsDIM Ft,Fl,Fb,Fr,Fy,Fx:'                               Rect & point for functionsDIM TopRect(3),BottomRect(3)    True = NOT(False)DIM KeyRecord(7):'                             Record structure for keyboard mapDIM FAsc,FDes,FWid,FLead,Fht:'              Record structure for font dimensionsDIM 40 BtnName$,40 CtrlTitle$:'                   Simple string for button namesDIM 1 Cr$:Cr$= CHR$(13):'                                       Return characterDIM 1 Q$ :Q$ = CHR$(34):'                                             Quote markDIM PenSpecs$:'                                           Holds current pen dataDIM HiName$(1,9),HiScore(1,9),HiStartLevel(1,9),HiEndLevel(1,9)   '***High Score Arrays***DIM ErrorFactor(2),Normal(100)  '***Multiplicative factors for random error; NormalDIM HelpText$(6)    '***Kinds of Help availableDIM Y(2,410),Ymax(1),Ymin(1),Ytop(1),Ybottom(1)DIM 255 NamePlusScore$,FTemp$,Snd$(10)DIM EnvVersion,MachineType,SystemVersion,ProcessorDIM HasFPU,KeyBoardType,AtDrvrVersNum,SysVRefNum   'Variables For Environs'DIM ScrnT,ScrnL,ScrnB,ScrnR:'                                Rect of main screen    CALL GETWMGRPORT(WMgrPort&):'                        Ptr to desktop grafport    BLOCKMOVE WMgrPort&+8,VARPTR(ScrnT),8:'        Move its rect to my structure'    Arrow       =  0:IBeam     =  1:'                                    Cursors    CrossHair   =  2:Plus      =  3    Watch       =  4:Hand      = 1000'    ButtonAct   =  1:FieldAct  =  2:'                              Dialog events    WindowAct   =  3:CloseAct  =  4    RefreshAct  =  5:ReturnAct =  6    TabAct      =  7:ZoomInAct =  8    ZoomOutAct  =  9:ShTabAct  = 10    ClearAct    = 11:LeftAct   = 12    RightAct    = 13:UpAct     = 14    DownAct     = 15:KeyAct    = 16    DiskAct     = 17    TopBox=0:BottomBox=1                      '***Which box the curve is being drawn in    Ytop(TopBox)=8:Ybottom(TopBox)=111    Ytop(BottomBox)=159:Ybottom(BottomBox)=262   '***Top and bottom of drawing boxes    BoxHeight=Ybottom(0)-Ytop(0)    Cycle=1:Pseudo=2                                '***Values of CycleType    HighestLevel=8    Xmin=4:Xmax=409                              '***Left and right of the drawing boxes    Snd$(0)="Correct":Snd$(1)="Wrong":Snd$(2)="Lucky":Snd$(3)="Impressive"  GOSUB "New Parameters":X=Xmin+DeltaX    TimeDelay=5:TTime&=FN TICKCOUNT:GoFlag=False'''DIM Stak(20):'                                                    My event stack    StakHi = 20:'                                             Max items on stack    SP = 0:'                                                       Stack pointer    OpenEvent  = 1:'                                    Request to open a window    CloseEvent = 2:'                             Request that a window be closed    MenuEvent  = 3:'                         Request that menu be de-highlighted    BreakEvent = 4:'                          Request that program be terminated'    WndMain = 1    WndHelp = 2    WndSetup = 3    WndSetup2 = 4    WndNewHiScore = 5    WndShowHiScore = 6    WndAbout = 7'    HelpBtn=1 '***Scroll button of Help window'    HelpText$(0)="Instructions":HelpText$(WndMain)="MainHelp":    HelpText$(WndSetup)="SetupHelp":HelpText$(WndSetup2)="Setup2Help":    HelpText$(WndNewHiScore)="NewHiScoreHelp":HelpText$(WndShowHiScore)="ShowHiScoreHelp":''    ***My Constants***    ErrorFactor(0)=1:ErrorFactor(1)=3:ErrorFactor(2)=7  '***Experiment with values'DIM MHndl&(7),SndHndl&(10):'                                        Handles for toolbox menus, Snds''             ------------'   FUNCTION: FN DiskSpace              - Copyright 1989 Staz & Ariel Publishing'             ------------''DESCRIPTION: This function will determine the amount of space available on the'             default volume.''  VARIABLES: Temp$                     - This is a simple string but is used'                                         by the function as an input/output'                                         parameter block.  In other words,'                                         information is placed in the memory'                                         occupied by the string and passed'                                         to the toolbox.  The toolbox changes'                                         some of the memory locations in the'                                         same string and returns it to us.'             ParamBlk&                 - Handle to beginning of Temp$'             BlockSize&                - Number of bytes in a block'             FreeBlocks&               - Number of free blocks'''-------------------------------------------------------------------------------'Pi!=ATN(1)<<2                          :'Pi!= arctangent of 1 shifted left twice'-------------------------------------------------------------------------------''==============================================================================='GOTO"Queue"''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Functions'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥''                                                   1/0 - Is the shift key down?'LONG FN ShiftDown  CALL GETKEYS(KeyRecord(0))END FN = FN BITTST(VARPTR(KeyRecord(3)),15)''                                               Set the font and calc its height'LONG FN GetFht(GFFont,GFSize,GFFace,GFMode)  TEXT GFFont,GFSize,GFFace,GFMode  CALL GETFONTINFO(FAsc)END FN = FAsc+FDes+FLead''                                             Capture offset values from handles'DEF FN  GetWord(GWHndl&,GWOffSet)=PEEK WORD(PEEK LONG(GWHndl&)+GWOffSet)DEF FN GetLong&(GLHndl&,GLOffSet)=PEEK LONG(PEEK LONG(GLHndl&)+GLOffSet)''                                             Place an integer on my event stack'LONG FN Push(PushVal)  IF SP+1>StakHi THEN SP=StakHi-1  SP = SP + 1  Stak(SP) = PushValEND FN''                                                Remove an integer from my stack'LONG FN Pop  LONG IF SP    PopVal = Stak(SP)    SP = SP - 1  XELSE    PopVal = 0  END IFEND FN = PopVal''                                   Refresh a window without bringing it forward'LONG FN Format(Wnd2Format)  LONG IF Wnd2Format    OldOutPutWnd = WINDOW(1)    WINDOW OUTPUT Wnd2Format    GOSUB"Format Wnd"    IF OldOutPutWnd THEN WINDOW OUTPUT OldOutPutWnd  END IFEND FN''                                                        Locate a button by name'LONG FN FindBtn&(BtnName$)  FndBtnHndl&=PEEK LONG(WINDOW(14)+140)  DO    CALL GETCTITLE(FndBtnHndl&,CtrlTitle$)    LONG IF BtnName$<>CtrlTitle$      FndBtnHndl&=PEEK LONG(PEEK LONG(FndBtnHndl&))    END IF  UNTIL BtnName$=CtrlTitle$ OR FndBtnHndl&=0END FN = FndBtnHndl&''                                                   Draw a frame around a button'LONG FN FrameBtn(BtnName$)  FrBtnHndl&=FN FindBtn&(BtnName$)  LONG IF FrBtnHndl&    BLOCKMOVE PEEK LONG(FrBtnHndl&)+8,VARPTR(Ft),8    CALL INSETRECT(Ft,-4,-4)    PEN 3,3,1,8,0    CALL FRAMEROUNDRECT(Ft,16,16)    CALL PENNORMAL  END IFEND FN''                                 Handle event if it's an arrow in an edit field'LONG FN EditFldArrow(EFAAct)  GOSUB"TE Stats":SendKey = 0  SELECT EFAAct    CASE LeftAct,UpAct      IF SelStart THEN SendKey = EFAAct+16    CASE RightAct,DownAct      IF SelEnd<TELen THEN SendKey = EFAAct+16  END SELECT  LONG IF SendKey    CALL TEKEY(SendKey,TEHANDLE(WINDOW(0)))    EFAAct = 0  END IFEND FN = EFAAct''                                      Change cursor according to mouse position'LONG FN AutoCursor(Fy,Fx)  ACResult = Arrow  LONG IF WINDOW(0)    ACHndl& = TEHANDLE(WINDOW(0))    LONG IF ACHndl&      BLOCKMOVE PEEK LONG(ACHndl&),VARPTR(Ft),8      IF FN PTINRECT(Fy,Ft) THEN ACResult = IBeam     END IF    ACPort& = WINDOW(14)    LONG IF ACPort&      LONG IF FN FINDCONTROL(Fy,ACPort&,ACHndl&)        ACResult = Hand      END IF    END IF  END IFEND FN = ACResult''                                            Check 1 menu item & return its name'LONG FN Chk1Item$(MHndl&,ChkItem)  FOR F=1 TO FN COUNTMITEMS(MHndl&)    CALL CHECKITEM(MHndl&,F,(F=ChkItem))  NEXT  CALL GETITEM(MHndl&,ChkItem,ItemName$)END FN=ItemName$''                                                      Check a menu item by name'LONG FN Chk1Name(MHndl&,ItemName$)  FOR F=1 TO FN COUNTMITEMS(MHndl&)    CALL GETITEM(MHndl&,F,FTemp$)    CALL CHECKITEM(MHndl&,F,(FTemp$=ItemName$))  NEXTEND FN''LONG FN DiskSpace&  ParamBlk&=VARPTR(Temp$)              :'Use the string Temp$ as a parameter                                       :'block and make a note of the handle  POKE LONG ParamBlk&+12,0             :'A zero in this memory location tells                                       :'the tool box that there is no input/                                       :'output completion routine  POKE LONG ParamBlk&+18,0             :'Null hndl-don't need title$  POKE WORD ParamBlk&+22,0             :'Use current drive  POKE WORD ParamBlk&+28,0             :'Use current volume  GET VOLUME INFO Temp$                :'Have ZBasic get the info  BlockSize&=PEEK LONG(ParamBlk&+48)   :'# of bytes in a block  FreeBlocks&=PEEK WORD(ParamBlk&+62)  :'# of free blocksEND FN=BlockSize&*FreeBlocks&'DEF FN DegreeSIN!(Angle!)=SIN(     Angle! /360*2*Pi!)'LONG FN SetBtn(SBNum,SBState)''This function checks button number "SBNum"'before resetting it to SBState.  This'speeds up operations and prevents flicker.'  LONG IF BUTTON(SBNum)<>SBState    BUTTON SBNum,SBState  END IF END FN'LONG FN Group(GTop$,GBot$,GTitle$)''This FN will draw a frame around a group'of buttons between and including the'button named GTop$ and GBot$.  A title'passed as GTitle$ is placed at the top'of the frame.'  GTHndl&=FN FindBtn&(GTop$)  GBHndl&=FN FindBtn&(GBot$)  LONG IF GBHndl& AND GTHndl&    BLOCKMOVE PEEK LONG(GTHndl&)+ 8,VARPTR(Ft),4    BLOCKMOVE PEEK LONG(GBHndl&)+12,VARPTR(Fb),4    CALL INSETRECT(Ft,-8,-8)    CALL FRAMERECT(Ft):TEXT 0,12,0,0    GTitle$=" "+GTitle$+" "    CALL MOVETO((Fr-Fl)/2-FN STRINGWIDTH(GTitle$)/2+Fl,Ft+FAsc/2-1)    CALL DRAWSTRING(GTitle$)  END IFEND FN'LONG FN SetGroup(SGFirst,SGLast,SGSet)''This function will check all radio'buttons in a group from SGFirst to SGLast.'In the end, only button number "SGSet"'will be selected.  All others will be'deselected or left alone if dimmed.'  FOR F=SGFirst TO SGLast    LONG IF F=SGSet      IF BUTTON(F)<>2 THEN BUTTON F,2    XELSE      IF BUTTON(F)= 2 THEN BUTTON F,1    END IF  NEXTEND FN'LONG FN ToggleBtn(TBNum)''This function will "Toggle" a button'Selected buttons will be deselected'Deselected buttons will be selected'  LONG IF BUTTON(TBNum)=2    BUTTON TBNum,1  XELSE    BUTTON TBNum,2  END IFEND FN''LONG FN ResStr$(ResID,F)''This function retrieves a string'from a STR# resource with an ID'of "ResID".  Since many strings'may be stored in such a resource,'pass the number of the string to'extract in the "F" parameter'  FHndl&=FN GETNAMEDRESOURCE(CVI("STR#"),"HiScores")  'ResName$)'IF FHndl& THEN BEEP ELSE END  OSErr=FN HLOCK(FHndl&)  FPtr&=PEEK LONG(FHndl&)  FTemp$="":F=F-1  LONG IF F<PEEK WORD(FPtr&)    FPtr&=FPtr&+2:Counter=0    WHILE Counter<F      FPtr&=FPtr&+PEEK(FPtr&)+1      Counter=Counter+1    WEND    BLOCKMOVE FPtr&,VARPTR(FTemp$),PEEK(FPtr&)+1  END IF  OSErr=FN HUNLOCK(FHndl&):CALL RELEASERESOURCE(FHndl&)END FN=FTemp$''***This version uses named Text resources***LONG FN ScrollingHelp(RectPtr&,RName$,HelpBtn)                                       :'Load the help text resource                                       :'  ResHndl&=FN GETNAMEDRESOURCE(CVI("TEXT"),RName$)  ResPtr&=USR 3(ResHndl&)              :'Lock it & return the pointer  BLOCKMOVE RectPtr&,VARPTR(HelpT),8   :'Copy the rect rec'd as 1st argument  HelpR=HelpR-15                       :'Make room for scroll bar  CALL INSETRECT(HelpT,1,1)            :'Shrink it to allow for frame  HelpHndl&=FN TENEW(HelpT,HelpT)      :'Build a new TE field  HelpLen=FN SIZERESOURCE(ResHndl&)    :'Get the length of the help text  CALL TEAUTOVIEW(True,HelpHndl&)      :'Enable scrolling                                       :'Copy the text into the edit field  CALL TESETTEXT(ResPtr&,HelpLen,HelpHndl&)  CALL TECALTEXT(HelpHndl&)            :'Let the toolbox calculate line starts  CALL TEUPDATE (HelpT,HelpHndl&)      :'Show it                                       :'The number of lines in the field is                                       :'stored in the 94th position from the                                       :'start of the TE record  NumLines=PEEK WORD(PEEK LONG(HelpHndl&)+94)  CALL INSETRECT(HelpT,-1,-1)          :'Enlarge the rect ' CALL PENNORMAL:CALL FRAMERECT(HelpT) :'Frame it                                       :'Find out how tall the lines are  LineHt=PEEK WORD(PEEK LONG(HelpHndl&)+24)  VisLines=(HelpB-HelpT)/LineHt        :'Set scroll bar to 1st line beyond                                       :'visible area  SCROLL BUTTON HelpBtn,0,0,NumLines+1,VisLines-1,(HelpR,HelpT)-(HelpR+16,HelpB),1  ResPtr&=USR 7(ResHndl&)              :'Unlock the resourceEND FN''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Queue"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ GOSUB"Initialize":'                                     Execute set-up routines Count%=1:PrintFlag=FINDERINFO(Count%,FileName$,FileType&,FVolume%) FLUSHEVENTS:'                                   Remove any events since startup IF FileName$<>"" AND PrintFlag=0 THEN GOSUB "Open2":FN Push(1):FN Push(OpenEvent)  ON BREAK  GOSUB"Break":'                                        Set up handlers ON DIALOG GOSUB"Dialog" ON MOUSE  GOSUB"Mouse" ON MENU   GOSUB"Menu" CURSOR Arrow:'                                             Restore arrow cursor'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Loop"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥' DIALOG ON :MOUSE ON :BREAK ON :MENU ON DIALOG OFF:MOUSE OFF:BREAK OFF:MENU OFF:'     The only place events are trapped''                                                      Handle events on my stack'WHILE SP:'                                      Is the stack pointer above zero?  MyEvent=FN Pop:'                                  Pop the event from the stack  SELECT MyEvent:'                                            React to the event    CASE OpenEvent:'                                   Request to build a window      GOSUB"Build"    CASE CloseEvent:'                                  Request to close a window      Wnd2Close = FN Pop:'                   Pop # of window to close from stack'                                 Bring it to the front for the capture routines      IF WINDOW(0)<>Wnd2Close THEN WINDOW Wnd2Close      GOSUB"Capture":'                               Capture data before closing      WINDOW CLOSE Wnd2Close:'                                          Close it      IF Wnd2Close=WndHelp THEN CALL CHECKITEM(MHndl&(HelpMenu),HelpCheck,False)    CASE MenuEvent:'                                 Request to de-hilite a menu      MENU    CASE ButtonEvent       LONG IF WINDOW(0)=WndHelp         BtnPos=BUTTON(HelpBtn)-1               :'Get the button position and reset the                                       :'TE selection to that line         SelPos=PEEK WORD(PEEK LONG(HelpHndl&)+94+BtnPos*2)         CALL TESETSELECT(SelPos,SelPos,HelpHndl&)         CALL TESELVIEW(HelpHndl&)          :'Scroll it into view       END IF    CASE BreakEvent:'                                       Request to terminate      LONG IF WINDOW(0)'                          Close open windows 1st to handle list/region disposal        FN Push(BreakEvent)        FN Push(WINDOW(0))        FN Push(CloseEvent)      XELSE        PleaseTerminate=True      END IF  END SELECT:'                                             End of event handlers  IF PleaseTerminate=True THEN "Break":'    Cont while events remain on my stackWEND''LONG IF WINDOW(0)=WndMainIF(X>=Xmax) AND GoFlag THEN GoFlag=False:BUTTON 1, 1,"Go" '***Stop it when you run out***IF AnswerFlag AND GoFlag THEN GoFlag=False:BUTTON 1, 1,"Go" '***of space or get an answer***''***Main code--draws curves***'LONG IF GoFlag AND FN TICKCOUNT>TTime&+TimeDelay  TTime&=FN TICKCOUNT   '***Reset timer to get constant speed***  BoxType=TopBox   GOSUB "NextPoint"  LONG IF BiCycle    BoxType=BottomBox:     GOSUB "NextPoint"  END IF  X=X+DeltaX  PointsLeft=PointsLeft-LevelPts:GOSUB "Print Points Remaining"END IF END IF'                                                   Set cursor by mouse position' OldCsr=NewCsr:'                                             Save the old cursor NewCsr=Arrow:'                                        Reset new cursor to arrow CALL GETMOUSE(My):'                                         Where is the mouse? NewCsr=FN AutoCursor(My,Mx):'                                Let the FN tell us IF NewCsr<>OldCsr THEN CURSOR NewCsr:'               If the cursor has changedи'GOTO"Loop" '"NextPoint"  ON (CycleType+BoxType) GOSUB "Cycle","PseudoCycle","Cycle"  '***reverses for Box=1  LONG IF (Y>(Ymax(BoxType)+5)) OR (Y>BoxHeight-3)     Ymax(BoxType)=Y    GOSUB "Shift the Curve"   XELSE    IF Y<Ymin(BoxType)-5 OR Y<3 THEN Ymin(BoxType)=Y:GOSUB "Shift the Curve":  END IF  Y(BoxType,X)=Y+Ytop(BoxType)   '***Draw next point  CALL MOVETO(X-DeltaX,Y(BoxType,X-DeltaX)):CALL LINETO(X,Y(BoxType,X))RETURN'"Cycle"  CycleCenter!=CycleCenter!+DelCycleCenter!  SinAgmt=SinAgmt+DelSinAgmt  CycleError= CErrorFactor!*Normal(RND(99))    Y(2,X)=CycleCenter!+(USR 8(SinAgmt)/16)  Y=Y(2,X)+CycleError  'LONG IF Level>6   ' IF RND(30)=30 THEN DelCycleCenter!=(DeltaX*(RND(5)-3))*.04      ' IF Level>7 THEN IF RND(25)=25 THEN DelSinAgmt=DeltaX*(1+RND(4))  ' END IFRETURN'"PseudoCycle"  '***Calculate next point if PseudoCycle  PCycleCenter!=PCycleCenter!+DelPCycleCenter!  PCycleError= (PCycleError+PErrorFactor!*Normal(RND(99)))*RegressRate!  Y=PCycleCenter!+PCycleError  LONG IF Level>6    IF RND(30)=30 THEN DelPCycleCenter!=DeltaX*(RND(5)-3)*.02:       IF Level>7 THEN IF RND(25)=25 THEN RegressRate!=.89+RND(8)*.01  END IFRETURN'"Shift the Curve"  IF (Ymax(BoxType)-Ymin(BoxType))>=BoxHeight THEN GOSUB "Shrink it"  YShift=(BoxHeight-(Ymax(BoxType)+Ymin(BoxType)))>>1  PEN,,,12 :BOX FILL Xmin,Ytop(BoxType) TO X,Ybottom(BoxType)-2:PEN ,,,8  CALL MOVETO (Xmin,Y(BoxType,Xmin)+YShift)  FOR Xtmp=Xmin TO X-DeltaX STEP DeltaX    Y(BoxType,Xtmp)=Y(BoxType,Xtmp)+YShift    CALL LINETO (Xtmp,Y(BoxType,Xtmp))  NEXT Xtmp  Ymax(BoxType)=Ymax(BoxType)+YShift:Ymin(BoxType)=Ymin(BoxType)+YShift  Y=Y+YShift  LONG IF (CycleType=1 AND BoxType=0) OR (CycleType=2 AND BoxType=1)      CycleCenter!=CycleCenter!+YShift    '***Cycle is being shifted***  XELSE                                 '***PseudoCycle is being shifted***    PCycleCenter!=PCycleCenter!+YShift  END IFRETURN'"Shrink it"  MidPoint=Ytop(BoxType)+BoxHeight/2:MidPointTerm=MidPoint/2  FOR Xtmp=Xmin TO X-DeltaX STEP DeltaX:    Y(BoxType,Xtmp)=MidPointTerm+(Y(BoxType,Xtmp)/2)  NEXT Xtmp  Ymax(BoxType)=BoxHeight/4+(Ymax(BoxType)/2)  Ymin(BoxType)=BoxHeight/4+(Ymin(BoxType)/2)  Y=BoxHeight/4+Y/2  LONG IF (CycleType=1 AND BoxType=0) OR (CycleType=2 AND BoxType=1)      CycleCenter!=BoxHeight/4+CycleCenter!/2    '***Cycle is being shrunk***    DelCycleCenter!=DelCycleCenter!/2    CErrorFactor!=CErrorFactor!/2    CShrinkFactor=CShrinkFactor/2  XELSE                                 '***PseudoCycle is being shrunk***    PCycleCenter!=BoxHeight/4+PCycleCenter!/2    DelPCycleCenter!=DelPCycleCenter!/2    PCycleError=PCycleError/2    PErrorFactor!=PErrorFactor!/2  END IFRETURN'"Print Points Remaining"   TEXT 3,9,0,0   T = 118:L = 350:B = 130:R = 400   Temp$ = STR$(PointsLeft)   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, -1)RETURN"New Parameters"  CycleType=RND(2)  DeltaX=1+RND(5):  FOR BoxType=0 TO 1    Y(BoxType,Xmin)=Ytop(BoxType)+BoxHeight/2   '***Both start in center of box***    Ymax(BoxType)=BoxHeight/2:Ymin(BoxType)=BoxHeight/2   '***max=min=first point***  NEXT BoxType  CShrinkFactor=1024  SELECT Level    CASE 1      CErrorFactor!=1      DelSinAgmt=DeltaX*(3+RND(3)):DelCycleCenter!=0      PErrorFactor!=2:DelPCycleCenter!=0:RegressRate!=.98    CASE 2      CErrorFactor!=2      DelSinAgmt=DeltaX*(2+RND(3)):DelCycleCenter!=0      PErrorFactor!=3:DelPCycleCenter!=0:RegressRate!=.96    CASE 3      CErrorFactor!=2      DelSinAgmt=DeltaX*(2+RND(2)):DelCycleCenter!=(DeltaX*(RND(5)-3))*.03      PErrorFactor!=4:DelPCycleCenter!=DeltaX*(RND(5)-3)*.03:RegressRate!=.95    CASE 4      CErrorFactor!=2      DelSinAgmt=DeltaX*(1+RND(2)):DelCycleCenter!=(DeltaX*(RND(5)-3))*.03      PErrorFactor!=4:DelPCycleCenter!=DeltaX*(RND(5)-3)*.03:RegressRate!=.95    CASE 5      CErrorFactor!=3      DelSinAgmt=(DeltaX*(2+RND(3)))/2:DelCycleCenter!=(DeltaX*(RND(5)-3))*.04      PErrorFactor!=6:DelPCycleCenter!=DeltaX*(RND(5)-3)*.04:RegressRate!=.94    CASE >5      CErrorFactor!=3      DelSinAgmt=(DeltaX*(3+RND(5)))/5:DelCycleCenter!=(DeltaX*(RND(5)-3))*.05      PErrorFactor!=6:DelPCycleCenter!=DeltaX*(RND(5)-3)*.04:RegressRate!=.94    'CASE 7    'CASE 8    CASE ELSE  END SELECT  LevelPts=Level:PointsLeft=LevelPts*(1+(Xmax-Xmin))/DeltaX  '***Fix LevelPts for Level 0 later***'***Cycle Parameters***  CycleError= CErrorFactor!*Normal(RND(99))   '*ErrorFactor  SinAgmt=RND(255):   '  DelSinAgmt=DeltaX*(1+RND(4))  CycleCenter!= (BoxHeight/2)-((USR 8(SinAgmt)/16)+CycleError)  'DelCycleCenter!=(DeltaX*(RND(5)-3))*.05'***PCycle Parameters***  PCycleError=PErrorFactor!*Normal(RND(99))  PCycleCenter!= BoxHeight/2-PCycleError  'DelPCycleCenter!=DeltaX*(RND(5)-3)*.05RETURN'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Dialog"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ Act=DIALOG(0):Ref=DIALOG(Act)' LONG IF Act=CloseAct   FN Push(Ref):FN Push(CloseEvent)   RETURN END IF' IF Act=RefreshAct THEN FN Format(Ref):RETURN' IF Act=ClearAct THEN EDIT FIELD Ref,"":RETURN' IF FN EditFldArrow(Act)=0 THEN RETURN' LONG IF Act=WindowAct    GOSUB"Capture"    WINDOW Ref   LONG IF Ref=WndHelp      CALL ENABLEITEM(MHndl&(FontMenu),0)      CALL ENABLEITEM(MHndl&(SizeMenu),0)      CALL DISABLEITEM(MHndl&(EditMenu),0):CALL DISABLEITEM(MHndl&(ShowMenu),0)      IF WINDOW(0)<>WndHelp THEN HelpText$=HelpText$(WINDOW(0))      FN Push(MenuEvent)   END IF   RETURN END IF'' LONG IF WINDOW(0) = WndMain   LONG IF Act=ButtonAct     SELECT Ref       CASE 1           GoFlag=NOT GoFlag:           IF GoFlag THEN StopGo$="Stop" ELSE StopGo$="Go"           BUTTON 1, 1,StopGo$,( 56, 126)-( 104, 146),1           LONG IF AnswerFlag             GOSUB "New Parameters"             X=Xmin+DeltaX:AnswerFlag=False '!!!Temporary           END IF       CASE 2           IF CycleType=Cycle THEN GOSUB "Right Answer" ELSE GOSUB "Wrong Answer"       CASE 3           IF CycleType=Cycle THEN GOSUB "Wrong Answer" ELSE GOSUB "Right Answer"       CASE 4           IF CycleType=Cycle THEN GOSUB "Wrong Answer" ELSE GOSUB "Right Answer"       CASE 5           IF CycleType=Cycle THEN GOSUB "Right Answer" ELSE GOSUB "Wrong Answer"       CASE ELSE          BEEP     END SELECT   END IF   RETURN END IF' LONG IF WINDOW(0) = WndHelp   LONG IF Act=ButtonAct     LONG IF Ref=HelpBtn                        :'Scroll button from intro       FN Push (ButtonEvent)     END IF  END IF  RETURN END IF' LONG IF WINDOW(0) = WndSetup OR WINDOW(0)=WndSetup2   LONG IF Act=ButtonAct     SELECT Ref       CASE 1 '***Practice          Practice=True:BUTTON 1,2:BUTTON 2,1       CASE 2 '***Game          Practice=False:BUTTON 1,1:BUTTON 2,2       CASE 3,4,5,6,7          FN SetGroup(3,7,Ref)          IF WINDOW(0)=WndSetup AND Level=0 THEN BUTTON 8,1:'***Add Code to disable custom buttons          Level =Ref-2:StartLevel=Level       CASE 8          IF Level>0 THEN BUTTON Level+2,1:BUTTON 8,2:Level=0          '***add code to enable all the custom buttons***       CASE 9,10,11   '***size of error          FN SetGroup(9,11,Ref):ErrorLevel=Ref-9:ErrorFactor=ErrorFactor(ErrorLevel)       CASE 12     '***period constant          PeriodVariable=False:BUTTON 12,2:BUTTON 13,1       CASE 13     '*** or variable          PeriodVariable=True:BUTTON 12,1:BUTTON 13,2       CASE 14,15,16   '***Trend--none,constant,variable          FN SetGroup(14,16,Ref):TrendType=Ref-14       CASE 17   '*** Persistant          FN ToggleBtn(17)          PersistantFlag=NOT PersistantFlag       CASE 18   '***Regressive          FN ToggleBtn(18)          RegressiveFlag=NOT RegressiveFlag       CASE 19   '***Trendy          FN ToggleBtn(19)          TrendyFlag=NOT TrendyFlag       CASE 20   '***Chameleon          FN ToggleBtn(20)          ChameleonFlag=NOT ChameleonFlag          '***Add code to disable all other custom choices       CASE 21  '***UniCycle          BiCycle=False:BUTTON 21,2:BUTTON 22,1       CASE 22      '***or BiCycle          BiCycle=True:BUTTON 21,1:BUTTON 22,2       CASE 23     '***Done          LONG IF BiCycle<>OldBiCycle            FN Push(WndMain):FN Push(OpenEvent):            FN Push(WndMain):FN Push(CloseEvent)          XELSE            FN Format(WndMain)          END IF          FN Push(WINDOW(0)):FN Push(CloseEvent)          GOSUB "New Parameters":X=Xmin+DeltaX          GoFlag=False:StopGo$="Go"       CASE ELSE           BEEP     END SELECT   END IF'   <-- Insert WINDOW 3  DIALOG routines here   RETURN END IF'' LONG IF WINDOW(0) = WndNewHiScore   LONG IF Act=ReturnAct     GOSUB "Add New High Score":NewHiScoreFlag=True     GOSUB "Format Wnd":DELAY 3000     FN Push(WndNewHiScore):FN Push(CloseEvent)   END IF'   <-- Insert WINDOW 5  DIALOG routines here   RETURN END IF' LONG IF WINDOW(0) = WndShowHiScore'   <-- Insert WINDOW 6  DIALOG routines here   RETURN END IF' LONG IF WINDOW(0) = WndAbout'   <-- Insert WINDOW 7  DIALOG routines here   RETURN END IFRETURN'"Right Answer"  LONG IF  SndCapable    X&=FN SNDPLAY(0,SndHndl&(0),-1)  '***Version if Snds are pre-loaded   ' Snd$="Correct":gosub "Play Snd" '***Version if we load Snds as we need them***   '***Release the resource, Handle here!***  XELSE    OPEN TALK,-1,"",512  '***go back to this if wrong system software***    TALK#-1,250,150,0    PRINT#-1,"Correct"    CLOSE#-1  END IF  AnswerFlag=True   '!!!Temporary  IF NOT Practice THEN CurrentScore=CurrentScore+PointsLeft:GOSUB "Print Current Score"  IF (Level<HighestLevel) AND NOT Practice THEN Level=Level+1  IF ShowCycle THEN GOSUB "Draw Cycle"  GOSUB "New Parameters":X=Xmin+DeltaXRETURN"Wrong Answer"  LONG IF  SndCapable    X&=FN SNDPLAY(0,SndHndl&(1),-1)  '***Version if Snds are pre-loaded   ' Snd$="Wrong":gosub "Play Snd" '***Version if we load Snds as we need them***   '***Release the resource, Handle here!***  XELSE    OPEN TALK,-1,"",512  '***go back to this if wrong system software***    TALK#-1,250,110,0    PRINT#-1,"Wrong"    CLOSE#-1  END IF  AnswerFlag=True   '!!!  IF BiCycle THEN ScoreType=1 ELSE ScoreType=0  LONG IF (CurrentScore>HiScore(ScoreType,9)) AND NOT Practice    FN Push(WndNewHiScore):FN Push(OpenEvent)' Push setup window on to stack, open it.    NewHiScore=CurrentScore   XELSE    FN Push(WndSetup2):FN Push(OpenEvent)' Push setup window on to stack, open it.  END IF  CurrentScore=0:GOSUB "Print Current Score"  IF ShowCycle THEN GOSUB "Draw Cycle"           GoFlag=False:StopGo$="Go"   '!!!???           BUTTON 1, 1,StopGo$        '!!!???RETURN'"Play Snd"  '***Version if Sounds are loaded as used***    H&=FN GETNAMEDRESOURCE(CVI("snd "),Snd$)    IF H&=0 THEN STOP    X&=FN SNDPLAY(0,H&,-1)RETURN"Print Current Score"   TEXT 3,9,0,0   T = 136:L = 350:B = 148:R = 400   Temp$ = STR$(CurrentScore)   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, -1)RETURN'"Draw Cycle"  LONG IF (NOT BiCycle) AND (CycleType=2)    RETURN  XELSE    BoxType=CycleType-1    IF BoxType=TopBox THEN CALL CLIPRECT(TopRect(0)) ELSE CALL CLIPRECT(BottomRect(0))    MidPtTerm=(BoxHeight*(1024-CShrinkFactor))>>11    FOR Xtmp=Xmin TO X STEP DeltaX      Y(2,Xtmp)=MidPtTerm+(CShrinkFactor*Y(2,Xtmp))>>10     NEXT Xtmp    CALL MOVETO (Xmin,Ytop(BoxType)+BoxHeight/2)    PEN 2,2    FOR Xtmp=Xmin+DeltaX TO X-DeltaX STEP DeltaX      CALL LINETO (Xtmp,Y(2,Xtmp)+Ytop(BoxType))    NEXT Xtmp    PEN 1,1CALL CLIPRECT(ScrnT)    DELAY 2000  END IFRETURN'"Add New High Score"     ScoreNbr=8:IF BiCycle THEN ScoreType=1 ELSE ScoreType=0     WHILE (NewHiScore>HiScore(ScoreType,ScoreNbr)) AND ScoreNbr>=0       HiScore(ScoreType,ScoreNbr+1)=HiScore(ScoreType,ScoreNbr)       HiName$(ScoreType,ScoreNbr+1)=HiName$(ScoreType,ScoreNbr)       HiStartLevel(ScoreType,ScoreNbr+1)=HiStartLevel(ScoreType,ScoreNbr)       HiEndLevel(ScoreType,ScoreNbr+1)=HiEndLevel(ScoreType,ScoreNbr)       ScoreNbr=ScoreNbr-1     WEND     HiScore(ScoreType,ScoreNbr+1)=NewHiScore     HiName$(ScoreType,ScoreNbr+1)=EDIT$(1)     HiStartLevel(ScoreType,ScoreNbr+1)=StartLevel     HiEndLevel(ScoreType,ScoreNbr+1)=LevelRETURN''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Mouse"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥   Mact=MOUSE(0):Mx=MOUSE(1):My=MOUSE(2)   LONG IF WINDOW(0)=WndAbout     FN Push(WndAbout):FN Push(CloseEvent)   END IF     '   DO:UNTIL MOUSE(0)=0RETURN''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Menu"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥ MenuID=MENU(0):ItemID=MENU(1) FN Push(MenuEvent) LONG IF MenuID = 255:'                                       Apple menu    FN Push(WndAbout):FN Push(OpenEvent)      RETURN END IF ON MenuID GOTO "File","Edit","Font","Size","Show","Help""File" ON ItemID GOTO "New","Open","X","Save","Save Asи","X","PageSetupи","Print","X","Quit" '  "Close","Quit"'"New"                      IF FN ShiftDown THEN FN Push(WndSetup) ELSE FN Push(WndSetup2):  FN Push(OpenEvent)RETURN'"Open"   FileName$=FILES$(1,"lFlx",,FVolume%) "Open2"   SELECT FileName$      CASE ""         BEEP      CASE ELSE   ON ERROR GOSUB 65535'              This won't work on the first run   OPEN"I",#1,FileName$,,FVolume%'             Open the file (if it exists)   TheErr = ERROR'                            ERROR? Couldn't find it?   ON ERROR RETURN'                               reset error handling   LONG IF TheErr'                         If error exists, show alert      CALL PARAMTEXT("Couldn't locate variable file","","","")      X = FN NOTEALERT(1,0)      ERROR = 0   XELSE      INPUT#1,VarLgth&'                   No Error? Get simple var lgth      READ FILE#1,VARPTR(FirstVar),VarLgth&'                   and load      INPUT#1,VarLgth&'                                  Get array lgth      READ FILE#1,VARPTR(FirstArray(0)),VarLgth&'              and load      CLOSE #1'                                          That's a wrap!   END IF   END SELECT   FN Push(WndMain):FN Push (OpenEvent)    FN Push(WndMain):FN Push (CloseEvent) RETURN'"Save"   IF FileName$="" THEN FileName$=FILES$(0,"Save curves as what?","Curves",FVolume%)   'FileNameFlag=True                     OPEN"R",#1,FileName$   GOSUB "Get Simple Lgth"'                  Calc length of simple vars   PRINT #1,VarLgth&'                        Write lgth & data to file   WRITE FILE#1,VARPTR(FirstVar),VarLgth&   GOSUB "Get Array Lgth"'                    Repeat process for arrays   PRINT #1,VarLgth&   WRITE FILE#1,VARPTR(FirstArray(0)),VarLgth&   CLOSE #1RETURN'"Save Asи"    FileName$=FILES$(0,"Save Cycle/PseudoCycle as what?","Series",FVolume%)   GOSUB "Save"             RETURN'"PageSetupи"DEF PAGE:IF NOT PRCANCEL THEN SetupFlag=True ELSE BEEPRETURN"Print"IF NOT SetupFlag THEN GOSUB "PageSetupи":IF PRCANCEL THEN RETURN                DEF LPRINT : IF PRCANCEL THEN RETURNROUTE 128 : COORDINATE WINDOW:CLSCopyFlag=True:GOSUB  "Format Wnd":CopyFlag=FalseCLEAR LPRINT:CLOSE LPRINTROUTE 0RETURN'"Close"                  RETURN  '***Should probably remove this'"Quit" GOTO "Break"'"Edit" ON ItemID GOTO "Copy Picture","Copy Series","Clear"  '***Clear shd probably be cut out***'"Copy Picture"    CopyFlag=True   PICTURE ON (X0,Ymax)-(XendG,Ymin)      GOSUB "Format Wnd" PICTURE OFF,CPicture&   CopyFlag=False   L&=FN GETHANDLESIZE(CPicture&)   Scrap&=FN ZEROSCRAP   Scrap&=FN PUTSCRAP(L&,CVI("PICT"),PEEK LONG (CPicture&))   KILL PICTURE CPicture&RETURN'"Copy Series"'***copies Y(0 and 1,Xmin to X step DeltaX) to clipboard  CLEAR 5000 : ' Make room in index$ for strings' Routine to Fill INDEX$ With strings representing Y  NPts=((X-Xmin)/DeltaX)-1  FOR I=0 TO NPts    INDEX$(I)=STR$(Y(0,Xmin+I*DeltaX))'+","  NEXT I  LONG IF BiCycle    INDEX$(NPts+1)=Cr$    FOR I=0 TO NPts      INDEX$(I+NPts+2)=STR$(Y(1,Xmin+I*DeltaX))'+","    NEXT I    N=2*NPts+2  XELSE    N=NPts  END IF  GOSUB "INDEX$ to Scrap" : ' Move INDEX$ to ClipboardRETURN'"INDEX$ to Scrap"  Xsc=FN ZEROSCRAP                      : ' Zero Scrap first  L&=MEM(20)                          : ' find out how many bytes needed  A&=USR 0(L&)                         : ' Create Memory block to use  IF A&=0 THEN BEEP : RETURN          : ' Can't get the memory  T&=A&                               : ' T& => Next string byte to add  I&=MEM(40)                          : ' T& is temp Ptr,I& points to INDEX$  FOR I=0 TO N     Sl%=PEEK(I&)    I&=I&+1                           : ' get & Skip Length byte    IF (T&-A&)+Sl%+1 > L& THEN PRINT"Program Error...."     : STOP    BLOCKMOVE I&,T&,Sl%                  : ' Move our string to Memory Block    I&=I&+Sl%     T&=T&+Sl%     POKE T&,44' 13                           : ' Tack on a comma  'Carriage return    T&=T&+1  NEXT I  IF FN PUTSCRAP(T&-A&,CVI("TEXT"),A&) THEN BEEP : BEEP  Xsc=USR 1(A&)                             : ' Dispose of Memory BlockRETURN   "Clear"  X=0:GOSUB "Format Wnd"   '***May not be adequate***RETURN"Window"   '***Currently fossil code from here to end of "Setup Window" Sub ON ItemID GOTO "Main Window","Setup Window","High Scores""Main Window"   FN Push(WndMain):FN Push(OpenEvent)             RETURN"Setup Window"   FN Push(WndSetup):FN Push(OpenEvent)  '***This assumes advanced setup window***         RETURN"High Scores"               FN Push(WndShowHiScore):FN Push(OpenEvent)            RETURN"Show" ON ItemID GOTO "Show Cycle","High Scores"   '"Show Mean","Show Trend""Show Cycle"                ShowCycle=NOT ShowCycle   CALL CHECKITEM(MHndl&(ShowMenu),CycleItem,ShowCycle)  '***??Problem with ShowMean not Byte?            RETURN'"Show Mean":   '***Currently fossil code***   ShowMean=NOT ShowMean   CALL CHECKITEM(MHndl&(ShowMenu),MeanItem,ShowMean)  '***??Problem with ShowMean not Byte?            RETURN'"Show Trend"      '***Currently fossil code***             ShowTrend=NOT ShowTrend   CALL CHECKITEM(MHndl&(ShowMenu),TrendItem,ShowTrend)  '***??Problem with ShowMean not Byte?            RETURN'"Help"   LONG IF ItemID=1       HelpText$="Instructions"    XELSE       IF WINDOW(0)<>WndHelp THEN HelpText$=HelpText$(WINDOW(0))      LONG IF WINDOW(0)=WndMain        IF BiCycle THEN HelpText$="B"+HelpText$ ELSE HelpText$="U"+HelpText$      END IF   END IF   CALL CHECKITEM(MHndl&(HelpMenu),HelpCheck,False) '***unchecks item   CALL CHECKITEM(MHndl&(HelpMenu),ItemID,True):HelpCheck=ItemID   FN Push(WndHelp):FN Push(OpenEvent)           "X"                      RETURN''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Font"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ FontName$ = FN Chk1Item$(FontMHndl&,Item	ID) CALL GETFNUM(FontName$,FontNum)''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Suggest Size"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ FOR SugSzLoop=1 TO FN COUNTMITEMS(SizeMHndl&)   CALL GETITEM(SizeMHndl&,SugSzLoop,Temp$)   Sz=VAL(Temp$)   LONG IF FN REALFONT(FontNum,Sz)     CALL SETITEMSTYLE(SizeMHndl&,SugSzLoop,8)   XELSE     CALL SETITEMSTYLE(SizeMHndl&,SugSzLoop,0)   END IF NEXT 'FN Push(WndHelp):FN Push(RefreshAct)  IF WINDOW(0)=WndHelp THEN GOSUB "Format Wnd" RETURN''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Size"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ Temp$ = FN Chk1Item$(SizeMHndl&,ItemID) FontSize=VAL(Temp$) 'FN Push(WndHelp):FN Push(RefreshAct)  IF WINDOW(0)=WndHelp THEN GOSUB "Format Wnd" RETURN'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥"Break"'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥' IF WINDOW(0) THEN FN Push(BreakEvent):RETURN'GOSUB "Save High Scores"' IF ResRef>0 THEN CALL CLOSERESFILE(ResRef)' FOR X = 1 TO 7:'                                               Dispose of menus   CALL DISPOSEMENU(MHndl&(X)) NEXT'END'''╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥'Window Routines'╥╥╥оооооооооооооооооооооооооооооооооооооооооооооооооооооооо╥╥╥''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Build"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ Wnd2Build = FN Pop:'                                    Pop window # from stack SELECT Wnd2Build   CASE WndMain     OldBiCycle=BiCycle '***Used with Setup to check whether this has changed.     T = 0:L = 0:R = 498:'                       Set TLBR to window size     IF BiCycle THEN B=270 ELSE B=160'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2,(ScrnB/2+8)-B/2)     WINDOW Wnd2Build,"grglflx",(L,T)-(R,B),261     StopGo$="Go"     BUTTON 1, 1,StopGo$,( 56, 126)-( 104, 146),1     BUTTON 2, 1,"Cycle",( 420, 19)-( 488, 39),1     BUTTON 3, 1,"Random",( 420, 60)-( 488, 80),1     LONG IF BiCycle        BUTTON 4, 1," Cycle ",( 420, 186)-( 488, 206),1        BUTTON 5, 1," Random ",( 420, 225)-( 488, 245),1     END IF   CASE WndHelp     WINDOW Wnd2Build,"Help",(LW2,TW2)-(RW2,BW2),1   '5	     FirstHelpFlag=False     'SCROLL BUTTON 1,1,1,100,10,,1     CALL ENABLEITEM(MHndl&(FontMenu),0):CALL ENABLEITEM(MHndl&(SizeMenu),0)     CALL DISABLEITEM(MHndl&(EditMenu),0):CALL DISABLEITEM(MHndl&(ShowMenu),0)     FN Push(MenuEvent)   CASE WndSetup     T = 0:L = 0:B = 212:R = 381:'                       Set TLBR to window size'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2,(ScrnB/2+8)-B/2)     WINDOW Wnd2Build,"Setup",(L,T)-(R,B),-261     BUTTON 1, 2,"Drill",( 4, 8)-( 77, 24),3     BUTTON 2, 1,"Game",( 4, 26)-( 69, 42),3'***Level Buttons     BUTTON 3, 1,"1",( 21, 70)-( 52, 86),3     BUTTON 4, 1,"2",( 21, 91)-( 57, 107),3     BUTTON 5, 1,"3",( 21, 112)-( 51, 128),3     BUTTON 6, 1,"4",( 21, 133)-( 53, 149),3     BUTTON 7, 1,"5",( 21, 154)-( 47, 170),3     BUTTON 8, 1,"",( 22, 177)-( 36, 193),3 '***Custom     IF Level=0 THEN BUTTON 8,2 ELSE BUTTON Level+2,2 '***Currently selected level     BUTTON 9, 1,,( 77, 59)-( 94, 75),3    '***Small Error     BUTTON 10, 1,,( 108, 59)-( 125, 75),3 '***Medium Error     BUTTON 11, 1,,( 136, 59)-( 153, 75),3 '***Large Error     BUTTON ErrorLevel+9,2   '***current ErrorLevel     BUTTON 12, 2,,( 74, 97)-( 91, 113),3  '***Fixed Period     BUTTON 13, 1,,( 74, 125)-( 91, 141),3  '***Changing Period     BUTTON 14, 2,,( 98, 194)-( 115, 210),3 '***No Trend     BUTTON 15, 1,,( 161, 194)-( 178, 210),3  '***Constant Trend     BUTTON 16, 1,,( 231, 194)-( 248, 210),3  '***Changing Trend     BUTTON 17, 1,,( 299, 50)-( 317, 66),2  '***Persistant     BUTTON 18, 1,,( 299, 83)-( 317, 99),2  '***Regressive     BUTTON 19, 1,,( 299, 116)-( 317, 132),2  '***Trendy     BUTTON 20, 1,,( 299, 149)-( 317, 165),2  '***Chameleon     BUTTON 21, 1,,( 169, 6)-( 186, 22),3  '***UniCycle     BUTTON 22, 1,,( 169, 24)-( 186, 40),3  '***BiCycle     IF BiCycle THEN BUTTON 22,2 ELSE BUTTON 21,2     BUTTON 23, 1,"Done",( 316, 184)-( 364, 204),1   CASE WndSetup2     T = 0:L = 0:B = 260:R = 84:'                        Set TLBR to window size'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2,(ScrnB/2+8)-B/2)     WINDOW Wnd2Build,"Setup 2",(L,T)-(R,B),261     BUTTON 1, 1,"Practice",( 4, 8)-( 77, 24),3     BUTTON 2, 1,"Game",( 4, 26)-( 69, 42),3     IF Practice THEN BUTTON 1,2 ELSE BUTTON 2,2  '***Shows Practice or game***     BUTTON 3, 1,"1",( 24, 68)-( 71, 84),3     BUTTON 4, 1,"2",( 24, 89)-( 60, 105),3     BUTTON 5, 1,"3",( 24, 110)-( 54, 126),3     BUTTON 6, 1,"4",( 24, 131)-( 56, 147),3     BUTTON 7, 1,"5",( 24, 152)-( 50, 168),3     BUTTON Level+2,2   '***shows currently selected level***     BUTTON 21, 1,,( 4, 178)-( 21, 194),3  '***UniCycle     BUTTON 22, 1,,( 4, 199)-( 21, 215),3  '***BiCycle     IF BiCycle THEN BUTTON 22,2 ELSE BUTTON 21,2     BUTTON 23, 1,"Done",( 20, 229)-( 62, 251),1   CASE WndNewHiScore     T = 0:L = 0:B = 267:R = 251:'                       Set TLBR to window size'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2-10,(ScrnB/2+8)-B/2-10)     IF BiCycle THEN WndTitle$="BiCycle High Scores" ELSE WndTitle$="UniCycle High Scores"     WINDOW Wnd2Build,WndTitle$,(L,T)-(R,B),5     TEXT 3,12,0,0     EDIT FIELD 1,"",( 28, 237)-( 214, 253),1,2     NewHiScoreFlag=False'***Next are the High Score Window***   CASE WndShowHiScore     T = 0:L = 0:B = 187:R = 251:'                       Set TLBR to window size'                                    Offset the rect to the center of the screen     CALL OFFSETRECT(T,ScrnR/2-R/2-10,(ScrnB/2+8)-B/2-10)     IF BiCycle THEN WndTitle$="BiCycle High Scores" ELSE WndTitle$="UniCycle High Scores"     WINDOW Wnd2Build,WndTitle$,(L,T)-(R,B),5   CASE WndAbout     WINDOW Wnd2Build,"About GrglFlx",( 30, 30)-( 243, 245),-4 END SELECTRETURN'"Setup Help Window"    T=0:L=3:B=WINDOW(3)-2:R=WINDOW(2)+14        :'Build a rectangle that will be cleared    CALL PENNORMAL                     :'for the help field.  '  CALL ERASERECT(T)    TEXT FontNum,FontSize,0,0                     :'Set to selected font, size.program font    FN ScrollingHelp(VARPTR(T),HelpText$,HelpBtn)  :'Have the function do the grunt workRETURN''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Format Wnd"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥' CALL GETPENSTATE(PenSpecs$):'                      Record the current pen state' TxFont=PEEK WORD(WINDOW(14)+68):'                 Record the current font specs TxFace=PEEK WORD(WINDOW(14)+70) TxMode=PEEK WORD(WINDOW(14)+72) TxSize=PEEK WORD(WINDOW(14)+74)'' LONG IF WINDOW(1) = WndMain   CALL PENNORMAL:'                          If you haven't installed the proper   DEF SHADOWBOX(TopRect(0)):'                             ZMover library-this won't work   BoxType=TopBox:GOSUB "DrawCycle"   TEXT 3,9,0,0   T = 118:L = 258:B = 130:R = 344   Temp$ = "Points Remaining:"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   GOSUB "Print Points Remaining":GOSUB "Print Current Score"   T = 136:L = 269:B = 148:R = 341   Temp$ = "Current Score:"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 115:L = 248:B = 154:R = 409   PEN 1,1,1,8,0   CALL FRAMEROUNDRECT(T, 16, 16)   LONG IF BiCycle      T = Ytop(1):L = Xmin:B = Ybottom(1):R = Xmax      CALL PENNORMAL:'                          If you haven't installed the proper      DEF SHADOWBOX(BottomRect(0)):'                             ZMover library-this won't work   BoxType=BottomBox:GOSUB "DrawCycle"   END IF END IF:'                                                  End of WndMain format'' LONG IF WINDOW(1) = WndHelp   IF NOT FirstHelpFlag THEN GOSUB "Cleanup Help Window"	   '  FirstHelpFlag=False   GOSUB "Setup Help Window"  END IF:'                                                  End of WndHelp format'' LONG IF WINDOW(1) = WndSetup   T = 49:L =-1:B = 215:R = 72   PEN ,1,1,8,0   CALL FRAMERECT(T)   T = 94:L = 224:B = 106:R = 243   TEXT 3,9,0,1   Temp$ = "i+1"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 52:L = 235:B = 65:R = 280   TEXT ,10,,1   Temp$ = "=      +"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T =-1:L =-1:B = 49:R = 72   CALL FRAMERECT(T)   T = 51:L = 12:B = 67:R = 62   TEXT 0,12,,1   Temp$ = "Level"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 2:L = 100:B = 18:R = 143   Temp$ = "Cycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 23:L = 102:B = 36:R = 141   TEXT 3,10,,1   Temp$ = "Error"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 149:L = 161:B = 161:R = 192   TEXT ,9,,1   Temp$ = "Trend"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 82:L = 119:B = 95:R = 157   TEXT ,10,,1   Temp$ = "Period"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 4:L = 270:B = 20:R = 361    TEXT 0,12,,   Temp$ = "PseudoCycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 52:L = 320:B = 65:R = 372   TEXT 3,10,,1   Temp$ = "Persistent"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 85:L = 323:B = 98:R = 382   Temp$ = "Regressive"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 118:L = 323:B = 131:R = 364   Temp$ = "Trendy"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 151:L = 323:B = 164:R = 376   Temp$ = "Chameleon"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   FN FrameBtn("Done")   T = 27:L = 137:B = 58:R = 149   Hndl& = FN GETRESOURCE(CVI("PICT"),2000):'        Get handle to PICT resource   PICTURE ( 137, 27)-( 149, 58),Hndl&:'                                 Draw it   T = 37:L = 110:B = 59:R = 122   Hndl& = FN GETRESOURCE(CVI("PICT"),2001):'        Get handle to PICT resource   PICTURE ( 110, 37)-( 122, 59),Hndl&:'                                 Draw it   T = 44:L = 79:B = 60:R = 91   Hndl& = FN GETRESOURCE(CVI("PICT"),2002):'        Get handle to PICT resource   PICTURE ( 79, 44)-( 91, 60),Hndl&:'                                   Draw it   T = 177:L = 75:B = 197:R = 139   Hndl& = FN GETRESOURCE(CVI("PICT"),2005):'        Get handle to PICT resource   PICTURE ( 75, 177)-( 139, 197),Hndl&:'                                Draw it   T = 174:L = 134:B = 206:R = 196   Hndl& = FN GETRESOURCE(CVI("PICT"),2006):'        Get handle to PICT resource   PICTURE ( 134, 174)-( 196, 206),Hndl&:'                               Draw it   T = 178:L = 189:B = 208:R = 290   Hndl& = FN GETRESOURCE(CVI("PICT"),2007):'        Get handle to PICT resource   PICTURE ( 189, 178)-( 290, 208),Hndl&:'                               Draw it   T = 165:L = 95:B = 177:R = 131   TEXT ,9,,1   Temp$ = "none"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 169:L = 221:B = 181:R = 263   Temp$ = "variable"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 166:L = 149:B = 178:R = 195   Temp$ = "constant"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 96:L = 94:B = 116:R = 203   Hndl& = FN GETRESOURCE(CVI("PICT"),2004):'        Get handle to PICT resource   PICTURE ( 94, 96)-( 203, 116),Hndl&:'                                 Draw it   T = 124:L = 92:B = 144:R = 200   Hndl& = FN GETRESOURCE(CVI("PICT"),2008):'        Get handle to PICT resource   PICTURE ( 92, 124)-( 200, 144),Hndl&:'                                Draw it   T = 21:L = 260:B = 34:R = 333   Temp$ = "Y     = Y  + "   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 27:L = 265:B = 39:R = 284   TEXT ,9,,1   Temp$ = "i+1"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 28:L = 297:B = 40:R = 305   Temp$ = "i"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 24:L = 314:B = 33:R = 320   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 314, 24)-( 320, 33),Hndl&:'                                 Draw it   T = 29:L = 321:B = 41:R = 340   Temp$ = "i+1"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 54:L = 217:B = 63:R = 223   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 217, 54)-( 223, 63),Hndl&:'                                 Draw it   T = 61:L = 223:B = 73:R = 242   Temp$ = "i+1"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 54:L = 247:B = 63:R = 253   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 247, 54)-( 253, 63),Hndl&:'                                 Draw it   T = 60:L = 254:B = 72:R = 263   Temp$ = "i"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 54:L = 275:B = 63:R = 281   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 275, 54)-( 281, 63),Hndl&:'                                 Draw it   T = 76:L = 71:B = 148:R = 205   CALL FRAMERECT(T)   T = 86:L = 230:B = 99:R = 289   TEXT ,10,,1   Temp$ = "=A(Y-Y )+"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 88:L = 218:B = 97:R = 224   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 218, 88)-( 224, 97),Hndl&:'                                 Draw it   L = 286:R = 292   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 286, 88)-( 292, 97),Hndl&:'                                 Draw it   T = 75:L = 251:B = 88:R = 265   Temp$ = "_"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 91:L = 267:B = 103:R = 274   TEXT ,9,,1   Temp$ = "i"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 118:L = 236:B = 131:R = 281   TEXT ,10,,1   Temp$ = "= B +"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 120:L = 218:B = 129:R = 224   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 218, 120)-( 224, 129),Hndl&:'                               Draw it   T = 127:L = 224:B = 139:R = 243   TEXT ,9,,1   Temp$ = "i+1"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 120:L = 267:B = 129:R = 273   Hndl& = FN GETRESOURCE(CVI("PICT"),2010):'        Get handle to PICT resource   PICTURE ( 267, 120)-( 273, 129),Hndl&:'                               Draw it   T = 45:L = 204:B = 144:R = 204   PEN 3,3,1,8   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 145:B = 145:R = 287   CALL MOVETO(L,T):CALL LINETO(R,B)   L = 288:B = 212:R = 288   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 173:L = 289:B = 173:R = 378   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 44:L = 205:B = 78:R = 382   PEN 1,1,1,8   CALL FRAMERECT(T)   T = 77:B = 111   CALL FRAMERECT(T)   T = 110:B = 145   CALL FRAMERECT(T)   T = 144:L = 289:B = 175   CALL FRAMERECT(T)   T = 194:L = 7:B = 210:R = 63   TEXT 0,12,,1   Temp$ = "Custom"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 0:L = 162:B = 45:R = 247  ' PEN 3,3,1,8,19  ' CALL ERASERECT(T)   PEN 3,3,1,8,0   CALL FRAMERECT(T)   T = 6:L = 186:B = 22:R = 244   TEXT 3,,,1   Temp$ = "UniCycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 24:L = 188:B = 40:R = 240   Temp$ = "BiCycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0) END IF:'                                                 End of WndSetup format'' LONG IF WINDOW(1) = WndSetup2   T = 50:L = 19:B = 66:R = 63   TEXT 0,12,0,0   Temp$ = "Level"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 47:L = 0:B = 47:R = 83   PEN 1,1,1,8,0   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 173:L = 0:B = 173:R = 83   CALL MOVETO(L,T):CALL LINETO(R,B)   TEXT 3,,,1                        '***This is labelling the UniCycle Button***   T = 178:L = 21:B = 194:R = 79   Temp$ = "UniCycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 199:L = 23:B = 215:R = 75   '***This is labelling the BiCycle Button***   Temp$ = "BiCycle"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 218:L = 0:B = 218:R = 83   CALL MOVETO(L,T):CALL LINETO(R,B)   FN FrameBtn("Done") END IF:'                                                End of WndSetup2 format'' LONG IF WINDOW(1) = WndNewHiScore   T = 9:L = 31:B = 25:R = 76   TEXT 0,12,0,0   Temp$ = "Name"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 8:L = 126:B = 24:R = 169   Temp$ = "Score"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 7:L = 196:B = 23:R = 240   Temp$ = "Level"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 25:L = 180:B = 37:R = 222   TEXT 3,9,,0   Temp$ = "Starting"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   L = 221:R = 253   Temp$ = "Ending"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 47:L = 6:B = 50:R = 95   PEN ,,,11:BOX FILL L,T TO R,192:PEN ,,,8   TEXT ,9,,0   IF BiCycle THEN ScoreType=1 ELSE ScoreType=0   FOR HiScorer=0 TO 9      CALL TEXTBOX(VARPTR(HiName$(ScoreType,HiScorer))+1,LEN(HiName$(ScoreType,HiScorer)),T, 0)      TPlus=T+10:PRINT%( 126,TPlus) HiScore(ScoreType,HiScorer)      PRINT%( 180,TPlus) HiStartLevel(ScoreType,HiScorer):PRINT%( 221,TPlus) HiEndLevel(ScoreType,HiScorer)      T=T+12:B=B+12   NEXT HiScorer   T = 22:L = 0:B = 22:R = 251   PEN ,1,1,8,0   CALL MOVETO(L,T):CALL LINETO(R,B)   L = 124:B = 191:R = 124   CALL MOVETO(L,T):CALL LINETO(R,B)   L = 176:B = 192:R = 176   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 33:L = 219:R = 219   PEN ,,1,8,3   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 192:L = 0:B = 192:R = 251   PEN ,,1,8,0   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 199:L = 37:B = 231:R = 203   TEXT 0,12,,0   Temp$ = "You have a high score. "+Cr$+"Enter your name below"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1) END IF:'                                            End of WndNewHiScore format'' LONG IF WINDOW(1) = WndShowHiScore   T = 4:L = 30:B = 20:R = 75   TEXT 0,12,0,0   Temp$ = "Name"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 3:L = 125:B = 19:R = 168   Temp$ = "Score"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 2:L = 195:B = 18:R = 239   Temp$ = "Level"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 18:L = 179:B = 30:R = 221   TEXT 3,9,,0   Temp$ = "Starting"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0)   T = 35:L = 5:B = 45:R = 94   TEXT ,9,,0   IF BiCycle THEN ScoreType=1 ELSE ScoreType=0   FOR HiScorer=0 TO 9      CALL TEXTBOX(VARPTR(HiName$(ScoreType,HiScorer))+1,LEN(HiName$(ScoreType,HiScorer)),T, 0)      TPlus=T+10:PRINT%( 126,TPlus) HiScore(ScoreType,HiScorer)      PRINT%( 180,TPlus) HiStartLevel(ScoreType,HiScorer):PRINT%( 221,TPlus) HiEndLevel(ScoreType,HiScorer)      T=T+12:B=B+12   NEXT HiScorer   T = 17:L =-1:B = 17:R = 250   PEN ,1,1,8,0   CALL MOVETO(L,T):CALL LINETO(R,B)   L = 123:B = 186:R = 123   CALL MOVETO(L,T):CALL LINETO(R,B)   L = 175:B = 187:R = 175   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 28:L = 218:R = 218   PEN ,,1,8,3   CALL MOVETO(L,T):CALL LINETO(R,B)   T = 18:L = 220:B = 30:R = 252   TEXT ,9,,0   Temp$ = "Ending"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0) END IF:'                                           End of WndShowHiScore format'' LONG IF WINDOW(1) = WndAbout   T = 21:L = 9:B = 149:R = 196   TEXT 3,12,0,0   Temp$ = "is a game intended to induce cyclic scepticism in economics students"+Cr$+"and others. "+Cr$+"Designed and programmed by David Friedman"+Cr$+"for Living Paper"+Cr$+"╘David Friedman, 1991"+Cr$   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1)   T = 4:L = 69:B = 20:R = 118   TEXT 0,,,0   Temp$ = "grglflx"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 1)   T = 160:L = 14:B = 209:R = 204   TEXT 3,9,,0   Temp$ = "Special thanks to Zedcor for ZBasic 5.0"+Cr$+"Staz for Program Generator II"+Cr$+"Frederic Brown (?) for the title"+Cr$+"and George Stigler for the idea"   CALL TEXTBOX(VARPTR(Temp$)+1,LEN(Temp$),T, 0) END IF:'                                                 End of WndAbout format''TEXT TxFont,TxSize,TxFace,TxMode:'                        Restore the font specs' CALL SETPENSTATE(PenSpecs$):'                                   Restore the pen'RETURN'"DrawCycle"  IF X=Xmin+DeltaX THEN RETURN  CALL MOVETO (Xmin,Y(BoxType,Xmin))  FOR XDraw=Xmin TO X-DeltaX STEP DeltaX    CALL LINETO (XDraw,Y(BoxType,XDraw))  NEXT XDrawRETURN'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Capture"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥'' LONG IF WINDOW(0) = WndMain'   <-- Insert WINDOW 1  capture routines here END IF' LONG IF WINDOW(0) = WndHelp   GOSUB "Cleanup Help Window"   TW2 = -WINDOW(11):LW2 = -WINDOW(10):BW2 = TW2+WINDOW(3):RW2 = LW2+WINDOW(2):'      Set TLBR to window size   CALL DISABLEITEM(MHndl&(FontMenu),0)   CALL DISABLEITEM(MHndl&(SizeMenu),0)'   <-- Insert WINDOW 2  capture routines here   CALL ENABLEITEM(MHndl&(EditMenu),0):CALL ENABLEITEM(MHndl&(ShowMenu),0)'   CALL CHECKITEM(MHndl&(HelpMenu),HelpCheck,False)   FN Push(MenuEvent) END IF' LONG IF WINDOW(0) = WndSetup'   <-- Insert WINDOW 3  capture routines here END IF' LONG IF WINDOW(0) = WndSetup2'   <-- Insert WINDOW 4  capture routines here END IF' LONG IF WINDOW(0) = WndNewHiScore     IF NOT NewHiScoreFlag THEN GOSUB "Add New High Score"'   <-- Insert WINDOW 5  capture routines here END IF' LONG IF WINDOW(0) = WndShowHiScore'   <-- Insert WINDOW 6  capture routines here END IF' LONG IF WINDOW(0) = WndAbout'   <-- Insert WINDOW 7  capture routines here END IFRETURN'"Cleanup Help Window"				   FirstHelpFlag=True   LONG IF HelpHndl&              :'Is the handle valid?      CALL TEDISPOSE(HelpHndl&)    :'Dump the field we created      BUTTON CLOSE HelpBtn         :'Send the scroll button packin'      HelpHndl& = 0                :'Zero out the handle   END IFRETURN''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"TE Stats"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ SelStart = FN GetWord(TEHANDLE(WINDOW(0)),32):'     Starting point of selection SelEnd   = FN GetWord(TEHANDLE(WINDOW(0)),34):'       Ending point of selection SelLen   = SelEnd-SelStart:'                                Length of selectionRETURN''SEGMENT''╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥"Initialize"'╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥ FN Push(WndSetup2):FN Push(OpenEvent)' Push setup window on to stack, open it. FN Push(WndMain):FN Push(OpenEvent) 'Push main window on stack, tell event mgr to open itGOSUB "Load High Scores"  APPLE MENU "About grglflx..."   FileMenu=1   MHndl&(1) = FN NEWMENU(FileMenu,"File")   CALL APPENDMENU(MHndl&(FileMenu),"New/N")   CALL APPENDMENU(MHndl&(FileMenu),"Open/O")   CALL APPENDMENU(MHndl&(FileMenu),"-")   CALL APPENDMENU(MHndl&(FileMenu),"Save/S")   CALL APPENDMENU(MHndl&(FileMenu),"Save Asи")   CALL APPENDMENU(MHndl&(FileMenu),"-")   CALL APPENDMENU(MHndl&(FileMenu),"Page Setupи")   CALL APPENDMENU(MHndl&(FileMenu),"Print")   CALL APPENDMENU(MHndl&(FileMenu),"-")  ' CALL APPENDMENU(MHndl&(FileMenu),"(Close")   CALL APPENDMENU(MHndl&(FileMenu),"Quit/Q")   CALL INSERTMENU(MHndl&(FileMenu),0)   EditMenu=2 MHndl&(2) = FN NEWMENU(EditMenu,"Edit")   CALL APPENDMENU(MHndl&(EditMenu),"Copy Picture/C")   CALL APPENDMENU(MHndl&(EditMenu),"Copy Series") '  CALL APPENDMENU(MHndl&(EditMenu),"Clear")   CALL INSERTMENU(MHndl&(EditMenu),0) 'WindowMenu = 3 'MHndl&(WindowMenu) = FN NEWMENU(WindowMenu,"Window")  ' MainItem = 1  ' CALL APPENDMENU(MHndl&(WindowMenu),"Main Window")  ' SetupItem = 2 '  CALL APPENDMENU(MHndl&(WindowMenu),"Setup Window") '  ScoresItem = 3  ' CALL APPENDMENU(MHndl&(WindowMenu),"High Scores")  ' CALL INSERTMENU(MHndl&(WindowMenu),0)'CALL DISABLEITEM(MHndl&(WindowMenu),1)'CALL DISABLEITEM(MHndl&(WindowMenu),2) FontMenu = 3 MHndl&(FontMenu) = FN NEWMENU(FontMenu,"Font")   CALL DISABLEITEM(MHndl&(FontMenu),0)   FontMHndl& = MHndl&(FontMenu):'                           Handle used in subs   CALL ADDRESMENU(FontMHndl&,CVI("FOND")):'           Menu shows FOND resources   CALL INSERTMENU(MHndl&(FontMenu),0) SizeMenu = 4 MHndl&(SizeMenu) = FN NEWMENU(SizeMenu,"Size")   CALL DISABLEITEM(MHndl&(SizeMenu),0)   SizeMHndl& = MHndl&(SizeMenu):'                           Handle used in subs   PointItem = 5   CALL APPENDMENU(MHndl&(SizeMenu),"9 point!")   CALL APPENDMENU(MHndl&(SizeMenu),"12 point")   CALL APPENDMENU(MHndl&(SizeMenu),"14 point")   CALL APPENDMENU(MHndl&(SizeMenu),"18 point")   CALL INSERTMENU(MHndl&(SizeMenu),0) ShowMenu = 5 MHndl&(ShowMenu) = FN NEWMENU(ShowMenu,"Show")   CycleItem = 1:ShowCycle=False   CALL APPENDMENU(MHndl&(ShowMenu),"Show Cycle")   ScoresItem = 2   CALL APPENDMENU(MHndl&(ShowMenu),"Show High Scores")   'MeanItem = 2:ShowMean=False   'CALL APPENDMENU(MHndl&(ShowMenu),"Show Mean")   'TrendItem = 3:ShowTrend=False   'CALL APPENDMENU(MHndl&(ShowMenu),"Show Trend")   CALL INSERTMENU(MHndl&(ShowMenu),0) HelpMenu = 6 MHndl&(HelpMenu) = FN NEWMENU(HelpMenu,"Help")   InstructionsItem = 1   CALL APPENDMENU(MHndl&(HelpMenu),"Instructions/I")   HelpItem = 2   CALL APPENDMENU(MHndl&(HelpMenu),"Help/H")   CALL INSERTMENU(MHndl&(HelpMenu),0)'  Temp$=FN Chk1Item$(SizeMHndl&,1):'            Set font size to first menu item  FontSize=VAL(Temp$)'' FN Chk1Name(FontMHndl&,"Geneva"):'                         Set font to "Geneva" CALL GETFNUM("Geneva",FontNum) GOSUB"Suggest Size"'CALL DRAWMENUBAR  TW2 = 0:LW2 = 0:BW2 = 260:RW2 = 464:'      Set TLBR to window size'             Offset the rect to the center of the screen  CALL OFFSETRECT(TW2,ScrnR/2-RW2/2,(ScrnB/2+8)-BW2/2)CALL SETRECT(TopRect(0),Xmin,Ytop(0),Xmax,Ybottom(0))CALL SETRECT(BottomRect(0),Xmin,Ytop(1),Xmax,Ybottom(1))GOSUB "Make Normal Array"GOSUB "Load High Scores"GOSUB "Environs"IF SndCapable THEN GOSUB "Load Snd" HelpText$="Instructions"Level=1:X=Xmin+DeltaXCopyFlag=False:SetupFlag=False:FirstHelpFlag=True:GoFlag=True:AnswerFlag=False:BiCycle=TrueNewHiScoreFlag=False:Practice=TrueRETURN''"Make Normal Array"   NormalNbr=99:MidNormal=(NormalNbr+1)/2  Normal(MidNormal)=0: A0!=(SQR(6.283))/NormalNbr:X!=A0!/2            FOR R=MidNormal+1 TO NormalNbr    Anext!=A0!*EXP(X!*X!/2):    Normal(R)=(4.*(X!+(Anext!/2))):X!=X!+Anext!     Normal(NormalNbr+1-R)=-Normal(R)  NEXT RRETURN'"Load High Scores" '***High scores are in a STR# resource, each string is name+CR$+HiScore+CR$+ ...  IF ResRef=-1 THEN HomeResFile=PEEK WORD (&900) ELSE HomeResFile=ResRef    CurRes = FN CURRESFILE                      :'Store current res ref  CALL USERESFILE(HomeResFile)                :'Make the file that  HiScoreHndl&=FN GETNAMEDRESOURCE(CVI("STR#"),"HiScores") IF HiScoreHndl&=0 THEN STOP  OSErr=FN HLOCK(HiScoreHndl&)  FPtr&=PEEK LONG(HiScoreHndl&)  NbrOfStrings=PEEK WORD(FPtr&):  FPtr&=FPtr&+2  FOR Version=0 TO 1:FOR Player=0 TO 9    BLOCKMOVE FPtr&,VARPTR(NamePlusScore$),PEEK(FPtr&)+1    FPtr&=FPtr&+PEEK(FPtr&)+1    HiNameEnd=INSTR(1,NamePlusScore$,Cr$)-1    HiScoreEnd=INSTR(HiNameEnd+2,NamePlusScore$,Cr$)-1    HiStartEnd=INSTR(HiScoreEnd+2,NamePlusScore$,Cr$)-1    HiEndEnd=INSTR(HiStartEnd+2,NamePlusScore$,Cr$)-1    HiName$(Version,Player)=LEFT$(NamePlusScore$,HiNameEnd)    HiScore(Version,Player)=VAL(MID$(NamePlusScore$,HiNameEnd+2,(HiScoreEnd-HiNameEnd-1)))    HiStartLevel(Version,Player)=VAL(MID$(NamePlusScore$,HiScoreEnd+2,(HiStartEnd-HiScoreEnd-1)))    HiEndLevel(Version,Player)=VAL(MID$(NamePlusScore$,HiStartEnd+2,(HiEndEnd-HiStartEnd-1)))  NEXT Player:NEXT Version  OSErr=FN HUNLOCK(HiScoreHndl&):CALL RELEASERESOURCE(HiScoreHndl&):  CALL USERESFILE(CurRes)                     :'Switch back to original resource file  IF HiScoreHndl& THEN OSErr=FN DISPOSHANDLE(HiScoreHndl&)RETURN'"Save High Scores"  ResLength&=2   '***This chunk calculates size of Str# resource to be created  FOR V=0 TO 1:FOR P=0 TO 9   '***V is Version, P is Player***    NamePlusScore$=HiName$(V,P)+Cr$+STR$(HiScore(V,P))+Cr$+STR$(HiStartLevel(V,P))+Cr$+STR$(HiEndLevel(V,P))    ResLength&=ResLength&+LEN(NamePlusScore$)+1  NEXT P:NEXT V  HiScoreHndl&=FN NEWHANDLE(ResLength&)  FPtr&=USR 3(HiScoreHndl&)  'PEEK LONG(HiScoreHndl&) '***Pointer to beginning of Str# Resource-to-be in memory***  POKE WORD FPtr&,20   '***put number of strings in Str# Resource-to-be***    FPtr&=FPtr&+2:FPtrOld&=FPtr&  '***Points at length byte for first string  FOR V=0 TO 1:FOR P=0 TO 9   '***V is Version, P is Player***    NamePlusScore$=HiName$(V,P)+Cr$+STR$(HiScore(V,P))+Cr$+STR$(HiStartLevel(V,P))+Cr$+STR$(HiEndLevel(V,P))    BLOCKMOVE VARPTR(NamePlusScore$),FPtr&,LEN(NamePlusScore$)+1    FPtr&=FPtr&+LEN(NamePlusScore$)+1  NEXT P:NEXT V  FPtr&=USR 7(HiScoreHndl&)  CurRes = FN CURRESFILE                      :'Store current res ref  CALL USERESFILE(HomeResFile) 'This would make sure you got HiScores from right place.  OldHiScoreHndl&=FN GETNAMEDRESOURCE(CVI("STR#"),"HiScores")  IF OldHiScoreHndl&=0 THEN STOP  'HomeResFile = FN HOMERESFILE(OldHiScoreHndl&)         :'Get its res reference  'CurRes = FN CURRESFILE                      :'Store current res ref  'CALL USERESFILE(HomeResFile)                :'Make the file that  CALL RMVERESOURCE(OldHiScoreHndl&)  CALL ADDRESOURCE(HiScoreHndl&,CVI("STR#"),128,"HiScores")  CALL UPDATERESFILE(HomeResFile)  CALL USERESFILE(CurRes)                     :'Switch back to original resource file  CALL RELEASERESOURCE(HiScoreHndl&):  CALL RELEASERESOURCE(OldHiScoreHndl&):  IF OldHiScoreHndl& THEN OSErr=FN DISPOSHANDLE(OldHiScoreHndl&)   IF HiScoreHndl& THEN OSErr=FN DISPOSHANDLE(HiScoreHndl&)RETURN'"Load Snd"  CurRes = FN CURRESFILE                      :'Store current res ref  CALL USERESFILE(HomeResFile) 'This would make sure you got Snds from right place.FOR MyWord=0 TO 1  SndHndl&(MyWord)=FN GETNAMEDRESOURCE(CVI("snd "),Snd$(MyWord))  IF SndHndl&(MyWord)=0 THEN STOPNEXT MyWord  CALL USERESFILE(CurRes)                     :'Switch back to original resource fileRETURN'"Environs"  '***Call this to check for system version*** OSErr=FN SYSENVIRONS(1,VARPTR(EnvVersion)) IF (SystemVersion>&H0601) OR (MachineType>3) THEN SndCapable=True ELSE SndCapable=FalseWINDOW 1 PRINT "System:";HEX$(SystemVersion);"  Machine:";MachineType:DELAY 3000:WINDOW CLOSE 1RETURN''***Save/Load Code***"Get Simple Lgth"'                   get length of simple variables   VarLgth& = VARPTR(LastVar)-VARPTR(FirstVar)'     size is last-firstRETURN"Get Array Lgth"   DIM LastArray(1)'       have to DIM here so array is at end of list   VarLgth& = VARPTR(LastArray(1))-VARPTR(FirstArray(0))'  calc lengthRETURN'***Ends Save/Load Code***'