/* this is the file for doing animation of trade paths in Hansa */#include "animation.h"#include "animationP.h"#define kSpriteIcon 128void InitAnimation(){	spriteIcon = GetCIcon(kSpriteIcon);}#undef kSpriteIcon/* Update animation gets called once every cycle.									*//*																					*//* if this is the start of an animation cycle (first call after the user has 		*//* chosen production or consumption view, it initializes the start location for 	*//* all cities and then plots the appropriate trade route icon.						*//* if it is in the middle of an animation, it calculates where the next plot has 	*//* to be, replaces the current plot, and draws the new one.							*//* if it is at the end of an animation, it replaces the last animation with the map *//* and frees up all the memory used in the list of cities.							*//*																					*//* data structures:																	*//*																					*//* we keep a linked list representing all the trade routes and where they currently *//* are in the animation. When we get to the end, we start over again				*/void UpdateAnimation(){	enum viewMode 	currentViewMode;	CWindowPtr		savePort;			if (!IsGameInProgress())		return;		GetPort(&savePort);	SetPort(GetMapWindow());/* first, return most of the time *//* situation 1: no animation is wanted or in progress */	if (((currentViewMode = GetViewMode()) != productionView) && (currentViewMode != consumptionView) &&		(lastViewMode != productionView) && (lastViewMode != consumptionView))		;		/* situation 2: an animation is in progress and not wanted */	else if ((currentViewMode != productionView) && (currentViewMode != consumptionView))		killAnimation();		/* situation 3: we don't have an animation, but want one */	else if ((lastViewMode != consumptionView) && (lastViewMode != productionView))		createAnimation(); 			/* situation 4: we've just switched goods that we're looking at */	else if (GetCurrentView() != lastGood) {		killAnimation();		createAnimation();	}/* situation 5: we've just switched between production and consumption modes */	else if (lastViewMode != currentViewMode) {		killAnimation();		createAnimation();	}	/* last situation: we want to continue the animation */	else 		continueAnimation();		lastViewMode = currentViewMode;	lastGood = GetCurrentView();	SetPort(savePort);}/* we've just switched to a view that needs some animation. What we have to do is:	*//*																					*//* 1) create a linked list of all the cities that need produce/consume (pick the 	*//*    right one) the current good.													*//* 2) for each of those cities, make a list of the hexes we have to traverse.		*//* 3) for each of the cities in the list, save the start point as the current point *//*    and point at the first hex as the place we have to go next					*//* (1, 2, 3 all get collapsed into 1 loop.)											*//* 4) for each city in the list, draw the initial sprite.							*/void createAnimation(){	short thisCity, targetCity;		if (GetCurrentView() == noGood)		return;	DrawCities();	SaveToOffscreenMap();	for (thisCity = 0; thisCity < maxNumberOfCities; thisCity++)			for (targetCity = 0; targetCity < maxNumberOfCities; targetCity++)				if ((GetLeague(targetCity) == GetCurrentPlayer()) &&					(((GetViewMode() == productionView) && (GetExport(thisCity, targetCity, GetCurrentView()) > 0)) ||					 ((GetViewMode() == consumptionView) && (GetImport(targetCity, thisCity, GetCurrentView()) >0))))					createSpriteRecord(thisCity, targetCity);						drawSprites();}void continueAnimation(){	struct spriteRecord *p;	Rect				spriteRect;	Point				l;		if (--timer != 0)		return;	timer = 10; 	p = firstSpriteP;	while (p != NULL) {		SetRect(&spriteRect, (l = p->currentLocation).h-3, l.v-3, l.h+4, l.v+4);		if (EqualPt(p->currentLocation, p->finalLocation))			p->currentLocation = p->startLocation;		else {			if (p->currentLocation.h < p->finalLocation.h)				p->currentLocation.h++;			else if (p->currentLocation.h > p->finalLocation.h)				p->currentLocation.h--;			if (p->currentLocation.v < p->finalLocation.v)				p->currentLocation.v++;			else if (p->currentLocation.v > p->finalLocation.v)				p->currentLocation.v--;		}		CopyOffscreenMap(&spriteRect);		drawOneSprite(p);		p = p->nextP;	}}void drawSprites(){	struct spriteRecord	*currentSpriteP;		currentSpriteP = firstSpriteP;	while (currentSpriteP != NULL) {		drawOneSprite(currentSpriteP);		currentSpriteP = currentSpriteP->nextP;	}}void drawOneSprite(struct spriteRecord *spriteP){	Point				p;	Rect				spriteRect;	SetRect(&spriteRect, (p = spriteP->currentLocation).h-3, p.v-3, p.h+4, p.v+4);	PlotCIcon(&spriteRect, spriteIcon);}/* we've got to recursively kill all the sprite records */void killAnimation(){	if (firstSpriteP != NULL) { // make sure we're addressing something 		killSpriteRecord(firstSpriteP);		firstSpriteP = NULL;	}	CopyOffscreenMap(&(GetMapWindow()->portRect));}void killSpriteRecord(struct spriteRecord *killP){	if (killP->nextP != NULL)		killSpriteRecord(killP->nextP);	DisposPtr(killP);}/* go and make a sprite record, and attach it to the list */void createSpriteRecord(short fromCity, short toCity){	struct spriteRecord *tP;	Point t;		tP = (struct spriteRecord *) NewPtr(sizeof(struct spriteRecord));	tP->nextP = NULL;	t = GetLocation(fromCity);	tP->currentLocation = GetCenterPt(t.h, t.v);	tP->startLocation = tP->currentLocation;	t = GetLocation(toCity);	tP->finalLocation = GetCenterPt(t.h, t.v);	if (firstSpriteP == NULL) {		firstSpriteP = tP;		lastSpriteP = tP;	}	else {		lastSpriteP->nextP = tP;		lastSpriteP = tP;	}}