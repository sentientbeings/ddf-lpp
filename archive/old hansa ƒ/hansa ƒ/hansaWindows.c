/* this file contains all the window stuff for the game Hanseatic 		*//* League.																*/#include "hansaWindows.h"#include "hansaWindowsP.h"#include <Quickdraw.h>/* public procedures *//* do the processing associated with the player doing something in one of our windows */void DoContent(WindowPtr theWindow, EventRecord *theEvent, enum mouseEventType typeOfEvent){	int 			city1, city2;	Point 			start, end;	SetPort(theWindow);	start = (*theEvent).where;	GlobalToLocal(&start);	if ((CWindowPtr)theWindow == GetMapWindow())		switch (typeOfEvent) {							case doubleClick:			if (((city1 = cityPicked(start)) != noCity)) {				if (CityInLeague(city1) == true) {					SetProductionCity(city1);					ShowProductionWindow(city1, true);				} else if ((GetLearningMode()) && (GetPlayerStatus(GetLeague(city1)) == computer))					ShowProductionWindow(city1, true);				else {					ParamText(GetCityName(city1), GetCityName(city1), GetCityName(city1), GetCityName(city1));					Alert(CityNotInLeagueID, 0L);				}			}			break;					case dragClick:			UpdateWindow((WindowPtr)GetMapWindow());			if (((city1 = cityPicked(start)) != noCity) && (CityInLeague(city1) == true)) 				if (((city2 = cityPicked(end = drawDestinationLine(start))) != noCity) &&					(city1 != city2)) {					AddAnimationPath(city1, city2); // go and add in the traced path					if (CityInLeague(city2) == true)						ShowTradeWindow(city1, city2, true);					else TryToJoinTradeLeague(city1, city2);				}			break;		}	else if ((city1 = MatchProductionWindow(theWindow)) != noCity)		ShowProductionWindow(city1, false);	else if (theWindow == (WindowPtr)GetTradeWindow())		ShowTradeWindow(GetTradeCity1(), GetTradeCity2(), false);}void DoWaitWindow(enum buildPhase phase){	Rect r;	static WindowPtr myWindow;	static TEHandle scriptH;	Handle resourceH;	if (phase == finalPhase) {		CloseWindow(myWindow);		TEDispose(scriptH);		return;	}	if (phase == raiseContinentPhase) {		SetRect(&r, 50, 80, 470, 240);		SetPort((myWindow = NewWindow( 0L, &r, "\p", 1, 1, (WindowPtr)-1L, 0, 0L)));		TextFont(london);		TextSize(18);		scriptH = TENew(&(myWindow->portRect), &(myWindow->portRect));	}	EraseRect(&(myWindow->portRect));	resourceH = GetResource('TEXT', phaseWindow[phase]);	HLock(resourceH);	TESetText(*resourceH, GetHandleSize(resourceH), scriptH);	TEUpdate(&(myWindow->portRect), scriptH);	HUnlock(resourceH);	ReleaseResource(resourceH);}void DrawCities(void){	int i;	GrafPtr savePort;		GetPort(&savePort);	SetPort((GrafPtr) GetMapWindow());	for (i = 0; i < GetNumberOfCities(); i++)		drawCity(GetLocation(i));	SetPort(savePort); }void DrawLaborBar(DialogPtr dPtr, int laborBar, int amountBar, Boolean mustDraw){	ControlHandle 	goodH;	short 			type;	Rect			drawRect;	Str255			numberString, testString;	short			city;	SetPort(dPtr);	if (dPtr == GetTradeWindow())		city = (laborBar == tLaborBar1Item) ? GetTradeCity1() : GetTradeCity2();	else city = MatchProductionWindow(dPtr);	GetTransportCostString((char *)numberString, (unsigned short)LaborAvailable(city), false, city);	GetDItem(dPtr, amountBar, &type, (Handle *) &goodH, &drawRect);	GetIText((Handle) goodH, testString);	if (mustDraw  || (!EqualString(numberString, testString, true, true))) {		SetIText((Handle) goodH, numberString);		GetDItem(dPtr, laborBar, &type, (Handle *) &goodH, &drawRect);		SetRect(&drawRect, 	drawRect.left, 							drawRect.top, 							drawRect.left+(int)(((baseLabor-LaborAvailable(city))/100)*2.7), 							drawRect.bottom);		FillRect(&drawRect, &(qd.white));		GetDItem(dPtr, laborBar, &type, (Handle *) &goodH, &drawRect);		SetRect(&drawRect,	drawRect.left+(int)(((baseLabor-LaborAvailable(city))/100)*2.7), 							drawRect.top, 							drawRect.right, 							drawRect.bottom);		FillRect(&drawRect, &(qd.black));	} 	if (mustDraw) {		GetDItem(dPtr, laborBar, &type, (Handle *) &goodH, &drawRect);		SetRect(&drawRect, drawRect.left-1, drawRect.top-1, drawRect.right+1, drawRect.bottom+1);		FrameRect(&drawRect);	}}void DrawUtilityBar(DialogPtr dPtr, int utilityBar, int amountBar){	ControlHandle 	goodH;	short 			type;	Rect			drawRect, drawRectCopy;	short 			city;	Str255			numberString;		SetPort(dPtr);	if (dPtr == GetTradeWindow()) 		city = (utilityBar == tUtilityBar1Item) ? GetTradeCity1() : GetTradeCity2();	else city = MatchProductionWindow(dPtr);	FloatToString(numberString, GetUtility(city), 2);	GetDItem(dPtr, amountBar, &type, (Handle *) &goodH, &drawRect);	SetIText((Handle) goodH, numberString);	GetDItem(dPtr, utilityBar, &type, (Handle *) &goodH, &drawRect);	SetRect(&drawRectCopy,	drawRect.left+(int)(GetUtility(city)*10.0)+1, 						drawRect.top, 						drawRect.right, 						drawRect.bottom);	FillRect(&drawRectCopy, &(qd.white));	SetRect(&drawRectCopy, 	drawRect.left+1, 						drawRect.top, 						drawRect.left+(int) (GetUtility(city)*10.0)+1, 						drawRect.bottom);	if (GetUtility(city) < GetAutarchicLevel(city))		FillRect(&drawRectCopy, &(qd.gray));	else FillRect(&drawRectCopy, &(qd.black));	SetRect(&drawRectCopy, 	drawRect.left, 							drawRect.top-6, 							drawRect.right, 							drawRect.top);	FillRect(&drawRectCopy, &(qd.white));	MoveTo(drawRect.left+((int)(GetAutarchicLevel(city)*10.0))+(int)(GetOfferLevel(city, GetLeague(city)) * 10.0), drawRect.top-1);	PenPat(&(qd.gray));	Line(0, -5);	PenPat(&(qd.black));	MoveTo(drawRect.left+(int)(GetAutarchicLevel(city)*10.0), drawRect.top-1);	Line(0, -5);	SetRect(&drawRect, drawRect.left, drawRect.top-1, drawRect.right+1, drawRect.bottom+1);	FrameRect(&drawRect);}void LostGame(void){	DialogPtr p;		SetPort(p = GetNewDialog(lostGameID, 0L, (WindowPtr)-1L));	SelectWindow(p);	DrawDialog(p);	do  {	} while (!Button());	CloseWindow(p);	UpdateWindow((WindowPtr)GetMapWindow());}/* what we have to do when an event occurs in a dialog box */void ProcessDialogEvent(EventRecord *eventP, DialogPtr dialogP){	register short	city;	short item;	if (DialogSelect(eventP, &dialogP, &item)) {		SetPort(dialogP);		if (dialogP == GetDisplayWindow())			ProcessDisplayEvent(eventP, dialogP, item);		else if (dialogP == GetTradeWindow())			ProcessTradeEvent(eventP, dialogP, item);		else if (dialogP == GetOfferWindow())			ProcessOfferEvent(eventP, dialogP, item);		else if ((city = MatchProductionWindow(dialogP)) != noCity)			ProcessProductionEvent(eventP, dialogP, item);	} else switch (eventP->what) {			case updateEvt:			UpdateWindow(dialogP);			break;	}}/* do start of program window initialization. This initializes the savemap, builds the world, *//* though perhaps that whould be done elsewhere, and creates production and trade windows. */void SetUpWindows(void){		InitPixMaps();	DrawMap(false);}/* what we do when an updateEvent occurs. */void UpdateWindow(WindowPtr theWindow){	GrafPtr	savePort;		GetPort(&savePort);	SetPort(theWindow);	BeginUpdate(theWindow);	if ((CWindowPtr)theWindow == GetMapWindow()) 		CopyOffscreenMap(&(theWindow->portRect));	EndUpdate(theWindow);	if ((CWindowPtr)theWindow == GetMapWindow())		DrawCities();	if (theWindow == GetDisplayWindow())		DrawDisplayWindow();	SetPort(savePort);}/* announce that someone has won the game */void WonGame(void){	DialogPtr p;	int i;		for (i = 0; i < numberOfWinWindows; i++) {		p = GetNewDialog(WinGameID[i], 0L, (WindowPtr)-1L);		SelectWindow(p);		DrawDialog(p);		do {		} while (!Button());		CloseWindow(p);	}	ExitToShell();}/* private procedures *//* Is there a city where at the point (mouse click)? If there is, which one? */short cityPicked(Point where){	short i;	Point t, p;	for (i = 0; i < GetNumberOfCities(); i++) {		p = GetLocation(i);		t = GetCenterPt(p.h, p.v);		if (PointsNear(where, t))			return i;	}	return noCity;}void drawCity(Point p){	enum goodTypes good;//	int trade;	Point centerPt; //, t;	Rect cityRect;	short  city; //, i;		centerPt = GetCenterPt(p.h, p.v);	if (GetLeague(city = GetCityIndex(p)) == GetCurrentPlayer()) {		SetRect(&cityRect, centerPt.h-7, centerPt.v-7, centerPt.h+8, centerPt.v+8);		switch (GetViewMode()) {					case laborView:			if (LaborAvailable(city) < 100)				drawCityStatus(0.0, &cityRect, false);			else drawCityStatus(((float) LaborAvailable(city)) / 5000.0, &cityRect, false);			break;					case utilityView:			if (GetAutarchicLevel(city) > 0.0)				drawCityStatus((GetUtility(city) / GetAutarchicLevel(city)) *.5, &cityRect, true);			else				drawCityStatus(1.0, &cityRect, false);			break;					case normalView:		case noView:			PlotCIcon(&cityRect, GetLeagueIcon(GetLeague(city)));			FrameOval(&cityRect);			break;				case productionView:		case consumptionView:		case productionCostView:					if ((good = GetCurrentView()) == noGood) {					PlotCIcon(&cityRect, GetLeagueIcon(GetLeague(city)));				FrameOval(&cityRect);			}  else {			/*	for (i = city+1; i < maxNumberOfCities; i++)					if ((trade = GetTradeBetweenCities(city, i, good)) != 0) {						trade = (int) log((double)abs(trade)) + 1;						PenSize(trade, trade);						MoveTo(centerPt.h, centerPt.v);						t = GetLocation(i);						GetCenterPt(t.h, t.v);						LineTo(centerPt.h, centerPt.v);					} trc 29 June 1993 */				PenNormal();				if (GetViewMode() == productionView) {					if (GetProductionCost(city, good) > 0)						drawCityStatus((float) GetProduction(city, good) / (float) (50 / GetProductionCost(city, good)) , &cityRect, false);					else drawCityStatus(0.0, &cityRect, false);				} else 	if (GetViewMode() == consumptionView) 					drawCityStatus(GetItemTotal(city, good) * .1, &cityRect, false);				else if (GetViewMode() == productionCostView)					drawCityStatus(GetProductionCost(city, good) * .25, &cityRect, false);			}			break;						}	} else {		SetRect(&cityRect, centerPt.h-5, centerPt.v-5, centerPt.h+6, centerPt.v+6);		if (OfferProferred(city)) {			FillOval(&cityRect, &(qd.black));			FrameOval(&cityRect);	 	} else if (GetLeague(city) != noLeague) {			PlotCIcon(&cityRect, GetLeagueIcon(GetLeague(city)));			FrameOval(&cityRect);		} else if (GetLeague(city) == noLeague) {			FillOval(&cityRect, &(qd.white));			FrameOval(&cityRect);		}	}}void drawCityStatus(float percent, Rect *rectP, Boolean grayMinimum){	percent *= 360.0;	if ((percent > 0.0) && (percent < 30.0))		percent = 30.0;	if (percent <= 0.0) {		FillOval(rectP, &(qd.white));		InsetRect(rectP, 1, 1);		FrameOval(rectP);		InsetRect(rectP, -1, -1);	} else if ((percent < 180.0) && (grayMinimum)) {		FillOval(rectP, &(qd.ltGray));		PaintArc(rectP, 0, (int)(percent));	} else if (percent >= 360.0)		FillOval(rectP, &(qd.black));	else {		FillOval(rectP, &(qd.white));		PaintArc(rectP, 0, (int)(percent));	}	FrameOval(rectP);}/* draw the path where the mouse is being dragged. Return the point where the mouse   is released. I use an object called hexStack to implement all this. That will   eventually get copied to an animation structure to trace a path for flow of goods. */Point drawDestinationLine(Point where){	const short		illegalCrsr = 51;	const long		zeroCursor = 128;	Point 			destP, oldP, loc;	const Point		errHex = { -1, -1 };	CCrsrHandle		currentCrsrH;	short			currentCrsr = 0, newCrsr;		SetPt(&oldP, where.h, where.v);	InitHexStack();	PushHex(GetLocation(cityPicked(where)));	InvertTopHex();	SetCCursor( currentCrsrH = GetCCursor(zeroCursor));	while (WaitMouseUp() == true) {		GetMouse(&destP);		if (EqualPt(oldP, destP) == FALSE) {			SetPt(&oldP, destP.h, destP.v);			loc = GetHex(destP);			if (EqualPt(errHex, loc) && (currentCrsr != illegalCrsr)) {				currentCrsr = illegalCrsr;				ReleaseResource((Handle) currentCrsrH);				SetCCursor(currentCrsrH = GetCCursor(zeroCursor+illegalCrsr));			}			else if ((!EqualPt(GetTopHex(), loc)) && (!TrimHexStack(loc)))				{				newCrsr = (GetStackCost()+99)/100;				if (newCrsr != currentCrsr) {					currentCrsr = newCrsr;					ReleaseResource((Handle) currentCrsrH);					SetCCursor( currentCrsrH = GetCCursor(zeroCursor+currentCrsr));				}				if (PushHex(loc))					InvertTopHex();			}			if ((!EqualPt(errHex, loc)) && (!EqualPt(GetTopHex(), loc))) {				if (EqualPt(GetLastHex(), loc)) { /* we've backed up a hex */					InvertTopHex();					PopHex();				} else if (PushHex(loc))					InvertTopHex();			}		}	}	InvertHexStack();	InitCursor();	AdjustTransportCosts();	ReleaseResource((Handle) currentCrsrH);	return destP;}/* delete a chain of hexes and uninvert their screen locations */