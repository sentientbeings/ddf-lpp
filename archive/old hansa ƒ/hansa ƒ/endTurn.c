/* this is the .c file for taking care of end of turn processing.		*//* Modification History:												*/#include "endTurn.h"#include "endTurnP.h"/* end of turn processing consists of two parts: end of a player doing	*//* things, and end of a turn cycle. After the first, we just close 		*//* windows and go to the next player. (We might have to toss them from	*//* the game). After the end of tur cycle, we must also resolve how the	*//* turn went.															*/void DoEndTurn(void){	int *p;		BringToFront((WindowPtr) GetMapWindow());	UpdateWindow((WindowPtr)GetMapWindow());	if (GetCurrentPlayer() == GetLastActivePlayer()) {		p = (int *) *turnH;		*p = *p+1;		updateLeagueCities();		ResolveOffers();		SetCurrentPlayer(GetFirstActivePlayer());	}	else SetCurrentPlayer(GetNextActivePlayer(GetCurrentPlayer()));	CloseProductionWindows(false);	CloseTradeWindow(false);	CloseOfferWindow();	SetViewMode(noView);	SetCurrentView(noGood);	CopyOffscreenMap(&(GetMapWindow()->portRect));	DrawCities();	DrawDisplayWindow();	if (GetCurrentPlayer() == GetFirstActivePlayer())		reportEndOfTurnResults();	if (GetPlayerStatus(GetCurrentPlayer()) == computer)		DoComputerTurn();}void InitTurnInfo(void){	int *p;		turnH = NewHandle(sizeof(int));	p = (int *) *turnH;	*p = 1;}void DestroyTurnInfo(void){	DisposHandle(turnH);}void RestoreTurnInfo(void){	turnH = GetNamedResource('TABL', "\pturn");	DetachResource(turnH);}void SaveTurnInfo(void){	AddResource(turnH, 'TABL', UniqueID('TABL'), "\pturn");	WriteResource(turnH);	DetachResource(turnH);}/* private procedures *//* drop a city from a league */void dropCity(short city){	ZeroTrade(city);	DeleteAnOffer(city, GetLeague(city));	SetMissionCost(city, 0);	SetLeague(city, noLeague);}void reportEndOfTurnResults(void){	Str255 report[maxNumberOfPlayers+1];	short i, j, number;		for (i = 1; i <= maxNumberOfPlayers; i++) {		report[i][0] = 0;		switch (GetPlayerStatus(i)) {				case inactive:			concatP((char *) report[i], (char *)"\pInactive.");			break;					case computer:			concatP((char *) report[i], (char *)"\pComputer. ");			break;					case human:			number = 0;			for (j = 0; j < GetNumberOfCities(); j++) 				if ((GetLeague(j) == i) && (lastTurn[j] != i)) {					if (number++ != 0)						concatP((char *) report[i], (char *)"\p, ");					concatP((char *) report[i], (char *) GetCityName(j));				}			if (number == 0)				concatP((char *) report[i], (char *)"\pNone");			concatP((char *) report[i], (char *)"\p joined. ");			number = 0;			for (j = 0; j < GetNumberOfCities(); j++) 				if ((GetLeague(j) != i) && (lastTurn[j] == i)) {					if (number++ != 0)						concatP((char *) report[i], (char *)"\p, ");					concatP((char *) report[i], (char *) GetCityName(j));				}			if (number == 0)				concatP((char *) report[i], (char *)"\pNone");			concatP((char *) report[i], (char *)"\p left. ");			number = 0;			for (j = 0; j < GetNumberOfCities(); j++) {				if ((GetLeague(j) == i) && (lastTurn[j] == i) && (GetUtility(j) + GetOfferLevel(j, i) < GetAutarchicLevel(j))) {					if (number++ != 0)						concatP((char *) report[i], (char *)"\p, ");					concatP((char *) report[i], (char *) GetCityName(j));				}			}			if (number == 0)				concatP((char *) report[i], (char *) "\pNone");			concatP((char *) report[i], (char *) "\p unhappy.");			break;		}	}	ParamText(report[1], report[2], report[3], report[4]);	Alert(endOfTurnID, 0L);	if (GetNumberOfHumanPlayers() == 0) {		LostGame();		ExitToShell();	}}/* do end of turn processing of a league. First, take a snapshot of 	*//* the cities current status; then resolve the city situation in each	*//* league. Drop any league out of the game that loses. Next, resolve	*//* any offers, and again drop any league out of the game that loses. 	*//* Finally, settle up any end of turn accounting for cities.			*/void updateLeagueCities(void){	short i, j, testVal;		for (i = 0; i < GetNumberOfCities(); i++)		lastTurn[i] = GetLeague(i);	for (i = 1; i <= maxNumberOfPlayers; i++)		if ((GetPlayerStatus(i) != inactive) && GetPlayerStatus(i) != computer) {			for (j = 0; j < GetNumberOfCities(); j++)				if (GetLeague(j) == i)					if (GetUtility(j) + GetOfferLevel(j, i) < GetAutarchicLevel(j)) {						testVal = 500 + (int) ((GetAutarchicLevel(j) - GetUtility(j)) * 10.0);						if (test(testVal))							dropCity(j);					} 			if (NumberOfCitiesInLeague(i) <=1)				DropPlayer(i);					}	ResolveOffers();	for (i = 1; i <= maxNumberOfPlayers; i++)		if ((GetPlayerStatus(i) != inactive) && (NumberOfCitiesInLeague(i) <= 1))			DropPlayer(i);	for (j = 0; j < GetNumberOfCities(); j++)		SetMissionCost(j, 0);}