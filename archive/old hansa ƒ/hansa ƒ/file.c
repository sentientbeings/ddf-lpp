/* This is the file module for the game Hanseatic League. It is responsible for all 		*//* processing of file menu items.										*/#include "file.h"#include "fileP.h"#include "transport.h"/* external procedures *//* go process a menu item */Boolean DoFile(int item){	SFTypeList	myTypes;	Point 	SFGwhere;	int refNum;	SetPt(&SFGwhere, 90, 82);	switch (item) {	case fmNew:		if (tryToSaveOldGame(false)) { 			CloseProductionWindows(true);			CloseTradeWindow(true);			processNewGameInfo();			SetCurrentPlayer(GetFirstActivePlayer());			if ((GetMapsChoice() == historical) || (GetMapsChoice() == fantasy)) {				myTypes[0]='HNSH';				SFGetFile( SFGwhere, "\p", 0L, 1, myTypes, 0L, &reply );				if (reply.good) {					SetVol(nullString, reply.vRefNum);					refNum = OpenResFile(reply.fName);					restoreGame(false);					CloseResFile(refNum);					findStartingCities();					gameInProgress = true;				}			} else if (GetMapsChoice() == random) {				InitCityNameObject();				InitRiverTable();				InitTerrainTable();				CreateCityInfoObject();				InitCoastTable();				BuildWorld();				SetUpWindows();				findStartingCities(); 				gameInProgress = true;			}			if (GetPlayerStatus(GetCurrentPlayer()) == computer)				DoComputerTurn();		}		break;			case fmSaveAs: /* intentional fall-through to case fmSave */		theFileName[0] = 0;			case fmSave:			saveFile();		break;	case fmResume:		if (tryToSaveOldGame(true)) {			myTypes[0]='HNSA';			SFGetFile( SFGwhere, "\p", 0L, 1, myTypes, 0L, &reply );			if (reply.good) {				InitRiverTable();				InitTerrainTable();				SetVol("\p", reply.vRefNum);				refNum = OpenResFile(reply.fName);				restoreGame(true);				CloseResFile(refNum);				gameInProgress = true;				if (GetPlayerStatus(GetCurrentPlayer()) == computer)					DoComputerTurn();			}		}		break;			case fmEndTurn:		DoEndTurn();		break;			case fmQuit: 		if (tryToSaveOldGame(true))			ExitToShell();				}	DrawDisplayWindow();	return(true);}/* do start of game file processing: blank the current file name, and go process a startup	*//* from a player double-clicking on a map/saved game.										*/void DoStartUp(void){	short openOrPrint, numberOfFiles, refNum;	AppFile	theFile;	theFileName[0] = 0;	CountAppFiles(&openOrPrint, &numberOfFiles);	if ((numberOfFiles == 1) && (openOrPrint == appOpen)) {		GetAppFiles(1, &theFile);		SetVol("\p", theFile.vRefNum);		if (theFile.fType == 'HNSH') {			SetCurrentPlayer(GetFirstActivePlayer());			refNum = OpenResFile(theFile.fName);			restoreGame(false);			CloseResFile(refNum);			findStartingCities();			gameInProgress = true; 		} else if (theFile.fType == 'HNSA') {				InitRiverTable();				InitTerrainTable();				refNum = OpenResFile(theFile.fName);				restoreGame(true);				CloseResFile(refNum);				gameInProgress = true;				reply.vRefNum = theFile.vRefNum;				pStrCopy((char *)theFile.fName, (char *)theFileName);		}		ClrAppFiles(1);	}}Boolean IsGameInProgress(void){	return gameInProgress;}/* local procedures *//* make sure any current structures are freed up before reusing them. */void destroyGame(Boolean useSavedValues){	CloseProductionWindows(true);	CloseTradeWindow(true);	if (useSavedValues) {		DestroyMapType();  		DestroyTurnInfo(); 		DestroyPlayerInfo(); 	}  	DestroyCityData();  	DestroyTerrainInfo();	DestroyMapWindow();}short findFurthestCity(short city){	double testDistance, newDistance;	short	testCity, furthestCity;		testDistance = -1.0;	testCity = GetNumberOfCities();	while (--testCity >= 0) {		newDistance = GetTransportCosts(city, testCity, noGood);		if (newDistance >= testDistance) {			furthestCity = testCity;			testDistance = newDistance;		}	}	return furthestCity;}/* find closest city without the same production value */short findNearestNonmatchingCity(short city){	double testDistance, newDistance;	short	testCity, closestCity ;	Point p;	do {		testCity = FindNextCity(city);	} while ((GetLeague(testCity) != noLeague) || (productionMatches(city, testCity)));	InvertHex((p = GetLocation(city)).h, p.v);	InvertHex((p = GetLocation(testCity)).h, p.v);	testDistance = 200.0;	closestCity = noCity;	testCity = GetNumberOfCities();	while (--testCity >= 0)		if ((testCity != city) &&			(GetLeague(testCity) == noLeague) &&			(productionMatches(city, testCity) == FALSE) &&			((newDistance = GetTransportCosts( city, testCity, TypeOfTransport(city))) <= testDistance)) {			closestCity = testCity;			testDistance = newDistance;		}	return closestCity;	return testCity;}void findStartingCities(void){		short city1, city2, i; //, j;	enum goodTypes good;	CursHandle watch;	Boolean silkCityExists;		watch = GetCursor(watchCursor);	SetCursor(&(**watch));	for (city1 = 0; city1 < GetNumberOfCities(); city1++) {		SetLeague(city1, noLeague);		for (good = wheat; good < numberOfGoods; good++)			SetProduction(city1, good, 0);	}	DrawCities();	for (i = 1; i <= 4; i++)		if (GetPlayerStatus(i) != inactive) {			do {				while (GetLeague(city1 = (short) Randomize(GetNumberOfCities())) != noLeague)					;				city2 = findNearestNonmatchingCity(city1);			} while (city2 == noCity);			SetLeague(city1, i);			SetLeague(city2, i);/*			GetTransportCosts(city1, city2, noGood);			GetTransportCosts(city2, city1, noGood);			for (j = 0; j < maxNumberOfCities; j++) {				if (j != city1) {					SetTransportValue(city1, j, 5000);					SetTransportValue(j, city1, 5000);				}				if (j != city2) {					SetTransportValue(city2, j, 5000);					SetTransportValue(j, city2, 5000);				}			} */		}	silkCityExists = false;	for (city1 = 0; city1 < GetNumberOfCities(); city1++)		if (GetSilkProductionCost(city1) == 4) {			silkCityExists = true;			break;		}	if (!silkCityExists)		SetSilkProductionCost(Randomize(GetNumberOfCities()), 4);	InitCursor();}/* check to see if 2 cities have the similar production values */Boolean productionMatches(short city1, short city2){	int returnVal;		returnVal = 0;	returnVal += abs(GetProductionCost(city1, wheat) - GetProductionCost(city2, wheat));	returnVal += abs(GetProductionCost(city1, fish) - GetProductionCost(city2, fish));	returnVal += abs(GetProductionCost(city1, iron) - GetProductionCost(city2, iron));	returnVal += abs(GetProductionCost(city1, silk) - GetProductionCost(city2, silk));	return (returnVal < 2);}void processNewGameInfo(void){	DialogPtr dP;	Handle itemH;	short item, league, type;	Rect cRect;		dP = GetNewDialog(NEW_GAME_INFO, 0L, (WindowPtr)-1L);	for (league = 1; league <= 4; league++) {		GetDItem(dP, firstLeagueButton[league]+GetPlayerStatus(league), &type, &itemH, &cRect);		SetCtlValue((ControlHandle) itemH, 1);	} 	GetDItem(dP, MAP_BUTTON_HISTORICAL+GetMapsChoice(), &type, &itemH, &cRect);	SetCtlValue((ControlHandle) itemH, 1);	for (ModalDialog(0L, &item); item != 1; ModalDialog(0L, &item))	switch (item) {		case LEAGUE1_HUMAN:		setPlayerInfo(dP, 1, human);		break;		case LEAGUE1_COMPUTER:		setPlayerInfo(dP, 1, computer);		break;			case LEAGUE1_INACTIVE:		setPlayerInfo(dP, 1, inactive);		break;			case LEAGUE2_HUMAN:		setPlayerInfo(dP, 2, human);		break;		case LEAGUE2_COMPUTER:		setPlayerInfo(dP, 2, computer);		break;			case LEAGUE2_INACTIVE:		setPlayerInfo(dP, 2, inactive);		break;			case LEAGUE3_HUMAN:		setPlayerInfo(dP, 3, human);		break;		case LEAGUE3_COMPUTER:		setPlayerInfo(dP, 3, computer);		break;			case LEAGUE3_INACTIVE:		setPlayerInfo(dP, 3, inactive);		break;			case LEAGUE4_HUMAN:		setPlayerInfo(dP, 4, human);		break;		case LEAGUE4_COMPUTER:		setPlayerInfo(dP, 4, computer);		break;			case LEAGUE4_INACTIVE:		setPlayerInfo(dP, 4, inactive);		break;			case MAP_BUTTON_HISTORICAL:		setMapInfo(dP, historical);		break;			case MAP_BUTTON_FANTASY:		SysBeep(1);		break;			case MAP_BUTTON_RANDOM:		setMapInfo(dP, random);		break;			case LEARNING_MODE:		GetDItem(dP, LEARNING_MODE, &type, &itemH, &cRect);		SetCtlValue((ControlHandle) itemH, ToggleLearningMode());		break;	}	DisposDialog(dP);}void restoreGame(Boolean useSavedValues){	if (useSavedValues) { 		RestoreMapType();  		RestoreTurnInfo(); 		RestorePlayerInfo(); 	} else{ 		SetCurrentPlayer(1); 	}  	RestoreCityData();  	RestoreTerrainInfo(); 	RestoreCoastInfo(); 	SetUpWindows();}Boolean saveFile(void){	int refNum; //, numberOfEntries; //, i;	Point	SFPwhere;		if (theFileName[0]==0) {		SetPt(&SFPwhere, 106, 104);		SFPutFile(SFPwhere, "\p", "\pSaved Game", 0L, &reply);		if (reply.good) 			pStrCopy((char *)reply.fName, (char *)theFileName);		else return false;	}	FSDelete(reply.fName, reply.vRefNum);	FlushVol("\p", reply.vRefNum);	Create(reply.fName, reply.vRefNum, 'HANS', 'HNSA');	CreateResFile(reply.fName);	if ((refNum = OpenResFile(reply.fName)) != -1) {		saveGame(); 		CloseResFile(refNum); 		FlushVol("\p", reply.vRefNum);		return true;	} else {		printf("SaveFile error creating file %s", reply.fName);		return false;	}}void saveGame(void){	SaveMapType();	SaveTurnInfo();	SaveCityInfo(); 	SavePlayerInfo();	SaveTerrainInfo();	SaveCoastInfo();	SaveMapWindow(); }void setMapInfo(DialogPtr dP, enum mapType newType){	ControlHandle	itemH;	short			type;	enum mapType	i;	Rect 			cRect;		SetMapsChoice(newType);	for (i = historical; i <= random; i++) {		GetDItem(dP, MAP_BUTTON_HISTORICAL+i, &type, (Handle *) &itemH, &cRect);		if (i == newType)			SetCtlValue(itemH, 1);		else if (GetCtlValue(itemH) != 0)			SetCtlValue(itemH, 0);	}}void setPlayerInfo(DialogPtr dP, short league, enum playerType status){	ControlHandle itemH;	short type;	enum playerType i;	Rect cRect;		SetPlayerStatus(league, status);	for (i = human; i <= inactive; i++) {		GetDItem(dP, firstLeagueButton[league]+i, &type, (Handle *) &itemH, &cRect);		if (i == status)			SetCtlValue(itemH, 1);		else if (GetCtlValue(itemH) != 0)			SetCtlValue(itemH, 0);	}}Boolean tryToSaveOldGame(Boolean useSavedValues){	if (gameInProgress == true) {		switch (CautionAlert(tryToSaveAlert, 0L)) {				case yesButton:			if (saveFile()) {				destroyGame(useSavedValues);				return true;			} else return false;					case noButton:			destroyGame(useSavedValues);			return true;					case cancelButton:			return false;				}	} 	return true;}