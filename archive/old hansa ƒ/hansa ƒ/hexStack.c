/* this does the code for a hex stack */#include "hexStack.h"#include "hexStackP.h"#include "city.h"#include "cityIndexObject.h"#include "cityInfoObject.h"#include "map.h"#include "transport.h"static Point errHex = {-1, -1 };void AdjustTransportCosts(){	short city1, city2;		city1 = GetCityIndex(hexStack[0]);	city2 = GetCityIndex(GetTopHex());	if ((city1 != noCity) && (city2 != noCity)  &&		(GetStackCost() < GetTransportCosts(city1, city2, noGood))) {		SetTransportValue(city1, city2, GetStackCost());		SetTransportValue(city2, city1, GetReverseCost());	}}short CopyHexStack(Point stack[]){	short i;		for (i = 0; i <= top; i++)		stack[i] = hexStack[i];	return top;}Point GetLastHex(){	return ((top > 0) ? hexStack[top-1] : errHex);}Point GetTopHex(){	return ((top >= 0) ? hexStack[top] : errHex);}void InitHexStack(){	top = -1;}void InvertHexStack(){	short currentHex;		for (currentHex = top; currentHex != -1; currentHex--)		InvertHex(hexStack[currentHex].h, hexStack[currentHex].v);}void InvertTopHex(){	InvertHex(hexStack[top].h, hexStack[top].v);}Boolean PopHex(){	if (--top < -1)		top = -1;	return (top >= -1);}Boolean PushHex(Point p){	if (++top == hexStackSize) {		top--;		return false;	} else {		hexStack[top] = p;		setStackCost();		return true;	}}short GetStackCost(){	return stackCost[top-1];}short GetReverseCost(){	return reverseCost[top-1];}void setStackCost(){	if ((top == 0) || (top == 1)){		stackCost[top] = 0;		reverseCost[top] = 0;	}	else {		stackCost[top] = stackCost[top - 1] + GetAdjacentHexCost(hexStack[top-1], hexStack[top]);		reverseCost[top] = reverseCost[top-1] + GetAdjacentHexCost(hexStack[top], hexStack[top-1]);	if (stackCost[top] > 5000)		stackCost[top] = 5000;	if (reverseCost[top] > 5000)		reverseCost[top] = 5000;	}}/* search for a location hex in something other than top. If you find it, uninvert	the rest of the stack and set a new top */	Boolean TrimHexStack(Point loc){	short i;		for (i = 0; i < top; i++)		if (EqualPt(loc, hexStack[i])) { // we found an early match			while (top != i) {				InvertTopHex();				PopHex();			}			return true;		}	return false;}