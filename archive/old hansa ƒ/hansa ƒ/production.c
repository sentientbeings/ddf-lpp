/* this file contains the code pertaining to production windows for the	*//* game hanse.															*/#include "production.h"#include "productionP.h"/* PUBLIC CODE *//* close a city's production window */void CloseProductionWindow(short city){	if (productionPtr[city] != NULL) {		DisposDialog(productionPtr[city]);		productionPtr[city] = NULL;	}}void CloseProductionWindows(Boolean player){	short i;		for (i = 0; i < maxNumberOfCities; i++)		if ((productionPtr[i] != NULL) &&			(player || (GetLeague(i) != GetCurrentPlayer()))) 			CloseProductionWindow(i);}/* what is the current production city? */short GetProductionCity(void){	return productionCity;}/* see if ptr matches any open production window, if so, make it current */short MatchProductionWindow(WindowPtr w){	register int i;		i = maxNumberOfCities;	while (--i >= 0)		if (productionPtr[i] == w) {			SetProductionCity(i);			return i;		}	return noCity;}/* what we have to do when an event occurs in a dialog box *//* This is a bit tricky: DialogSelect calls TrackControl directly, so *//* moving around the control thumb may already have been done. It works *//* like this: 1) if we're in inDownButton, add 1 to production if you *//* can; if we're in inUpButton, subtract 1; 2) if the thumb hasn't been *//* moved (control value = production - exports) we want to increment by *//* 5 if we are in inPageDown, decrement by 5 if we are in inPageUp; *//* remember, up is left); 3) if the thumb has been moved, for some 		*//* reason I don't understand, inPageDown and inPageUp get reversed. My	*//* guess is that the original point is now in that area, rather than the *//* current point. Anyway, you have to increment by the difference 		*//* inPageUp, and decrement inPageDown). All this presumes you have the	*//* requisite labor or good to play with. If you don't, change by the max*/void ProcessProductionEvent(EventRecord *eventP, DialogPtr dialogP, int item){	ControlHandle 	goodH;	short 			type;	Rect 			drawRect;	short 			attempt, city;	if (item == ZeroTradeProductionItem)		ZeroTrade(GetProductionCity());	else {		GetDItem(dialogP, item, &type, (Handle *) &goodH, &drawRect);		if (type == (ctrlItem+resCtrl)) {			GlobalToLocal(&(eventP->where)); 			switch (TrackControl(goodH, eventP->where, 0L)) {					case inDownButton:			if (LaborAvailable((city = GetProductionCity()) >= (100 *GetProductionCost(city, getGoodType[item]))))				changeProductionValue(item, 1);			break;					case inUpButton:			if (GetCtlValue(goodH) > GetCtlMin(goodH))				changeProductionValue(item, -1);			break;					case inPageDown:			if (GetCtlValue(goodH) != getProductionMinusExports(city = GetProductionCity(), getGoodType[item]))				changeProductionValue(item, GetCtlValue(goodH) - getProductionMinusExports(city, getGoodType[item]));			else if (LaborAvailable(city) >= (500 * GetProductionCost(city, getGoodType[item])))				changeProductionValue(item, 5);			else changeProductionValue(item, LaborAvailable(city) / (100 * GetProductionCost(city, getGoodType[item])));			break;					case inPageUp:			if (GetCtlValue(goodH) != getProductionMinusExports(city = GetProductionCity(), getGoodType[item])) {				attempt = GetCtlValue(goodH) - getProductionMinusExports(city, getGoodType[item]);				if (LaborAvailable(city) >= (attempt * 100) * GetProductionCost(city, (enum goodTypes) item))					changeProductionValue(item, attempt);				else changeProductionValue(item, LaborAvailable(city) / (100 * GetProductionCost(city, (enum goodTypes) item)));			} else if (GetCtlValue(goodH) >= 5)				changeProductionValue(item, -5);			else changeProductionValue(item, -GetCtlValue(goodH));			break;		case inThumb:			if (GetCtlValue(goodH) < getProductionMinusExports(city = GetProductionCity(), getGoodType[item]))				changeProductionValue(item, GetCtlValue(goodH) - getProductionMinusExports(city, getGoodType[item]));			else if (GetCtlValue(goodH) > getProductionMinusExports(city, getGoodType[item])) {				attempt = GetCtlValue(goodH) - getProductionMinusExports(city, getGoodType[item]);				if (LaborAvailable(city) >= (attempt * 100) * GetProductionCost(city, (enum goodTypes) item))					changeProductionValue(item, attempt);				else changeProductionValue(item, LaborAvailable(city) / (100 * GetProductionCost(city, (enum goodTypes) item)));			}			break;							} 		}	}	ShowProductionWindow(GetProductionCity(), false); 	UpdateTradeWindow();}/* set production city */void SetProductionCity(short city){	productionCity = city;}void ShowProductionWindow(short city, Boolean select){	Boolean					isComputerPlayer;	ControlHandle 			goodH;	register enum goodTypes	good;	short 					type, items;	Rect 					invalRect;	Str255					productionString, testString;	SetProductionCity(city);	isComputerPlayer = (GetPlayerStatus(GetLeague(city)) == computer);	if (productionPtr[city] == NULL)		openProductionWindow();	else SetPort(productionPtr[city]);	for (good = wheat; good < numberOfGoods; good++) {		GetDItem(productionPtr[city], productionScrollBar[good], &type, (Handle *) &goodH, &invalRect);		if (((items = getProductionMinusExports(city, good)) != GetCtlValue(goodH)) && !isComputerPlayer)			SetCtlValue(goodH, items);		GetProductionTradeString((char *)productionString, city, good);		GetDItem(productionPtr[city], productionAmountItem[good], &type, (Handle *) &goodH, &invalRect);		GetIText((Handle) goodH, testString);		if (!EqualString(productionString, testString, true, true))			SetIText((Handle) goodH, productionString);	}	DrawUtilityBar(productionPtr[city], utilityBarItem, utilityAmountItem);	DrawLaborBar(productionPtr[city], laborBarItem, laborAvailableItem, false);		if (select)		SelectWindow(productionPtr[city]);}void UpdateProductionWindows(short city1, short city2){	if (productionPtr[city1] != NULL)		ShowProductionWindow(city1, false);	if (productionPtr[city2] != NULL)		ShowProductionWindow(city2, false);}/* zero out all trade between this city and all others */void ZeroTrade(short city){	register short city1, amount;	register enum goodTypes good;		city1 = GetNumberOfCities();	while (--city1 >= 0) {		good = numberOfGoods;		while (--good >= wheat) {			if ((amount = GetImport(city, city1, good)) != 0)				ChangeImportExport(city, city1, good, amount);			if ((amount = GetExport(city, city1, good)) != 0)				ChangeImportExport(city, city1, good, -amount);		}		FixTradeDeficit(city1);	}}/* private procedures */Boolean changeProductionValue(int item, short amount){	register short 	city;	enum goodTypes 	good;	if ((GetProductionCost((city = GetProductionCity()), good = getGoodType[item]) != 0) &&		(GetProduction(city, good) + amount >= 0) &&		(GetProduction(city, good) + amount + GetImportsExports(city, good) >= 0) && 		((long)(amount*100 * GetProductionCost(city, good)) <= (long) LaborAvailable(city))) {		SetProduction(city, good, GetProduction(city, good) + amount);		return true;	} else		return false;}pascal void drawProductionItems(DialogPtr dPtr, int itemNumber){		switch (itemNumber) {		case utilityBarItem:		DrawUtilityBar(dPtr, utilityBarItem, utilityAmountItem);		break;			case laborBarItem:		DrawLaborBar(dPtr, laborBarItem, laborAvailableItem, true);		break;			}}/* how much of the produced good stays here? */short getProductionMinusExports(short city, enum goodTypes good){	if (GetImportsExports(city, good) < 0)		return GetProduction(city, good) + GetImportsExports(city, good);	else return GetProduction(city, good);}void openProductionWindow(void){	Boolean 		isComputerPlayer;	register short	city;	Rect			drawRect;	ControlHandle	tempH;	short 			type;	enum goodTypes	i;	productionPtr[city = GetProductionCity()] = GetNewDialog(productionID, 0L, (WindowPtr)-1L);	isComputerPlayer = (GetPlayerStatus(GetLeague(city)) == computer);	SetWTitle(productionPtr[city], GetCityName(city));	GetDItem(productionPtr[city], utilityBarItem, &type, (Handle *) &tempH, &drawRect);	SetDItem(productionPtr[city], utilityBarItem, userItem, (Handle) &drawProductionItems, &drawRect);	GetDItem(productionPtr[city], laborBarItem, &type, (Handle *) &tempH, &drawRect);	SetDItem(productionPtr[city], laborBarItem, userItem, (Handle) &drawProductionItems, &drawRect);	for (i = wheat; i < numberOfGoods; i++) {		GetDItem(productionPtr[city], productionScrollBar[i], &type, (Handle *) &tempH, &drawRect);		if ((GetProductionCost(city, i) != 0) && !isComputerPlayer){			HiliteControl(tempH, 0);			SetCtlMax(tempH, (baseLabor/100)/GetProductionCost(city, i));			GetDItem(productionPtr[city], productionCostItem[i], &type, (Handle *) &tempH, &drawRect);			SetIText((Handle) tempH, costString[GetProductionCost(city, i)]);		} else			HiliteControl(tempH, 255);	}	ShowWindow(productionPtr[city]);}