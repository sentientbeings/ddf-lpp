/* this file contains the city information for the game Hanseatic League*//*												 						*/#include "city.h"#include "cityPrivate.h"/* public procedures *//* cancel all trade between 2 cities */void CancelTrade(short city1, short city2){	register enum goodTypes good;	register short amount;		good = numberOfGoods;	while (--good >= wheat) {		if ((amount = GetImport(city1, city2, good)) != 0) 			ChangeImportExport(city1, city2, good, amount);		if ((amount = GetExport(city1, city2, good)) != 0)			ChangeImportExport(city2, city1, good, amount);	}	FixTradeDeficit(city1);	FixTradeDeficit(city2);}/* import amount of good from city 1 to city 2 */void ChangeImportExport(short city1, short city2, enum goodTypes good, short amount){	SetTradeFlow(city1, city2, good, GetTradeFlow(city1, city2, good) + amount);	SetTradeFlow(city2, city1, good, GetTradeFlow(city2, city1, good) - amount);}/* go forth and put a city in this hex */void CreateCity(short row, short column){	Point p;	p.h = row;	p.v = column;	SetLocation(GetNumberOfCities(), p);	SetCityIndex(p, GetNumberOfCities());	IncrementNumberOfCities();}/* fix up any trade deficits we may find */void FixTradeDeficit(short city){	register enum goodTypes good;	register short deficit, city1;		good = numberOfGoods;	while (--good >= wheat) 		if ((deficit = GetItemTotal(city, good) * -1) > 0) {			city1 = GetNumberOfCities();			while ((--city1 >= 0) && (deficit > 0))				if (GetExport(city, city1, good) > 0) {					if (deficit > GetExport(city, city1, good)) {						ChangeImportExport(city, city1, good, -GetExport(city, city1, good));						deficit -= GetExport(city, city1, good);					} else {						ChangeImportExport(city, city1, good, -deficit);						deficit = 0;					}					FixTradeDeficit(city1);				}		}}/* what is the distance between 2 items? */double GetCityDistance(short city1, short city2){	short h, v;	Point p1, p2;		p1 = GetLocation(city1);	p2 = GetLocation(city2);		h = p1.h - p2.h;	v = p1.v - p2.v;	return sqrt((double) ((h*h)+(v*v)));}/* how much trade is going on in a particular good for a particular city? */short GetImportsExports(short city, enum goodTypes good){	register short testCity, total;		testCity = GetNumberOfCities();	total = 0;	while (--testCity >= 0)		total += GetImport(city, testCity, good)-GetExport(city, testCity, good);	return total;}/* total number of items pouring into or out of city */short GetItemTotal(short city, enum goodTypes good){	return GetProduction(city, good) + GetImportsExports(city, good);}/* how much does it cost to produce this good? */short GetProductionCost(short city,enum goodTypes good){	Point p;		if (good == silk)		return GetSilkProductionCost(city);	else {		p = GetLocation(city);		return productionCost[IsAdjacentTerrain(p.h, p.v, goodTerrain[good])];	}}/* what is the trade between 2 cities in a commodity? */short GetTradeBetweenCities(short city1, short city2, enum goodTypes good){	return GetImport(city1, city2, good) - GetExport(city1, city2, good);}/* what is the current utility of a city? */	float GetUtility(short city){	int tot;	enum goodTypes good;		tot = 1;	for (good = wheat; good < numberOfGoods; good++)		tot *= (GetItemTotal(city, good) + 1);	return pow(tot - 1.0, 1.0/numberOfGoods);}/* get the average utility over autarchy for a league */float GetUtilityOverAutarchy(short league){	short t;	float val, number;		for (t = 0, val = 0.0, number = 0.0; t < maxNumberOfCities; t++)		if (league == GetLeague(t)) {			val += GetUtility(t) - GetAutarchicLevel(t);			number++;		}	return val / number;}/* initialize city information */void InitCities(void){	register short i, j;	enum goodTypes k;	Point p;		CreateCityIndex();	SetNumberOfCities(0);	i = maxNumberOfCities; 	while (--i >= 0) {		p.h = -1; p.v = -1;		SetLocation(i, p);		k = numberOfGoods;		while (--k >= wheat) {			SetProduction(i, k, 0);			j = maxNumberOfCities; /* reuse column for speed */			while (--j >= 0) {				SetTradeFlow(i, j, k, 0);			}		}		SetLeague(i, noLeague);		SetMissionCost(i, 0);		SetSilkProductionCost(i, 0);	}}/* is there a city next to this hex? */Boolean IsAdjacentCity(short row, short column){	register enum direction compass;		compass = northwestPlus;	while (--compass >= north)		if (IsCityHere(row, column, compass) == true)			return true;	return false;}/* is there a city in this hex? */Boolean IsCityHere(short row, short column, enum direction dir){	register Point t;		t = GetHexCoordinates(row, column, dir);	if (HexLegal(t))		return (GetCityIndex(t) != -1) ? true : false;	else return false;}/* how much unused labor does a city have? *//* how many cities are in a league? */short NumberOfCitiesInLeague(short league){	short answer, i;		answer = 0;	for (i = 0; i < GetNumberOfCities(); i++)		if (GetLeague(i) == league)			answer++;	return answer;}/* has an offer been made for a city this turn? */void DestroyCityData(void){	DestroyCityNameObject();	DestroyCityInfoObject();	DestroyCityIndexObject();}void RestoreCityData(void){	InitCityNameObject();		RestoreCityInfoObject();	RestoreCityIndexObject();}void SaveCityInfo(void){	SaveCityInfoObject(); 	SaveCityNameObject();	SaveCityIndexObject(); }/* write city name info *//* do final city initializations *//* private code to this module *//* find the furthest city from a given city *//* how much labor is used producing goods? */unsigned short GetLaborUsed(short city){	register short labor;	register enum goodTypes good;		labor = 0;	good = numberOfGoods;	while (--good >= wheat)		labor += (GetProductionCost(city, good) * GetProduction(city, good)*100);	return labor;}