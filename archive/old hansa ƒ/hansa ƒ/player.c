/* this module deals with adding a player to the current game pool 		*/#include "player.h"#include "playerP.h"#include "globals.h"#include "utilities.h"short AddPlayer(enum playerType type){	short i;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	for (i = 1; i <= maxNumberOfPlayers; i++)		if (leagueStatus[i] == inactive) {			leagueStatus[i] = type;			return i;		}	return noPlayer;}void DestroyPlayerInfo(void){	DisposHandle(currentPlayerH);	DisposHandle(leagueStatusH);}void DropPlayer(short league){	short i;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;		for (i = 0; i < GetNumberOfCities(); i++) {		DeleteAnOffer(i, league);		if (GetLeague(i) == league) {			ZeroTrade(i);			SetLeague(i, noLeague);			SetMissionCost(i, 0);		}	}	leagueStatus[league] = inactive;}short GetCurrentPlayer(void){	short *p;		p = (short *) *currentPlayerH;	return *p;}short GetFirstActivePlayer(void){	short i;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	for (i = 1; i <= maxNumberOfPlayers; i++)		if (leagueStatus[i]!= inactive)			return i;	return playerError;}short GetLastActivePlayer(void){	short i;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	for (i = maxNumberOfPlayers; i >= 1; i--)		if (leagueStatus[i] != inactive)			return i;	return playerError;}short GetNextActivePlayer(short which){	short i;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	if (which == GetLastActivePlayer())		return GetFirstActivePlayer();	for (i = which+1; i <= maxNumberOfPlayers; i++)		if (leagueStatus[i] != inactive)			return i;	return playerError;}short GetNumberOfPlayers(void){	short i, number;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	number = 0;		for (i = 1; i <= maxNumberOfPlayers; i++)		if (leagueStatus[i] != inactive)			number++;	return number;}short GetNumberOfHumanPlayers(void){	short i, number;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	number = 0;		for (i = 1; i <= maxNumberOfPlayers; i++)		if (leagueStatus[i] == human)			number++;	return number;}enum playerType GetPlayerStatus(short league){	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	return leagueStatus[league];}void InitPlayerInfo(void){	short i, *p;		enum playerType *leagueStatus;		currentPlayerH = NewHandle(sizeof(short));	p = (short *) *currentPlayerH;	*p = 1;	leagueStatusH = NewHandle(sizeof(enum playerType) * (maxNumberOfPlayers+1));	leagueStatus = (enum playerType *) *leagueStatusH;	for (i = 1; i <=maxNumberOfPlayers; i++)		leagueStatus[i] = inactive;}void RestorePlayerInfo(void){	currentPlayerH = GetNamedResource('TABL', "\pnumber of players");	DetachResource(currentPlayerH);	leagueStatusH = GetNamedResource('TABL', "\pleague status");	DetachResource(leagueStatusH);}void SavePlayerInfo(void){		AddResource(currentPlayerH, 'TABL', UniqueID('TABL'), "\pnumber of players");	WriteResource(currentPlayerH);	DetachResource(currentPlayerH);	AddResource(leagueStatusH, 'TABL', UniqueID('TABL'), "\pleague status");	WriteResource(leagueStatusH);	DetachResource(leagueStatusH);}Boolean SetCurrentPlayer(short player){	short *p;	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	if (leagueStatus[player] != inactive) {		p = (short *) *currentPlayerH;		*p = player;		return true;	} else return false;}void SetPlayerStatus(short league, enum playerType status){	enum playerType *leagueStatus;		leagueStatus = (enum playerType *) *leagueStatusH;	leagueStatus[league] = status;}short GetNextCity(short league, short city){	short i;		for (i = city + 1; i < maxNumberOfCities; i++)		if (GetLeague(i) == league)			return i;	return maxNumberOfCities;}