/* this is the file for doing animation of trade paths in Hansa */#include "animation.h"#include "animationP.h"#define kSpriteIcon 128#define kWaterIcon  130#define leftOffset 7#define rightOffset 8void InitAnimation(){	spriteIcon[0] = GetCIcon(kSpriteIcon);	spriteIcon[1] = GetCIcon(kWaterIcon);}/* now go add in an animation path currently sitting on the stack */void AddAnimationPath(short fromCity, short toCity){	struct pathRecord *newPathP;		if ((newPathP = doesPathExist(fromCity, toCity)) != NULL)		updatePath(newPathP);	else {		newPathP = createPathRecord(fromCity, toCity);		attachPathToList(newPathP);	}}/* does an animation path already exist for these two cities? */struct pathRecord *doesPathExist(short fromCity, short toCity){	struct pathRecord *tempP;		for (tempP = firstPathP; tempP != NULL; tempP = tempP->nextP) // run through the list		if ((tempP->fromCity == fromCity) && (tempP->toCity == toCity)) // do we have a match?			break;	return tempP; // return the match or NULL if we reached the end}void updatePath(struct pathRecord *pathP){	pathP->top = CopyHexStack(pathP->stack);}struct pathRecord *createPathRecord(short fromCity, short toCity){	struct pathRecord *pathP;		pathP = (struct pathRecord *) NewPtr(sizeof(struct pathRecord));	pathP->fromCity = fromCity;	pathP->toCity = toCity;	pathP->top = CopyHexStack(pathP->stack);	pathP->nextP = NULL;	return pathP;}void attachPathToList(struct pathRecord *pathP){	if (firstPathP != NULL) { // the list exists, go put our widget on the end		lastPathP->nextP = pathP; // attach it to the end		lastPathP = pathP; // notice that this is the new end	} else // go put it at the start		firstPathP = lastPathP = pathP;}/* Update animation gets called once every cycle.									*//*																					*//* if this is the start of an animation cycle (first call after the user has 		*//* chosen production or consumption view, it initializes the start location for 	*//* all cities and then plots the appropriate trade route icon.						*//* if it is in the middle of an animation, it calculates where the next plot has 	*//* to be, replaces the current plot, and draws the new one.							*//* if it is at the end of an animation, it replaces the last animation with the map *//* and frees up all the memory used in the list of cities.							*//*																					*//* data structures:																	*//*																					*//* we keep a linked list representing all the trade routes and where they currently *//* are in the animation. When we get to the end, we start over again				*/void UpdateAnimation(){	enum viewMode 	currentViewMode;	CWindowPtr		savePort;			if (!IsGameInProgress())		return;		GetPort((GrafPtr *) &savePort);	SetPort((GrafPtr) GetMapWindow());/* first, return most of the time *//* situation 1: no animation is wanted or in progress */	if (((currentViewMode = GetViewMode()) != productionView) && (currentViewMode != consumptionView) &&		(lastViewMode != productionView) && (lastViewMode != consumptionView))		;		/* situation 2: an animation is in progress and not wanted */	else if ((currentViewMode != productionView) && (currentViewMode != consumptionView))		killAnimation();		/* situation 3: we don't have an animation, but want one */	else if ((lastViewMode != consumptionView) && (lastViewMode != productionView))		createAnimation(); 			/* situation 4: we've just switched goods that we're looking at */	else if (GetCurrentView() != lastGood) {		killAnimation();		createAnimation();	}/* situation 5: we've just switched between production and consumption modes */	else if (lastViewMode != currentViewMode) {		killAnimation();		createAnimation();	}	/* last situation: we want to continue the animation */	else 		continueAnimation();		lastViewMode = currentViewMode;	lastGood = GetCurrentView();	SetPort((GrafPtr) savePort);}/* we've just switched to a view that needs some animation. What we have to do is:	*//*																					*//* 1) create a linked list of all the cities that need produce/consume (pick the 	*//*    right one) the current good.													*//* 2) for each of those cities, make a list of the hexes we have to traverse.		*//* 3) for each of the cities in the list, save the start point as the current point *//*    and point at the first hex as the place we have to go next					*//* (1, 2, 3 all get collapsed into 1 loop.)											*//* 4) for each city in the list, draw the initial sprite.							*/void createAnimation(){	short thisCity, targetCity;		if (GetCurrentView() == noGood)		return;	DrawCities();	SaveToOffscreenMap();	for (thisCity = 0; thisCity < maxNumberOfCities; thisCity++)			for (targetCity = 0; targetCity < maxNumberOfCities; targetCity++)				if ((GetLeague(targetCity) == GetCurrentPlayer()) &&					(((GetViewMode() == productionView) && (GetExport(thisCity, targetCity, GetCurrentView()) > 0)) ||					 ((GetViewMode() == consumptionView) && (GetImport(targetCity, thisCity, GetCurrentView()) >0))))					createSpriteRecord(thisCity, targetCity);						drawSprites();}void continueAnimation(){	struct spriteRecord *p;	Rect				spriteRect;	Point				l;		if (--timer != 0)		return;	timer = 10; 	p = firstSpriteP;	while (p != NULL) {		l = p->currentLocation;		SetRect(&spriteRect, l.h-leftOffset, l.v-leftOffset, l.h+rightOffset, l.v+rightOffset);		if (EqualPt(p->currentLocation, p->finalLocation)) {			p->currentLocation = p->startLocation;			p->nextHex = 1;			p->nextLocation = GetCenterPt1(p->pathP->stack[1]);		}		else if (EqualPt(p->currentLocation, p->nextLocation))			p->nextLocation = GetCenterPt1(p->pathP->stack[++(p->nextHex)]);		else {			if (p->currentLocation.h < p->nextLocation.h)				p->currentLocation.h++;			else if (p->currentLocation.h > p->nextLocation.h)				p->currentLocation.h--;			if (p->currentLocation.v < p->nextLocation.v)				p->currentLocation.v++;			else if (p->currentLocation.v > p->nextLocation.v)				p->currentLocation.v--;		}		CopyOffscreenMap(&spriteRect);		drawOneSprite(p);		p = p->nextP;	}}void drawSprites(){	struct spriteRecord	*currentSpriteP;		currentSpriteP = firstSpriteP;	while (currentSpriteP != NULL) {		drawOneSprite(currentSpriteP);		currentSpriteP = currentSpriteP->nextP;	}}void drawOneSprite(struct spriteRecord *spriteP){	Point				p;	Rect				spriteRect;	p = spriteP->currentLocation;	SetRect(&spriteRect, p.h-leftOffset, p.v-leftOffset, p.h+rightOffset, p.v+rightOffset);	PlotCIcon(&spriteRect, spriteIcon[(IsWaterHere(p)) ? 1 : 0]);}/* we've got to recursively kill all the sprite records */void killAnimation(){	if (firstSpriteP != NULL) { // make sure we're addressing something 		killSpriteRecord(firstSpriteP);		firstSpriteP = NULL;	}	CopyOffscreenMap(&(GetMapWindow()->portRect));}void killSpriteRecord(struct spriteRecord *killP){	if (killP->nextP != NULL)		killSpriteRecord(killP->nextP);	DisposPtr((char *) killP);}/* go and make a sprite record, and attach it to the list */void createSpriteRecord(short fromCity, short toCity){	struct spriteRecord *tP;		tP = (struct spriteRecord *) NewPtr(sizeof(struct spriteRecord));	tP->nextP = NULL;	tP->pathP = doesPathExist(fromCity, toCity);	tP->startLocation = tP->currentLocation = GetCenterPt1(tP->pathP->stack[0]);	tP->nextLocation = GetCenterPt1(tP->pathP->stack[1]);	tP->nextHex = 1;	tP->finalLocation = GetCenterPt1(tP->pathP->stack[tP->pathP->top]);	if (firstSpriteP == NULL) {		firstSpriteP = tP;		lastSpriteP = tP;	}	else {		lastSpriteP->nextP = tP;		lastSpriteP = tP;	}}