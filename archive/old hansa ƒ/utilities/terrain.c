/* This file contains the code dealing with terrain for the game 		*//* Hanseatic League. It has the primitive functions for terrain, rivers,*//* and coasts.															*/#include "terrain.h"#include "terrainP.h"#include "utilities.h"/* PUBLIC PROCEDURES */void FillInCoast(row, column)short row, column;{	enum direction inDir, outDir, dir;	Point p;	SetPt(&p, row, column);	if (HexLegal(p) &&		(GetTerrainType(row, column, same) != ocean) &&		(GetCoastType(row, column, same) == noCoast) && 		(IsAdjacentTerrain(row, column, ocean) > 0)) {		for (dir = north; dir <= northwest; dir++)			if (GetTerrainType(row, column, dir) == ocean) {				if (GetTerrainType(row, column, inDir = GetClockwise(dir)) != ocean)					SetCoastType(p, GetCoastType(row, column, same) | DirectionToInMask(inDir));				if (GetTerrainType(row, column, outDir = GetWiddershins(dir)) != ocean)					SetCoastType(p, GetCoastType(row, column, same) | DirectionToOutMask(outDir));			} 		if (NumberOfBits(GetCoastType(row, column, same)) == 1)			SetCoastType(p, noCoast);	} }							unsigned GetCoastType(row, column, dir)short row, column;enum direction dir;{	Point p;		p = GetHexCoordinates(row, column, dir);	if (HexLegal(p))		return (coast[p.h][p.v]);	else return noCoast;}/* what is the hex coordinates of a hex next to a known hex ? */Point GetHexCoordinates(row, column, dir)short row, column;enum direction dir;{	Point loc;		switch (dir) {		case same:		loc.h = row;		loc.v = column;		break;			case north:		loc.h = row;		loc.v = column-1;		break;			case northeast:		loc.h = row+1;		loc.v = column - ((row+1) % 2);		break;			case southeast:		loc.h = row+1;		loc.v = column - ((row+1) % 2) + 1;		break;			case south:		loc.h = row;		loc.v = column+1;		break;			case southwest:		loc.h = row-1;		loc.v = column - ((row+1) % 2) +1;		break;			case northwest:		loc.h = row-1;		loc.v = column - ((row+1) % 2);		break;	}	return loc;}/* what is the river type in the passed hex? */unsigned GetRiverType(row, column, dir)short row, column;enum direction dir;{	Point t;	unsigned *river;		if (dir == same) {		if ((row < 0) || (row >= rowSize) || (column < 0) || (column >= columnSize))			return 0;		else {			river = (unsigned *) *riverH;			return *(river+row*columnSize+column);		}	} else {		t = GetHexCoordinates(row, column, dir);		return GetRiverType(t.h, t.v, same);	}}		/* what is the terrain type of this hex? */	enum terrainType GetTerrainType(row, column, dir)short row, column;enum direction dir;{	Point t;	enum terrainType *terrain;		if (dir == same) {			if ((row < 0) || (row >= rowSize) || (column < 0) || (column >= columnSize))			return noTerrainType;		else {			terrain = (enum terrainType *) *terrainH;			return *(terrain+row*columnSize+column);		}	} else {		t = GetHexCoordinates(row, column, dir);		return GetTerrainType(t.h, t.v, same);	}		}void InitCoastTable(){	int i, j;	Point p;		for (i = 0; i < rowSize; i++)		for (j = 0; j < columnSize; j++) {			SetPt(&p, i, j);			SetCoastType(p, noCoast);		}}void InitRiverTable(){	riverH = NewHandle(rowSize*columnSize*sizeof(unsigned));}void InitTerrainTable(){	terrainH = NewHandle(rowSize*columnSize*sizeof(enum terrainType));}/* is there an a hex adjacent to this one with the passed type? If so, how many? */short IsAdjacentTerrain(row, column, type)short row, column;enum terrainType type;{	register enum direction compass;	register short answer;		answer = 0;	compass = northwestPlus;	while (--compass >= north) {		if (GetTerrainType(row, column, compass) == type)			answer++;		if ((type == ocean) && (GetCoastType(row, column, same) != noCoast) &&			(GetCoastType(row, column, compass) != noCoast))			answer++;	}	return answer;}// is the point near the last hex we found?Point GetHex(Point p){	Point base, retVal = {-1, -1}, testVal;	enum direction i;		if (PointInHex(p, base = GetTopHex()))		retVal = base;	 else		for (i = north; i < northwestPlus; i++)			if ((HexLegal(testVal = GetHexCoordinates(base.h, base.v, i))) &&				(PointInHex(p, testVal))) {				retVal = testVal;				break;			}	return retVal;}// is there ocean, coast or river here?Boolean IsWaterHere(Point p){	Point loc = GetHex(p);	return ((GetTerrainType(loc.h, loc.v, same) == ocean) ||			(GetRiverType(loc.h, loc.v, same) != noRiver) ||			(GetCoastType(loc.h, loc.v, same) != noCoast));}void RestoreCoastInfo(){/*	if ((coastH = GetNamedResource('TABL', "\pcoast")) != 0L) {		DetachResource(coastH);	} else InitCoastTable(); */}void DestroyTerrainInfo(){	DisposHandle(terrainH);	DisposHandle(riverH);}void RestoreTerrainInfo(){	terrainH = GetNamedResource('TABL', "\pterrain");	DetachResource(terrainH);	riverH = GetNamedResource('TABL', "\priver");	DetachResource(riverH);}void SaveCoastInfo(){/*	AddResource(coastH, 'TABL', UniqueID('TABL'), "\pcoast");	WriteResource(coastH);	DetachResource(coastH); */}void SaveTerrainInfo(){	unsigned t[rowSize][columnSize];		AddResource(terrainH, 'TABL', UniqueID('TABL'), "\pterrain");	WriteResource(terrainH);	DetachResource(terrainH);	AddResource(riverH, 'TABL', UniqueID('TABL'), "\priver");	WriteResource(riverH);	DetachResource(riverH);		}void SetCoastType(hex, type)Point hex;unsigned type;{	coast[hex.h][hex.v] = type;}void SetRiverType(row, column, dir, type)short row, column;enum direction dir;unsigned type;{	Point t;	unsigned *river;			river = (unsigned *) *riverH;	t = GetHexCoordinates(row, column, dir);	*(river+t.h*columnSize+t.v) = type;}/* assign terrain to hex */void SetTerrainType(row, column, dir, type)short row, column;enum direction dir;enum terrainType type;{	enum terrainType *terrain;	Point t;	t = GetHexCoordinates(row, column, dir);	terrain = *terrainH;	*(terrain+t.h*columnSize+t.v) = type;	}