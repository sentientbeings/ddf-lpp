/* this file contains all the map window stuff 							*/#include "map.h"#include "mapP.h"#include "globals.h"#include <QDOffscreen.h>#include <stdio.h>/* what I want to do is this: create a base map in an off-screen graphics device, and *//* bring that map onto the screen. That keeps a base copy around for doing all my     *//* restore operations.																  */static PixPatHandle desertYellow, mountainPurple, oceanBlue, swampGreen;/* PUBLIC PROCEDURES *//* put the saved map onto the screen *//* put the saved map onto the screen */void CopyOffscreenMap(Rect *aRect){	PixMapHandle base;		base = GetGWorldPixMap(offScreenP);	CopyBits((const BitMap *) *base, (const BitMap *) *(mapWindow->portPixMap), aRect, aRect, srcCopy, NULL); }void SaveToOffscreenMap(){	PixMapHandle base;		base = GetGWorldPixMap(offScreenP);	CopyBits((const BitMap *) *(mapWindow->portPixMap), (const BitMap *) *base,  &(mapWindow->portRect), &(mapWindow->portRect), srcCopy, NULL);}void DestroyMapWindow(){	CloseWindow((WindowPtr) mapWindow);}// is a given point in a hex?Boolean PointInHex(Point question, Point hex){	drawHex(hex.h, hex.v);	return (PtInRgn(question, hexH));}void DrawMap(outline)Boolean outline;{	short row, column;	Handle mapH;		HideCursor();	if ((mapH = GetNamedResource('TABL', "\pgame map")) != 0L) {/*		HLock(mapH);		BlockMove(*mapH, currentMap.baseAddr, GetHandleSize(mapH));		HUnlock(mapH);		CopyOffscreenMap();		ReleaseResource(mapH); */	} else {		for (row = 0; row < rowSize; row++)			for (column = 0; column < columnSize; column++) {				FillInCoast(row, column); 				DrawThisHex(row, column, outline); 			} 	}	SaveToOffscreenMap();	ShowCursor();}Boolean RestoreMapPicture(){	Handle mapH;		if ((mapH = GetNamedResource('TABL', "\pgame map")) != 0L) {/*		currentMap.baseAddr = NewPtr(300*64);		currentMap.rowBytes = 64;		HLock(mapH);		BlockMove(*mapH, currentMap.baseAddr, GetHandleSize(mapH));		HUnlock(mapH);		ReleaseResource(mapH); */		return true;	}	return false;}void DrawThisHex(row, column, outline)short row, column;Boolean outline;{	drawHex(row, column);	switch (GetTerrainType(row, column, same)) {				case clear:			FillRgn(hexH, &white);			break;					case desert:			FillCRgn(hexH, desertYellow);			break;					case forest:			FillRgn(hexH, &white);			GetCenterPt(row, column);			Move(-2,0);			Line(3, -3);			Line(3, 3);			Line(-2, 0);			Line(0, 2);			Line(-2,0);			Line(0,-2);			Line(-2, 0);			break;					case mountain:			FillRgn(hexH, &white);			GetCenterPt(row, column);			PenPixPat(mountainPurple);			Move(-2,0);			Line(hexSideDiv2, -hexSideDiv2);			Line(hexSideDiv2, hexSideDiv2);			PenNormal(); 			break;					case noTerrainType:			FillRgn(hexH, &black);			break;					case ocean:			FillCRgn(hexH, oceanBlue);			break;					case swamp:			FillCRgn(hexH, swampGreen);			GetCenterPt(row, column);			Move(-2,2);			Line(6,0);			Move(-3,0);			Line(-3, -3);			Move(3, 3);			Line(0, -4);			Move(0, 4);			Line(3, -3);			break;	}			drawRiver(row, column);	drawCoast(row, column);	if (outline) /* put the grid on top */		FrameRgn(hexH);}Point GetCenterPt(row, column)short row, column;{	Point r;		MoveTo(r.h = row*(hexWidthPlus1),  r.v = column *hexWidth + ((row %2 == 0) ? 0 : hexWidthDiv2));	return r;}Point GetCenterPt1(Point p){	return GetCenterPt(p.h, p.v);}CWindowPtr GetMapWindow(){	return mapWindow;}void InitPixMaps(){	SetPort((GrafPtr) (mapWindow = (CWindowPtr) GetNewCWindow(mapID, NULL, (WindowPtr)-1L)));	if (mapWindow == NULL)		FatalError(0, "\p failed to create a window");	InitHexPolygon();	InitColorPatterns();	FatalError(NewGWorld(&offScreenP, 0, &(mapWindow->portRect), 0L, 0L, 0x0), "\pPlease reset monitor depth to something smaller");}#define desertPatternID 	1398#define oceanPatternID		128#define swampPatternID		129#define mountainPatternID	130void InitColorPatterns(){	desertYellow = GetPixPat(desertPatternID);	mountainPurple = GetPixPat(mountainPatternID);	oceanBlue = GetPixPat(oceanPatternID);	swampGreen = GetPixPat(swampPatternID);}#undef desertPatternID#undef mountainPatternID#undef oceanPatternID#undef swampPatternID/* the way this polygon has to look is like this						   _						  / \		Anyway, you get the idea. Flat top, not pointy.						  \_/						  	The interesting points to remember are this:		1) We're going to start the polygon at north, and work around.	2) Positive directions are right and down*/void InitHexPolygon(){		int i, j;		SetPt(&(drawCompass[0]),  hexSideDiv2, 0);	SetPt(&(drawCompass[1]),  hexSideCos30/2, hexSideSin30/2);	SetPt(&(drawCompass[2]),  hexSideCos30/2, hexSideSin30/2);	SetPt(&(drawCompass[3]),  -hexSideCos30/2, hexSideSin30/2);	SetPt(&(drawCompass[4]),  -hexSideCos30/2, hexSideSin30/2);	SetPt(&(drawCompass[5]),  -hexSideDiv2, 0);	SetPt(&(drawCompass[6]),  -(hexSideDiv2+1), 0);	SetPt(&(drawCompass[7]),  -hexSideCos30/2, -hexSideSin30/2);	SetPt(&(drawCompass[8]),  -hexSideCos30/2, -hexSideSin30/2);	SetPt(&(drawCompass[9]),  hexSideCos30/2, -hexSideSin30/2);	SetPt(&(drawCompass[10]), hexSideCos30/2, -hexSideSin30/2);	SetPt(&(drawCompass[11]), hexSideDiv2+1, 0);	GetCenterPt(0, 0);	Move(0, -hexWidthDiv2);	GetPen(&hexLocation);	hexH = NewRgn(); OpenRgn();	for (i = 0; i < 12; i++) 		Line(drawCompass[i].h, drawCompass[i].v);	CloseRgn(hexH);}void SaveMapWindow(){	Handle mapH;	/*	PtrToHand(currentMap.baseAddr, &mapH, GetPtrSize(currentMap.baseAddr));	AddResource(mapH, 'TABL', UniqueID('TABL'), "\pgame map");	WriteResource(mapH);	ReleaseResource(mapH); */}/* PRIVATE PROCEDURES */void drawCoast(row, column)short row, column;{	Point centerPt, basePt;	RgnHandle	seaH;	Rect baseR;	int i;	unsigned type, inVal, outVal;	enum direction inDir, outDir;		if ((type = GetCoastType(row, column, same)) == noCoast)		return;	else if (type == island) {		basePt = GetCenterPt(row, column);		SetRect(&baseR, basePt.h+hexWidthDiv2-2, basePt.v+hexWidthDiv2-2, basePt.h+hexWidthDiv2+1, basePt.v + hexWidthDiv2+1);		EraseOval(&baseR);	} else {		centerPt = GetCenterPt(row, column);		for (outVal = northOut, outDir = north; outDir <= northwest; outDir++, outVal <<= 1)			if (outVal & type) {				for (inVal = outVal >> 6, inDir = outDir; (inVal & type) == 0; inDir = GetClockwise(inDir))					if (inDir == northwest)						inVal = northIn;					else inVal <<= 1;				seaH = NewRgn(); OpenRgn();				drawRiverSegment(row, column, outDir);						for (i = (outDir-1)*2; i != (inDir-1)*2; i = (i+1) % 12)					Line(drawCompass[i].h, drawCompass[i].v);				LineTo(centerPt.h, centerPt.v);				CloseRgn(seaH);				FillCRgn(seaH, oceanBlue);				DisposeRgn(seaH);  				drawRiverSegment(row, column, outDir);						drawRiverSegment(row, column,inDir);			}			} }void InvertHex(short row, short column){	drawHex(row, column);	InvertRgn(hexH);}void drawHex(row, column)short row, column;{	int i, h, v;	Point p;		GetCenterPt(row, column);	Move(0, -hexWidthDiv2);	GetPen(&p);	OffsetRgn(hexH, (int) (p.h - hexLocation.h), (int) (p.v - hexLocation.v));	SetPt(&hexLocation, p.h, p.v);}/* draws a river Thru a hex. We do this by calling a routine to draw each component. */void drawRiver(row, column)short row, column;{	unsigned r;		r = GetRiverType(row, column, same);	PenSize(2,2);	PenPixPat(oceanBlue);	if (riverSegmentMatch(r, northIn, northOut))		drawRiverSegment(row, column, north);	if (riverSegmentMatch(r, northeastIn, northeastOut))		drawRiverSegment(row, column, northeast);	if (riverSegmentMatch(r, southeastIn, southeastOut))		drawRiverSegment(row, column, southeast);	if (riverSegmentMatch(r, southIn, southOut))		drawRiverSegment(row, column, south);	if (riverSegmentMatch(r, southwestIn, southwestOut))		drawRiverSegment(row, column, southwest);	if (riverSegmentMatch(r, northwestIn, northwestOut))		drawRiverSegment(row, column, northwest);	PenNormal(); }/* draw from the center to the edge of a hex. */void drawRiverSegment(row, column, dir)short row, column;enum direction dir;{	int i;	Point endPt, endPt2;		GetCenterPt(row, column);	Move(0, -hexWidthDiv2);	for (i = 0; i < (dir-1)*2; i++)		Move(drawCompass[i].h, drawCompass[i].v);	GetPen(&endPt);	GetCenterPt(row, column);	LineTo(endPt.h, endPt.v);	GetPen(&endPt2);}