/* this is the new FindTransportCost module, usings David's algorithm	*//* for discovering transport costs 										*/#include "transport.h"#include "transportP.h"#include "cityInfoObject.h"/* This implemention is a modification of David's algorithm for finding *//* transport costs. It doesn't use the buckets idea.					*//*																		*//* GetTransportCosts from city1 to city2. Do not include the end points *//* Set the shortest known distance for city1's hex to 0. Set all others *//*	to maximumDistance.													*//* Put city1 into the list of active hexes.								*//* while (the active list is not empty)									*//*	if city2 is next to the hex at the front of the list, return this val*//*	for all hexes adjacent to the cheapest								*//*		if the cost to get to the hex from here is cheaper than its 	*//*			current cost, delete it from the list, add it into its new	*//*			location.													*//*	delete the first hex from the list.									*//* We didn't find anything cheaper than our maximum distance, so return *//* that.																*//* Notes:																*//* 																		*//* Since we're always deleting the smallest cost hex, keep this stuff	*//* in reverse order.													*//*																		*//* Since I don't think in practice we ever look at a lot of hexes, keep	*//* both the head and tail around with space on either side to insert	*//* cleverly into the list												*/// Given a city, find the nearest city that hasn't already been foundshort FindNextCity(short city){	short testCity;	struct newTransportInfo *costP;		testCity = noCity; // noCity indicates that we should look for a new one	if ((costP = createTransportRecord(city, &testCity)) != NULL) // we found a hit		attachTransportRecord(costP);	return testCity;}// how much does it cost to transport a good from city1 to city2?short GetTransportCosts(short city1, short city2, enum goodTypes good){	struct newTransportInfo *costP;	short retVal;		if (((costP = transportRecordExists(city1, city2)) == NULL) && // if no transport record exists		((costP = createTransportRecord(city1, &city2)) != NULL))  // and we were able to create one		attachTransportRecord(costP);  // attach it to the transport record list	if (costP != NULL) { // if we got at transport record list return its value		retVal = costP->cost;		if ((good == silk) || (good == gold))			retVal /= (retVal < 10) ? retVal : 10;	} else retVal = baseLabor + 1; // if we didn't, return more than can be transported	return retVal;}// if the trade route exists return the transport costs, else return 0short getExistingTransportCosts(short city1, short city2, enum goodTypes good){	if (transportRecordExists(city1, city2))		return GetTransportCosts(city1, city2, good);	else return 0;}// attach a transport information record to the master listvoid attachTransportRecord(struct newTransportInfo *newP){	if (newHeadP != NULL) { // the list exists		newTailP->nextP = newP; newTailP = newP;	} else {		newHeadP = newP; newTailP = newP;	}}struct newTransportInfo *transportRecordExists(short city1, short city2){	struct newTransportInfo *testP = newHeadP;		if (city2 != noCity) // we only want to check real cities		while ((testP != NULL) && ((testP->fromCity != city1) || (testP->toCity != city2)))			testP = testP->nextP;	else testP = NULL; // no transport record exists for a general inquiry	return testP;}struct newTransportInfo *createTransportRecord(short city1, short *city2P){	struct newTransportInfo * returnP;	struct transportSearch *baseP = NULL, *hexP = NULL, *tailP = NULL;	short i, j;	Point p;	enum direction d;	const Point errHex = {-1, -1};	Point p1, p2;	StringPtr numberString;/* initializations - set up the array that contains the current cheapest costs, and the	list of hexes we are currently looking at */		for (i = 0; i < rowSize; i++) // set all the hex costs to more than we have		for (j = 0; j < columnSize; j++)			cost[i][j] = baseLabor + 1;	baseP = (struct transportSearch *) NewPtr(sizeof(struct transportSearch)); // initialize a search record	baseP->hex = GetLocation(city1); // where is the first city?	baseP->fromHex = errHex; // the path came from nowhere	baseP->costToHere = 0; // the cost to get to here is 0	for (d = north; d <= northwest; d++) // find all the costs for hexes around here		baseP->newCost[d] = GetAdjacentHexCost(baseP->hex, GetHexCoordinates(baseP->hex.h, baseP->hex.v, d));	tailP = baseP;	/* go find the shortest path to our hex */// keep going while we don't have a match and we haven't spent too much labor to get here	while ((!checkTermination(tailP, city1, city2P)) && (tailP->costToHere <= baseLabor)) {		tailP->nextP = findNextHex(baseP);		tailP = tailP->nextP;	}	if ((tailP != NULL) && (tailP->costToHere <= baseLabor)) { // we found the answer		returnP = (struct newTransportInfo *) NewPtr(sizeof(struct newTransportInfo));		returnP->nextP = NULL;		returnP->fromCity = city1;		returnP->toCity = *city2P;		returnP->cost = tailP->costToHere;		fixTransportPath(baseP, tailP, returnP);		deleteSearchList(baseP);	} else returnP = NULL;	return returnP;} Boolean checkTermination(struct transportSearch * tailP, short city1, short *city2P){	short city2;		if (*city2P != noCity) // if this is a specific city		return (EqualPt(tailP->hex, GetLocation(*city2P))); // terminate if hex matches	else if (((IsCityHere(tailP->hex.h, tailP->hex.v, same)) && // if there is a city here				 (city1 != (city2 = GetCityIndex(tailP->hex))) &&  // and it isn't the start city				 (transportRecordExists(city1, city2)) == NULL)) {		// and a transport record doesn't exist		*city2P = city2; // 	we want to make this a city		return true;	} else return false;}void deleteSearchList(struct transportSearch * baseP){	if (baseP->nextP != NULL)		deleteSearchList(baseP->nextP);	DisposPtr((char *) baseP);}struct transportSearch * findNextHex(struct transportSearch * baseP){	short cheapestCost = baseLabor +1, newCostToHere;	struct transportSearch * testP;	enum direction d;	Point newHex, newFromHex, p;		testP = baseP;	while (testP != NULL) {		for (d = north; d <= northwest; d++)			if ((testP->newCost[d] < cheapestCost) && 				(HexLegal(p = GetHexCoordinates(testP->hex.h, testP->hex.v, d))) &&				(testP->newCost[d] < cost[p.h][p.v])) {				newHex = p;				newCostToHere = testP->newCost[d];				newFromHex = testP->hex;				cheapestCost = newCostToHere;			}		testP = testP->nextP; // go through all of them	}	if (cheapestCost < baseLabor+1) { // we got a hit		testP = (struct transportSearch *) NewPtr(sizeof(struct transportSearch));		testP->nextP = NULL;		testP->hex = newHex;		testP->costToHere = newCostToHere;		testP->fromHex = newFromHex;		for (d = north; d <= northwest; d++)			testP->newCost[d] = testP->costToHere + GetAdjacentHexCost(testP->hex, GetHexCoordinates(testP->hex.h, testP->hex.v, d));		cost[testP->hex.h][testP->hex.v] = testP->costToHere;	} else testP = NULL;	return testP;}void fixTransportPath(struct transportSearch *baseP, struct transportSearch *tailP, struct newTransportInfo *newRecordP){	const Point errHex = { -1, -1 };	short stackIndex;		stackIndex = 0;	while (!EqualPt(tailP->fromHex, errHex)) {		newRecordP->stack[stackIndex++] = tailP->hex;		tailP = findListHex(baseP, tailP->fromHex);	}}struct transportSearch *findListHex(struct transportSearch *baseP, Point testHex){	while (!EqualPt(baseP->hex, testHex))		baseP = baseP->nextP;	return baseP;}short oldGetTransportCosts(short city1, short city2, enum goodTypes good){	short cheapestCost, i, retval;	Point p, targetHex;	enum direction dir;		if (GetTransportCosts(city1, city2, noGood) > baseLabor) {		calculateTransportCosts(city1);		for (i = 0; i < GetNumberOfCities(); i++)			if (i != city1) {				cheapestCost = baseLabor;				targetHex = GetLocation(i);				for (dir = north; dir <= northwest; dir++) {					p = GetHexCoordinates(targetHex.h, targetHex.v, dir);					if (HexLegal(p) && 						(cost[p.h][ p.v] <= cheapestCost))						cheapestCost = cost[p.h][p.v];				}				SetTransportValue(city1, i, cheapestCost);			}		SetTransportValue(city1, city1, 0); /* don't check again */	}	retval = GetTransportCosts(city1, city2, noGood);	if (((good == silk) || (good == gold)) && (retval > 0))		retval /= (retval < 10) ? retval : 10;	return retval;}void GetTransportCostString(char *transportString, short transportCost, Boolean useHeader, short city){		Str255	numberString;		transportString[0] = 0;	if (useHeader) 		concatP(transportString, (char *) "\pTransport costs: ");	NumToString(transportCost/100, numberString);	concatP(transportString, (char *) numberString);	if (transportCost % 100 != 0) {		concatP(transportString, (char *) "\p.");		if (transportCost % 100 < 10)			concatP(transportString, (char *) "\p0");		NumToString(transportCost % 100, numberString);		concatP(transportString, (char *) numberString);	}	if ((useHeader) && (TypeOfTransport(city) != noGood)) {		concatP(transportString, (char *)"\p(");		transportCost /= 10;		if (transportCost == 0)			transportCost++;		NumToString(transportCost/100, numberString);		concatP(transportString, (char *) numberString);		if (transportCost % 100 != 0) {			concatP(transportString, (char *)"\p.");			if (transportCost % 100 < 10)				concatP(transportString, (char *)"\p0");			NumToString(transportCost % 100, numberString);			concatP(transportString, (char *) numberString);		}		concatP(transportString, (char *)"\p)");	}}Boolean EnoughLaborToTransport(short city1, short city2, enum goodTypes good, short amount){	if (amount < 0)		return EnoughLaborToTransport(city2, city1, good, -amount);	return ((GetTransportCosts(city1, city2, good) * amount) <= LaborAvailable(city1)) ||			(GetImport(city1, city2, good) >= amount);}enum goodTypes TypeOfTransport(short city){	if (GetProductionCost(city, gold) != 0)		return gold;	else if (GetProductionCost(city, silk) != 0)		return silk;	else return noGood;}void calculateTransportCosts(short city1){	enum direction dir;	Point p, t;	short i, j, newCost, numberOfCities;	register struct transportInfo *tailP;		headP = tailP = transportTable + (rowSize*columnSize) - 1;	tailP->hex = GetLocation(city1);	tailP->cost = 0;	for (i = 0; i < rowSize; i++)		for (j = 0; j < columnSize; j++)			cost[i][j] = baseLabor;	cost[(t = tailP->hex).h][t.v] = 0;	numberOfCities = GetNumberOfCities();	while ((tailP >= headP) && (numberOfCities > 0)) {		for (dir = north; dir <= northwest; dir++) {			p = GetHexCoordinates(t.h, t.v, dir);					if (HexLegal(p) &&				((newCost = (tailP->cost + getHexCost(t, dir))) < cost[p.h][p.v]))				insertHex(p, newCost);		}		if (IsCityHere(t.h, t.v, same))			numberOfCities--;		tailP--;		t = tailP->hex;	}}void insertHex(Point hex, short newCost){	register struct transportInfo *loc, *locLast;		if (cost[hex.h][hex.v] != baseLabor)		replaceHex(hex, newCost);	else {		for (loc = headP--, locLast = headP;loc->cost > newCost; loc++)			*locLast++ = *loc;		locLast->hex = hex;		locLast->cost = newCost;	}	cost[hex.h][hex.v] = newCost;}/* insert just before the current hex */Boolean pointsAdjacent(Point p1, Point p2){	enum direction dir;		for (dir = north; dir <= northwest; dir++)		if (EqualPt(p1, GetHexCoordinates(p2.h, p2.v, dir)))			return true;	return false;}void replaceHex(Point hex, short newCost){	register struct transportInfo *loc, *locNext;		for (loc = headP; ((hex.h!=loc->hex.h) && (hex.v!=loc->hex.v)); loc++)		;	locNext = loc+1;	while (locNext->cost > newCost)		*loc++ = *locNext++;	loc->hex = hex;	loc->cost = newCost;}short GetAdjacentHexCost(Point from, Point to){	enum direction dir;		for (dir = north; dir <= northwest; dir++)		if (EqualPt(to, GetHexCoordinates(from.h, from.v, dir)))			return getHexCost(from, dir);	return 5100;}short getHexCost(Point hex, enum direction dir){	unsigned rType;		if (GetCoastType(hex.h, hex.v, dir) != noCoast)		return 1; 	if ((rType = GetRiverType(hex.h, hex.v, same)) & DirectionToOutMask(dir))		return 20;	else if (rType & DirectionToInMask(dir))		return 50;	else switch (GetTerrainType(hex.h, hex.v, dir)) {			case ocean:			return 1;				case clear:		case forest:			return 100;					case swamp:		case desert:			return 500;					case mountain:			return 1000;					default:			return baseLabor;				}}short GetTotalTransportCosts(short city1, short city2){	enum goodTypes good;	short total, i;		if (city2 == noCity) {		for (i = total = 0; i < GetNumberOfCities(); total += GetTotalTransportCosts(city1, i++))			;		return total;	}	for (good = wheat, total = 0; good < numberOfGoods; good++)		total += GetExport(city1, city2, good)*getExistingTransportCosts(city1, city2, good);	return total;}