'***To Do List***'Load error messages overwrite their area'Check for optimal PSetXor, use it.'"Out of String space" message with help screen?'Check DCGA, Hercules, both XY and LL screens' Next revision, add mouse selection in menusDECLARE SUB ButtonFlash ()DECLARE SUB ClearQeue ()DECLARE SUB FKeysStop ()DECLARE SUB FKeysOn ()DECLARE SUB FKeysOff ()DECLARE SUB GetScreen ()DECLARE SUB HideCursor ()DECLARE SUB LimitMouse (mXmin%, mYmin%, mXmax%, mYmax%)DECLARE SUB LineXor (Xa%, Ya%, Xb%, Yb%)DECLARE SUB PrintText (TITLE$, Text$)DECLARE SUB PSetXor (Px%, Py%)DECLARE SUB PutScreen ()DECLARE SUB ResetMouse ()DECLARE SUB SetCursorPosn (mXPosn%, mYPosn%)DECLARE SUB ShowCursor ()DECLARE SUB VMouse (M%)DECLARE FUNCTION ChooseOneF% (NMesF%)TYPE Registersax AS INTEGERbx AS INTEGERcx AS INTEGERdx AS INTEGERbP AS INTEGERSI AS INTEGERDI AS INTEGERflags AS INTEGERds AS INTEGERes AS INTEGEREND TYPEDIM inregs AS Registers, outregs AS RegistersDECLARE SUB INTERRUPT (Intnum AS INTEGER, inregs AS Registers, outregs AS Registers)		    '       *******B/I DRAWING PROGRAM V1.09PC******   '    *******Copyright David D. Friedman, May 12, 1991*****   '                                               ***Main Program***DEFINT A-Z:DIM mCursor(15, 1, 8)COMMON mCursor()	CLEAR :	LFlag = 0Prestart:	ScNbr = -1MainProgramBIDR:	DEF SEG = &H0	GOSUB Screentype: GOSUB CheckForMouse	IColor = 1: BColor = 2'***Expand with graphics changes?***	GOSUB Initialize: GOSUB DefFKeys:	IF mMouse THEN GOSUB mCursorStart:	: FKeysOn: LOCATE 7, 2: PRINT "F1:Help   F2:Menu" '  ***Activitating the FKeys***MidyardSerpent: '***This whole  program is one endless loop***	ON D1 GOSUB BLine, ICurve, AxisTool, MMark, MMark, MMark, DLine, DCurve, Reverse, FileMenu, HelpMenu	GOSUB ClrMessageGOTO MidyardSerpentEND    '*******************************************************    '    ***Subroutines for the Main Program Start Here***    '****************************************************    '****************Initialize*************************Initialize:	EVENT OFF	DIM Mouse(3), BLabl$(50), BVal!(50), LX(50), LY(50)	DIM MarkX(3, 40), MarkY(3, 40), mHotX(8), mHotY(8), PCursr(4)	DIM XC(9, 300), YC(9, 300), MXI(50), MYI(50), BLineX(50), BLineY(50)	DIM LineX1(20), LineY1(20), LineX2(20), LineY2(20), MXA(50), MYA(50)	DIM TextScr$(12), I$(12), IndCurve(6), Mes$(12), Code(2), ScNbr(20)Reinitialize:	DIM Scren#(2025 * DFct!)  'Should be 2025!	DIM CursrM(60 * DFct!), Cursor(20 * DFct!, 7), ACursr(20 * DFct!), I(20)Initialize2:	CONST HScale = 60, VScale = 25:	IF LFlag THEN HNUMBER = 4: VNUMBER = 40 ELSE HNUMBER = 2: VNUMBER = 2	CONST True = -1, False = 0:	IChoice = -1: Bidr = True	ScrollUp = False: ScrollDown = False: CLS	NCursr = 20 * DFct!: LF$ = CHR$(10): CR$ = CHR$(13)	FOR I = 1 TO 16: I(I) = 0: NEXT I	GOSUB Patience'                  ***Prints Patience Message***	CONST CMAX = 10, CLTH = 300'***sets the max number and length of freehand curves**	RESTORE FirstData	FOR I = 1 TO 10: READ TextScr$(I): TextScr$(I) = "Help" + TextScr$(I): NEXT IFirstData: 	DATA BLin,Icve,Axis,Mark,Mark,Mark,Line,curv,Eras,Menu	FOR I = 1 TO 10: READ I$(I): NEXT I	DATA I1,I2,I3,I4,I5,I6,I7,I8,I9,I10	LockSwitch = 3: Px! = 1: Py! = 1: LENGTH = 8: IF LFlag THEN INC! = 24 ELSE INC! = 10	NLFLAG = NOT LFlag'***nlflag is true if we are dealing with goods X,Y***	h = 1: w = 1:	CONST PI! = 3.1415, RaDegree! = PI! / 1.8'***Height and Width ***	CONST Rate! = .1, RateB = 20: RateB2 = 2 * RateB: RateBInv! = 1 / RateB'   ***Sets the rates for dragging  endpoint.***	'Next two lines go with Put version of PSetXor	PSET (Xmax - 5, Y20): GET (Xmax - 5, Y20)-(Xmax - 4, Y20), PCursr:	PRESET (Xmax - 5, Y20) '***Creates XOR dot cursor,then cleans up***	'Next three lines create asterix for SUB ButtonFlash	LINE (Xmax - 8, Y20)-(Xmax - 1, Y20): LINE (Xmax - 7, Y20 - 3)-(Xmax - 2, Y20 + 3)	LINE (Xmax - 7, Y20 + 3)-(Xmax - 2, Y20 - 3)	GET (Xmax - 8, Y20 - 3)-(Xmax - 1, Y20 + 3), ACursr: LINE (Xmax - 8, Y20 - 3)-(Xmax - 1, Y20 + 3), 0, BF	GOSUB Axis: GOSUB ButtonPanel	RANDOMIZE (VAL(MID$(TIME$, 7, 2)))'***Reseeds random generator**	GOSUB ToBLineTool: GOSUB ClrMessage '***Chooses budgetline, Clears Patience Message**    Mouse(1) = (Xo + XH) / 2: Mouse(2) = (Yo + Yv) / 2'        ***The Rest of this helps set up the Virtual Mouse***	KEY 15, CHR$(&H82) + CHR$(&H48): ON KEY(15) GOSUB ShftUp	KEY 16, CHR$(&H82) + CHR$(&H50): ON KEY(16) GOSUB ShftDown	KEY 17, CHR$(&H82) + CHR$(&H4B): ON KEY(17) GOSUB ShftLeft	KEY 18, CHR$(&H82) + CHR$(&H4D): ON KEY(18) GOSUB ShftRight	up$ = CHR$(0) + CHR$(72): down$ = CHR$(0) + CHR$(80):	lft$ = CHR$(0) + CHR$(75): rght$ = CHR$(0) + CHR$(77)	UpRt$ = CHR$(0) + CHR$(73): DownRt$ = CHR$(0) + CHR$(81):	UpLft$ = CHR$(0) + CHR$(71): DownLft$ = CHR$(0) + CHR$(79)	CONST BSpace$ = "_" 'CHR$(&H8)	Scn$(0) = ":CGA      (640x200)": Scn$(1) = ":Hercules (720x348)"	Scn$(2) = ":DCGA     (640x400) Color"	Scn$(3) = ":EGA      (640x350) Mono+": Scn$(4) = ":EGA      (640x350) Color":	Scn$(5) = ":VGA/MCGA (640x480)": Scn$(6) = ":VGA      (640x480) Color":	EVENT ONRETURNCheckins:	inregs.ax = &H200	CALL INTERRUPT(&H16, inregs, outregs)	AL = outregs.ax AND &HFF	ALIns = 128 - (AL AND 128)RETURN'********************FKey Subroutines for Virtual Mouse**********ShftUp:	K$ = up$: ShftFnKey = 1: M = 1:RETURNShftDown:	K$ = down$: ShftFnKey = 1:  M = 1RETURNShftRight:K$ = rght$: ShftFnKey = 1: M = 1RETURNShftLeft:K$ = lft$: ShftFnKey = 1: M = 1RETURN'****This checks for available graphics, chooses best******Screentype:	j = 0: S(0) = 2: S(1) = 3: S(2) = 4: S(3) = 10:	S(4) = 9: S(5) = 11: S(6) = 12: S(7) = 0ON ERROR GOTO wrongscreen	FOR I = 0 TO 6		SCREEN S(I)		IF I < 7 THEN ScNbr(j) = I: j = j + 1:	NEXT ION ERROR GOTO 0	EVENT OFF	IF j = 0 THEN		SCREEN 0		CLS : LOCATE 20, 10: PRINT "This Machine Has No Graphics Capability"		LOCATE 20, 12: PRINT " and Therefor Cannot Run this Software,"		LOCATE 20, 14: PRINT "   since it requires at least CGA"		END	ELSE		GrModesNbr = j:  'Number of graphics modes this computer supports	END IF	IF ScNbr = -1 THEN ScNbr = ScNbr(j - 1)	IF LFlag THEN Xo = 204:  ELSE Xo = 196:	Xmax = 639: w = 25: LtWd = 8: ColorNbr = 1	SELECT CASE S(ScNbr):   '***Assigns parameters according to the screen***		CASE 2			Ymax = 199: DelX = 2: LtHt = 8: SNumber = 1: DFct! = 1: CFct = 1: ICurveDy = 0		CASE 3			IF LFlag THEN Xo = 229:  ELSE Xo = 220:			Ymax = 347: Xmax = 719: DelX = 2: LtHt = 14: LtWd = 9: SNumber = 2			DFct! = 1.96: CFct = 1: ICurveDy = 3		CASE 4			Ymax = 399: DelX = 1: LtHt = 16: SNumber = 3: DFct! = 2: CFct = 1: ICurveDy = 3		CASE 9 TO 10			Ymax = 349: DelX = 1: LtHt = 14: SNumber = 4: DFct! = 7: CFct = 4: ICurveDy = 3			IF S(ScNbr) = 10 THEN				SNumber = 5: DFct! = 3.5: CFct = 2: ColorNbr = 3			END IF		CASE 11 TO 12			Ymax = 479: DelX = 1: LtHt = 16: SNumber = 6: DFct! = 2.4: CFct = 1: w = 30: ICurveDy = 6			IF S(ScNbr) = 12 THEN SNumber = 7: DFct! = 9.6: CFct = 4		CASE ELSE			CLS : BEEP: PRINT "OOPS"	END SELECT	XH = Xmax - (5 * LtWd + 3): Yo = 22 * LtHt + 2: Yv = 2 * LtHt + 2: w = 25:	CFct = (CFct * 3 * (XH - Xo) + 32) / 8	IF S(ScNbr) > 10 THEN Yo = Yo + 3 * LtHt	X4 = LtWd / 2: X7 = LtWd - 1: X9 = LtWd + 1: X15 = 2 * LtWd - 1: X16 = 2 * LtWd	X19 = 2 * LtWd + 3	X24 = 3 * LtWd: X25 = 3 * LtWd + 1: X26 = 3 * LtWd + 2: X27 = 4 * LtWd - 5	X31 = 4 * LtWd - 1: X33 = 4 * LtWd + 1: X34 = 4 * LtWd + 2: X35 = 4 * LtWd + 3	X36 = 5 * LtWd - 4: X37 = 4 * LtWd + 5: X39 = 4 * LtWd + 7	X40 = 5 * LtWd: X41 = 5 * LtWd + 1: X42 = 5 * LtWd + 2: X43 = 5 * LtWd + 3	X51 = 7 * LtWd - 5: X56 = 7 * LtWd: X58 = 7 * LtWd + 2	X62 = 7 * LtWd + 6: X64 = 8 * LtWd: X66 = 8 * LtWd + 2	X72 = 9 * LtWd: X75 = 9 * LtWd + 3: X79 = 10 * LtWd - 1: X80 = 10 * LtWd	X85 = 11 * LtWd - 3: X86 = 11 * LtWd - 2: X88 = 11 * LtWd	X108 = 14 * LtWd - 4: X112 = 14 * LtWd: X114 = 14 * LtWd + 2: X125 = 15 * LtWd + 1	X130 = 17 * LtWd - 6: X135 = 17 * LtWd - 1: X136 = 17 * LtWd: X137 = 17 * LtWd + 1	X142 = 17 * LtWd + 6: X145 = 18 * LtWd + 1: X146 = 18 * LtWd + 2	X152 = 19 * LtWd: X153 = 19 * LtWd + 1: X154 = 19 * LtWd + 2: X155 = 19 * LtWd + 3	X158 = 20 * LtWd - 2: X159 = 20 * LtWd - 1	X160 = 20 * LtWd: X161 = 20 * LtWd + 1		R12 = 1.5 * LtWd' (Check that aspect<1 always)		Y5 = LtHt / 2 + 1: Y12 = 1.5 * LtHt	Y13 = 1.5 * LtHt + 1: Y15 = 2 * LtHt - 1: Y16 = 2 * LtHt: Y17 = 2 * LtHt + 1	Y20 = 2.5 * LtHt: Y23 = 3 * LtHt - 1: Y32 = 4 * LtHt: Y39 = 5 * LtHt - 1	Y40 = 5 * LtHt: Y43 = 5 * LtHt + 3: Y45 = 6 * LtHt - 3: Y46 = 6 * LtHt - 2	Y56 = 7 * LtHt: Y57 = 7 * LtHt + 1	Y61 = 8 * LtHt - 3: Y64 = 8 * LtHt: Y65 = 8 * LtHt + 1	Y70 = 9 * LtHt - 2: Y72 = 9 * LtHt: Y86 = 11 * LtHt - 2	Y95 = 12 * LtHt - 1: Y96 = 12 * LtHt: Y99 = 12.5 * LtHt - 1	Y100 = 12.5 * LtHt: Y102 = 13 * LtHt - 2: Y104 = 13 * LtHt: Y105 = 13 * LtHt + 1	Y112 = 14 * LtHt: Y119 = 15 * LtHt - 1	Y127 = 16 * LtHt - 1: Y128 = 16 * LtHt: Y129 = 16 * LtHt + 1	Y136 = 17 * LtHt	Y152 = 19 * LtHt: Y153 = 19 * LtHt + 1: Y154 = 19 * LtHt + 2: Y157 = 20 * LtHt - 3	Y161 = 20.5 * LtHt - 3: Y162 = 20 * LtHt + 2: Y163 = 20 * LtHt + 3:	Y164 = 20.25 * LtHt + 2: Y165 = 20.5 * LtHt + 1: Y166 = 20.5 * LtHt + 2	Y170 = 21 * LtHt + 2: Y171 = 21 * LtHt + 3: Y173 = 21 * LtHt + 5: Y176 = 22 * LtHt: Y177 = 22 * LtHt + 1	Y180 = 22.5 * LtHt: Y184 = 23 * LtHt: Y185 = 23 * LtHt + 1	Y191 = 24 * LtHt - 1: Y192 = 24 * LtHt:	Y195 = 24.5 * LtHt - 1: Y198 = 25 * LtHt - 2: Y199 = 25 * LtHt - 1	'IF S(ScNbr) = 11 THEN PALETTE 1, 4144959:	'WIDTH , w:	SCREEN S(ScNbr):	Pages = 1	EVENT ON	ON ERROR GOTO PagesError	SCREEN , , 1	SCREEN , , 0	ON ERROR GOTO 0 'Pages=1 if multiple pages, 0 if only one pageRETURNwrongscreen:	I = I + 1RESUMEPagesError:	Pages = 0RESUME NEXTmCursor:	EVENT OFF	IF S(ScNbr) = 2 THEN RESTORE CGAData ELSE RESTORE HiResData	FOR D = 0 TO 8: READ mHotX(D), mHotY(D): NEXT D	FOR D = 0 TO 8	    FOR I = 0 TO 15: READ mCursor(I, 1, D): NEXT I	    GOSUB MakeMask	    NEXT DRETURN	'***Cursor for Budget Line***HiResData: ' Hot Spot CoordinatesDATA -3,1,-1,2,-2,1,1,1,1,1,-2,0,0,2,0,2,3,0'Cursor for BLine  --HiRes versions   DATA &H0000,&H4000,&H4000,&H4000,&H6000,&H5000,&H4800,&H4400   DATA &H4200,&H4100,&H4080,&H4040,&H4020,&H4010,&H7FFE,&H0000    'Cursor for ICurve Hi-Res  DATA &H0000,&H5000,&H5000,&H5000,&H4800,&H4800,&H4800,&H4400  DATA &H4400,&H4200,&H4180,&H4070,&H400E,&H4000,&H7ffe,&H0000'  Cursor for Hi-Res Axistool   DATA &H0000,&H000E,&H7FFA,&H000E,&H0004,&H0004,&H0004,&H0004  DATA &H0004,&H0004,&H0004,&H0004,&H0004,&H0004,&H0004,&H0000'Cursor for Hi-Res X   DATA &H0000,&H4040,&H2080,&H1100, &H0A00,&H0400,&H0A00,&H1100   DATA &H2080,&H4040,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for Hi-Res block   DATA &H0000,&H7F00,&H7F00,&H7F00,&H7F00,&H7F00,&H7F00,&H7F00   DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for Hi-Res Circle  DATA &H0000,&H1c00,&H3E00,&H7F00,&h7F00,&h7F00,&H3E00,&H1C00  DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for Hi-Res Line   DATA &H0000,&H0002,&H000C,&H0030,&H00C0,&H0300,&H2C00,&H5000   DATA &H5000,&H2000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for Hi-Res Curve   DATA &H0000,&H0300,&H0480,&H2840,&H5040,&H5042,&H2024,&H0018   DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for Hi-Res Hand   DATA &H1E00,&H1200,&H1200,&H1200,&H1200,&H13FF,&H1249,&H1249   DATA &H1249,&H9001,&H9001,&H9001,&H8001,&H8001,&H8001,&HFFFF	CGAData:   ' Hot spot coordinatesDATA -3,0,-1,2,-3,1,1,1,1,1,-1,-1,0,0,0,2,2,15'Cursor   for B Line    CGA   DATA &H0000,&H4000,&H6000,&H5800,&H4600,&H4180,&H4060,&H4010   DATA &H7ffe,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0   'Cursor for ICurve CGA  DATA &H0000,&H5000,&H5000,&H4800,&H4600,&H41c0,&H403e,&H4000  DATA &H7ffe,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'cursor for CGA Axistool  DATA &H0000,&H001E,&H7Ff2,&H001E,&H000c,&H000c,&H000c,&H000c  DATA &H000c,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for CGA X  DATA &H0000,&H6060,&H1980,&H0600,&H1980,&H6060,&H0000,&H0000  DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'cURSOR for CGA block  DATA &H0000,&H7F00,&H7F00,&H7F00,&H0000,&H0000,&H0000,&H0000  DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for CGA Circle   DATA &H0000,&H3E00,&H7F00,&H3E00,&H0000,&H0000,&H0000,&H0000   DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for CGA Line   DATA &H0000,&H0002,&H003C,&H23C0,&H5C00,&H2000,&H0000,&H0000   DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for CGA Curve   DATA &H0000,&H0302,&H2484,&H5848,&H2030,&H0000,&H0000,&H0000   DATA &H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000,&H0000'Cursor for CGA Hand   DATA &HFFFF,&H8001,&H8001,&H8001,&H9001,&H9001,&H9001,&H1249   DATA &H1249,&H1249,&H13FF,&H1200,&H1200,&H1200,&H1200,&H1E00MakeMask:	mCursor(0, 0, D) = &HFFFF - mCursor(1, 1, D)	FOR I = 1 TO 14		mCursor(I, 0, D) = mCursor(I - 1, 1, D) OR mCursor(I + 1, 1, D)		C# = mCursor(I, 0, D) AND &H7FFF: C# = 2 * C#	    IF C# >= 2 ^ 15 THEN C# = (C# - (2 ^ 16))'ELSE LShift = C#	    LShift = C#			RShift = (mCursor(I, 1, D) AND &HFFFE) / 2			mCursor(I, 0, D) = (&HFFFF - (mCursor(I, 0, D) OR mCursor(I, 1, D) OR RShift OR LShift))	NEXT I	mCursor(15, 0, D) = &HFFFF - mCursor(15, 1, D)	'EVENT ONRETURN:CheckForMouse:	mMouse = 0	MSEG = 256 * PEEK(51 * 4 + 3) + PEEK(51 * 4 + 2)	MOUSE1 = 256 * PEEK(51 * 4 + 1) + PEEK(51 * 4) + 2	IF MSEG OR (MOUSE1 - 2) THEN			DEF SEG = MSEG		IF PEEK(MOUSE1 - 2) <> 207 THEN			mMouse = -1:			: ResetMouse:			: LimitMouse X7, Yv, XH + 2, Ymax - 7			: SetCursorPosn ((Xo + Xmax) / 2), ((Yo + Yv) / 2)		END IF	END IFRETURNSetCursor:  ' Function 9  Set Graphics Cursor Block (custom cursor)	IF mMouse THEN		  IF HandFlag THEN D = 8 ELSE D = D1 - 1: IF D1 > 9 THEN D = 0SetCursor2:   		inregs.ax = 9		inregs.bx = mHotX(D)  'Horizontal hot spot		inregs.cx = mHotY(D)  'Vertical hot spot		inregs.dx = VARPTR(mCursor(0, 0, D))'Pointer to Scn and Cursr Masks		CALL INTERRUPT(&H33, inregs, outregs):	ELSE		FOR F = 0 TO NCursr	      '    IF HandFlag THEN D = 8 ELSE	      D = D1 - 1: IF D1 > 9 THEN D = 0		    CursrM(F) = Cursor(F, D)   '1 - 1)		NEXT F	END IFRETURNButtonPanel:	LINE (1, Y40)-(X154, Ymax), 0, BF'***Clears the panel area***	LINE (X158, 1)-(Xmax - 1, Ymax - 1), , B: LINE (X159, 2)-(Xmax - 2, Ymax), , B'**Boxes Drawing Area***	LINE (1, 1)-(X154, Y43), , B '***Boxes Message***	LINE (1, Y157)-(X154, Y171), , B'***Markers	LINE (1, Y173)-(X154, Y185), , B:	LOCATE 7, 2: PRINT "F1:Help   F2:Menu": LINE (1, Y45)-(X154, Y57), , B	LOCATE 9, 2: PRINT "F3:Budget Line"	LINE (X130, Y64)-(X130, Y72), BColor: LINE -(X146, Y72), BColor	LINE (X130, Y65)-(X145, Y72), BColor: CIRCLE (X130, Y65), 1, BColor:    IF NOT mMouse THEN GET (X130, Y64)-(X146, Y72), Cursor(0, 0)'***When mMouse goes in	 '***These are the Window/lock buttons***	IF LFlag THEN I$ = "Io=": Px$ = "  W=": Py$ = "  A="	IF NOT LFlag THEN I$ = " I=": Px$ = " Px=": Py$ = " Py="	LOCATE 10, 2: PRINT I$: PRINT Px$: PRINT Py$: LINE (1, Y61)-(X154, Y96), , B    '***Indifference Curve and axis Buttons***	LOCATE 14, 2: PRINT "F4:I Curve "'***I Curve Tool***	'***Draw I-Curve icon***	LINE (X130, Y105)-(X130, Y112), IColor: LINE -(X145, Y112), IColor	CIRCLE (X145, Y105), R12, IColor, PI!, 3 * PI! / 2	IF NOT mMouse THEN GET (X130, Y105)-(X145, Y112), Cursor(0, 1) '***When mMouse goes in	LOCATE 17, 2: PRINT "F5:Coordinates": IF NLFLAG THEN PRINT " X=": PRINT " Y="	IF LFlag THEN LOCATE 18, 2: PRINT "L=": PRINT " I="'***Axis Tool***	LINE (1, Y102)-(X154, Y154), , B	LINE (X130, Y129)-(X145, Y129): LINE -(X145, Y136): CIRCLE (X145, Y128), 1	IF NOT mMouse THEN GET (X130, Y128)-(X146, Y136), Cursor(0, 2) '***When mMouse goes in	LOCATE 21, 2: PRINT "F6:   F7:   F8:"'***The Marking tools***	LINE (X34, Y162)-(X42, Y166): LINE (X34, Y166)-(X42, Y162)	IF S(ScNbr) = 2 THEN PSET (X33, Y162): PSET (X33, Y166)'***This is the X Tool***	IF NOT mMouse THEN GET (X33, Y162)-(X42, Y166), Cursor(0, 3)'***When mMouse goes in	LINE (X80, Y163)-(X86, Y165), , BF  '***The Block Tool***	IF NOT mMouse THEN GET (X79, Y163)-(X85, Y165), Cursor(0, 4) '***When mMouse goes in	CIRCLE (X136, Y164), 3: CIRCLE (X136, Y164), 2: CIRCLE (X136, Y164), 1: PSET (X136, Y164)	IF NOT mMouse THEN GET (X130, Y161)-(X142, Y170), Cursor(0, 5)'***When mMouse goes in	'***These are the Drawing Tools***	LOCATE 23, 2: PRINT "F9:	F10:": '***Line Drawing Tool***	LINE (X39, Y180)-(X51, Y177): CIRCLE (X37, Y180), 2	IF NOT mMouse THEN GET (X35, Y176)-(X51, Y184), Cursor(0, 6) '***When mMouse goes in	FOR I = X114 TO X135: PSET (I, Y180 + (LtHt / 8) * 1.51 * SIN(PI! * (I - 113) / 11)): NEXT I	CIRCLE (X112, Y180), 2: 'GET (X108, Y176)-(X135, Y184), Cursr8	IF NOT mMouse THEN GET (X108, Y176)-(X135, Y184), Cursor(0, 7) '***When mMouse goes in	'  '***This is the backspace button***	LINE (X31, Y195)-(X51, Y195): LINE (X37, Y192)-(X31, Y195): LINE -(X37, Y198)	LOCATE 25, 8: PRINT "BackSpace"; : LINE (X19, Y191)-(X137, Y199), , B	EVENT ONRETURN    '***********************************************************FileMenu: '***************File Menu--Saves, Loads, Prints, Clears, quits*************	: FKeysOff: EVENT OFF	Mes$(1) = "1:Quit": Mes$(2) = "2:Start Over"	Mes$(3) = "3:Change Programs":	Mes$(4) = "4:Load": Mes$(5) = "5:Save": Mes$(6) = "6:Print":	Mes$(7) = "7:Change I curve": Mes$(8) = "8:Change Axes"	'***Next line eliminates Change Graphics if there is only one alternative***	IF GrModesNbr = 1 THEN Mes$(9) = "" ELSE Mes$(9) = "9:Change Graphics"	Mes$(10) = "0:Cancel": Mes$(11) = "H:Help": NMes = 12:	GOSUB Message: IF Choice <> 11 THEN D1 = D1OLDER	IF GrModesNbr = 1 AND Choice = 9 THEN Choice = 10	ON Choice GOSUB Quit, ClearChoice, ChgeProgram, LoadChoice, SaveChoice, PrintChoice, ChangeIMap, ChangeAxes, ChangeGraphics	IF Choice = 11 THEN GOSUB ToHelpMenu:	FKeysOn	EVENT ON    RETURN    '************These Are the Alternatives on the File Menu*************LoadChoice:100 : '***This is the loading routine***	GOSUB ClrMessageLoadRoutine2:    LOCATE 2, 2: PRINT "Type name of file": LOCATE 3, 2: PRINT "And press Enter"	LOCATE 4, 2: PRINT "(A to abort)."	GOSUB FileNameLimit  '***gets the name of the file to load***	GOSUB Patience  '***patience sign***	IF F$ = "a" OR F$ = "A" THEN RUN	IF MID$(F$, 2, 1) <> ":" THEN F$ = "b:" + F$'***drive b if not specified***	ON ERROR GOTO DriveNotReadyLoading	OPEN "I", #1, F$, 1024	ON ERROR GOTO 0	EVENT OFF	: PutScreen: GOSUB Patience	FOR K = 1 TO 12: INPUT #1, I(K): NEXT K	INPUT #1, IChoice, YFactor!, XI, YI, L1Sq!, L2Sq!, RSq!, R, Slope!, A!, D!	INPUT #1, IXO, IYO, IYF, IXF, LFlag	INPUT #1, CRESTART, BRestart, LockSwitch, D1, DOld, CNbr, Px!, Py!, INC!	FOR K = 0 TO 40		FOR D = 1 TO 3: INPUT #1, MarkX(D, K), MarkY(D, K): NEXT D		INPUT #1, MXI(K), MYI(K), BLineX(K), BLineY(K), BLabl$(K), BVal!(K), LX(K), LY(K)	NEXT K	FOR K = 0 TO 20		INPUT #1, MXA(K), MYA(K), LineX1(K), LineX2(K), LineY1(K), LineY2(K)	NEXT K	FOR C = 0 TO CNbr: FOR K = 0 TO 200: INPUT #1, XC(C, K), YC(C, K): NEXT K, C	CLOSE	IM5 = IChoice - 5	IF IChoice > 3 THEN ON IChoice - 3 GOSUB Setup4, Setup5, Setup6, Setup7, Setup8, Setup9, Setup10	ON D1 GOSUB LdToBLine, LdToICve, LdToAxis, ToXTool, ToBlkTool, ToCircleTool, ToLineTool, LdToCve:	D0 = DOld'**was DO not D0	PSWITCH = 1: LINE (Xo, Yv - Y5)-(XH + X9, Yo), 0, BF: GOSUB Redraw: ' GOSUB DefFKeys	EVENT ONRETURNSaveChoice:	GOSUB ClrMessage	LOCATE 2, 2: PRINT "Type name of file": LOCATE 3, 2: PRINT "and press Enter"	LOCATE 4, 2: PRINT "(A to abort)."	GOSUB FileNameLimit	IF F$ = "a" OR F$ = "A" THEN RETURN ELSE GOSUB Patience	IF MID$(F$, 2, 1) <> ":" THEN F$ = "b:" + F$'***drive b if not specified***	ON ERROR GOTO DriveNotReadySaving	OPEN "O", #1, F$, 1024	: PutScreen	FOR K = 1 TO 12: WRITE #1, I(K): NEXT K	WRITE #1, IChoice, YFactor!, XI, YI, L1Sq!, L2Sq!, RSq!, R, Slope!, A!, D!	WRITE #1, IXO, IYO, IYF, IXF, LFlag	WRITE #1, CRESTART, BRestart, LockSwitch, D1, D0, CNbr, Px!, Py!, INC!'***D0 was DO	FOR K = 0 TO 40		FOR j = 1 TO 3: WRITE #1, MarkX(j, K), MarkY(j, K): NEXT j		WRITE #1, MXI(K), MYI(K), BLineX(K), BLineY(K), BLabl$(K), BVal!(K), LX(K), LY(K)	NEXT K	FOR K = 0 TO 20		WRITE #1, MXA(K), MYA(K), LineX1(K), LineX2(K), LineY1(K), LineY2(K)	NEXT K	FOR C = 0 TO CNbr: FOR K = 0 TO 200: WRITE #1, XC(C, K), YC(C, K): NEXT K, C	CLOSE : GOSUB ClrMessage	ON ERROR GOTO 0                                 '***ends error trapping***	: PutScreenRETURNDriveNotReadyLoading: 'Warning if disk drive not ready when loading*********	DRIVE$ = LEFT$(F$, 1): GOSUB ClrMessage	GOSUB FindSavingError     '***checks for a specific error***	LOCATE 3, 2: PRINT "Check drive " + DRIVE$ + "."	LOCATE 4, 2: PRINT "When ready": LOCATE 5, 2: PRINT "press Enter."	: ClearQeue	WHILE K$ <> CR$: K$ = INKEY$: WEND: GOSUB ClrMessageRESUME LoadRoutine2DriveNotReadySaving: 'Warning if disk drive not ready when saving*********	DRIVE$ = LEFT$(F$, 1): GOSUB ClrMessage	GOSUB FindSavingError     '***checks for a specific error***	LOCATE 3, 2: PRINT "Check drive " + DRIVE$ + "."	LOCATE 4, 2: PRINT "When ready": LOCATE 5, 2: PRINT "press Enter."	: ClearQeue	WHILE K$ <> CR$: K$ = INKEY$: WEND: GOSUB ClrMessageRESUME SaveChoiceFindSavingError: '***routine to identify the error in saving***	Text$ = "Disk Problem!"	IF ERR = 61 THEN Text$ = "Disk Full!"	IF ERR = 53 THEN Text$ = "File Not Found!"	IF ERR = 70 THEN Text$ = "Write Protected!"	IF ERR = 71 THEN Text$ = "Drive " + DRIVE$ + " Not Ready!"	LOCATE 2, 2: PRINT Text$'***prints specific error warning***RETURNClearChoice:'    IF CursorFlag THEN ShowCursor    RUNRETURNChangeGraphics:	EVENT OFF	GOSUB EraseWarning: IF YNFlag = 0 THEN RETURN ELSE PutScreen	CALL FKeysOff   '***deactivates function keys***	FOR iGr = 0 TO GrModesNbr - 1		TextF$(iGr) = STR$(iGr + 1) + Scn$(ScNbr(iGr))		IF ScNbr(iGr) = ScNbr THEN Select$ = STR$(iGr + 1): TextF$(iGr) = TextF$(iGr) + " (X)"	NEXT iGr	TextF$(GrModesNbr) = "":	TextF$(GrModesNbr + 1) = "Option" + Select$ + " is currently selected."	ChoiceF = ChooseOneF(GrModesNbr + 1)	 IF ScNbr(ChoiceF - 1) = ScNbr THEN RETURN	ScNbr = ScNbr(ChoiceF - 1)	ERASE Scren#, CursrM, Cursor, ACursr, I	: LimitMouse X31, Yv, XH + 2, Ymax - 7'- Y17	: SetCursorPosn ((Xo + Xmax) / 2), ((Yo + Yv) / 2): HandFlag = 0: GOSUB SetCursor	IF mMouse THEN GOSUB mCursor	GOSUB Screentype: GOSUB ReinitializeRETURNEraseWarning: '***warns that changing graphics erases everything***	: PutScreen	LINE (XWA, YWA + Y16)-(XWB - X16, YWA + Y86), 0, BF'***erases message area***	LINE (XWA, YWA + Y16)-(XWB - X16, YWA + Y86), , B'***boxes message area***	XSTART = (XWA / LtWd) + 2: YSTART = (YWA / LtHt) + 4: XCTR = (XWA + XWB - X16) / (2 * LtWd) - 3	: ClearQeue	LOCATE YSTART, XCTR: PRINT "WARNING";	LOCATE YSTART + 2, XSTART: PRINT "Making this change will erase";	LOCATE YSTART + 3, XSTART: PRINT "what you have done so far.";	LOCATE YSTART + 6, XSTART: PRINT "Is this what you want?(Y/N)";	LOCATE YSTART + 7, XSTART: T$ = "(strike Y for yes, N for no)": PRINT T$;	EVENT ONChangeYN:		YN$ = "": WHILE YN$ = "": YN$ = INKEY$: WEND		IF YN$ = "Y" OR YN$ = "y" THEN YNFlag = -1: RETURN		IF YN$ = "N" OR YN$ = "n" THEN YNFlag = 0: PutScreen: RETURN		BEEP: LOCATE YSTART + 7, XSTART: PRINT "!" + T$ + "!";		I! = TIMER: WHILE (TIMER < I! + 1) AND (TIMER >= I!): WEND'***delay***		LOCATE YSTART + 7, XSTART: PRINT SPACE$(32)	GOTO ChangeYNPrintChoice:	GOSUB ClrMessage	Q$ = "": IF STUDTNAME$ = "" THEN GOSUB STUDTNAME	ON ERROR GOTO ErTrapPrintPrintChoiceA:    IF Q$ = "a" OR Q$ = "A" THEN ON ERROR GOTO 0: RETURN	LPRINT STUDTNAME$, "Indifference Curve"; IChoice	ON ERROR GOTO 0	LPRINT "Yfactor="; : LPRINT USING "#.##"; YFactor!	LPRINT "Slope="; : LPRINT USING "##.##"; Slope!: LPRINT "Xorigin="; XI; :	LPRINT "	Yorigin="; YI: GOSUB ClrMessage	LOCATE 2, 2: PRINT "Depress the shift": LOCATE 3, 2: PRINT "key, press 'PrtSc'"	LOCATE 4, 2: PRINT "and wait."	CPRT = 0: WHILE (CPRT AND 3) = 0: CPRT = PEEK(&H17): WEND'***waits for shift***	GOSUB ClrMessageRETURNErTrapPrint: '***error trapping routine for printint***	GOSUB ClrMessage: LOCATE 2, 2: PRINT "Check the printer."	LOCATE 3, 2: PRINT "When ready press": LOCATE 4, 2: PRINT "enter. Press A"	LOCATE 5, 2: PRINT "to abort printing.": Q$ = "": ClearQeue	WHILE Q$ <> CR$ AND Q$ <> "a" AND Q$ <> "A"		Q$ = INKEY$	WEND	GOSUB ClrMessageRESUME PrintChoiceASTUDTNAME: '***Enter name if it has not already been entered***	LOCATE 2, 2: PRINT "Check the printer."	LOCATE 3, 2: PRINT "Type your name.": LOCATE 4, 2: PRINT "Press enter."	GOSUB StudtNameLimit: STUDTNAME$ = F$'***getting student name input***RETURNRedraw:	EVENT OFF	IHLD = I: XAHLD = Xa: XBHLD = Xb: YAHLD = Ya: YBHLD = Yb'***storing values***	MXHLD = MX: MYHLD = MY	'IF BRestart THEN Xa = XBLCRT: Xb = Xo: Ya = YO: Yb = YBLCRT: GOSUB LineXOr	IF BRestart THEN LineXor XBLCRT, Yo, Xo, YBLCRT	YC = Yo: XD = Xo'***Starts redrawing the budget lines	FOR I = 0 TO I(1) - 1		XC = BLineX(I): YD = BLineY(I)		LINE (XC, Yo)-(Xo, YD), BColor		LINE (XC + 1, Yo)-(Xo + 1, YD), BColor'   ***Draws B line***	NEXT I	FOR I = 0 TO I(1) - 1	  VALUE! = BVal!(I): LABEL$ = BLabl$(I)	  IF VALUE! <> 0 THEN		GOSUB MakeBLLabel:		PUT (LX(I), LY(I)), CursrM, PSET	  END IF	NEXT I	FOR I = 0 TO I(2) - 1: MX = MXI(I): MY = MYI(I): M = 2: GOSUB IDraw2: NEXT I: M = 0	FOR I = 0 TO I(3) - 1   '***starts redrawing axistool lines***	  'Xa = Xo: Ya = MYA(I): Xb = MXA(I): Yb = Ya: GOSUB LineXOr: Xa = Xb: Ya = YO: GOSUB LineXOr	: LineXor Xo, MYA(I), MXA(I), MYA(I): LineXor MXA(I), Yo, MXA(I), MYA(I)	NEXT I	GOSUB DefMkCursor4	FOR I = 0 TO I(4) - 1: PUT (MarkX(1, I), MarkY(1, I)), CursrM, OR: NEXT I	GOSUB DefMkCursor5	FOR I = 0 TO I(5) - 1: PUT (MarkX(2, I), MarkY(2, I)), CursrM, OR: NEXT I	GOSUB DefMkCursor6	FOR I = 0 TO I(6) - 1: PUT (MarkX(3, I), MarkY(3, I)), CursrM, OR: NEXT I	FOR I = 0 TO I(7) - 1	  LINE (LineX1(I), LineY1(I))-(LineX2(I), LineY2(I))	NEXT I	IF CRESTART THEN CBND = CNbr ELSE CBND = CNbr - 1	FOR C = 0 TO CBND	  PSET (XC(C, 0), YC(C, 0))		FOR I = 1 TO I(8 + C) - 1		LINE -(XC(C, I), YC(C, I))		NEXT I	NEXT C	I = IHLD: Xa = XAHLD: Xb = XBHLD: Ya = YAHLD: Yb = YBHLD'***Restoring values***	MX = MXHLD: MY = MYHLD	EVENT ONRETURNChangeIMap: '***Change Indifference Curve Map***	I(2) = 0: LINE (Xo, Yv - 5)-(XH + 2, Yo), 0, BF:	GOSUB Redraw: GOSUB SETUPMENU	LINE (X7, Y112)-(X125, Y119), 0, BFRETURNChangeAxes: '***Change axes from goods to leisure/labour or visa versa***	GOSUB EraseWarning: IF YNFlag = 0 THEN RETURN	IF LFlag THEN GOTO ChangeToGoods ELSE GOTO ChangeToLaborRETURNChangeToGoods: 'CLEAR : DEFINT A-Z: DEF SEG = &H0: LFlag = 0: GOTO Prestart	LFlag = 0: GOSUB Initialize2: RETURNChangeToLabor: ' CLEAR : DEFINT A-Z: DEF SEG = &H0: LFlag = -1: GOTO Prestart	 LFlag = -1: GOSUB Initialize2: RETURNChgeProgram: '***Change Programs***	RUN "control.exe"RETURNQuit:	ENDRETURN'*************************************************************************	'****************Setup Menu--Chooses I curve form*************SETUPMENU: 'chooses the indifference curve map	Mes$(1) = "Choose indifference curve map 1-10;"	Mes$(2) = "0 stands for 10.": NMes = 2	IFLAG = -1: GOSUB Message: IFLAG = 0'***Choice routine; Iflag for special fix**	IChoice = Choice: IF IChoice = 0 THEN IChoice = 10	YFactor! = 1 + 2 * RND	ON IChoice GOSUB SETUP1, SETUP2, SETUP3, Setup4, Setup5, Setup6, Setup7, Setup8, Setup9, Setup10	LOCATE 14, 13: PRINT I$(IChoice): IM5 = IChoice - 5RETURNEVENT OFFSETUP1:	IXO = XH + 20 * RND: IYO = Yv - 40 * RND: XI = IXO: YI = IYO	L1Sq! = (IXO - Xo) ^ 2 + ((IYO - Yv) * YFactor!) ^ 2	L2Sq! = (IXO - XH) ^ 2 + ((IYO - Yo) * YFactor!) ^ 2RETURNSETUP2:	IXO = XH: IYO = Yv - 40 * RND: IYF = Yv: YFactor! = 3 + RND / 2	RSq! = (IXO - Xo) ^ 2 + ((IYO - Yo) * YFactor!) ^ 2: R = SQR(RSq!): IXF = XH + R	Slope! = (IYF - IYO) * YFactor! / (IXF - IXO)	A! = 1 + Slope! ^ 2: D! = IXO * Slope! - (Yv + (IYO - Yv) * YFactor!)RETURNSETUP3:	IXO = XH - 20 * RND: IYO = Yv - 40 * RND: XI = IXO: YI = IYO	L1Sq! = (IXO - Xo) ^ 2 + ((IYO - Yv) * YFactor!) ^ 2	L2Sq! = (IXO - XH) ^ 2 + ((IYO - Yo) * YFactor!) ^ 2RETURNSetup4:	IXO = XH + 10: IYO = Yv - 22: YFactor! = 2: XI = IXO: YI = IYO	L1Sq! = (IXO - Xo) ^ 2 + ((IYO - Yv) * YFactor!) ^ 2	L2Sq! = (IXO - XH) ^ 2 + ((IYO - Yo) * YFactor!) ^ 2RETURNSetup5:	IXO = XH: IYO = Yv - 30: IYF = Yv: YFactor! = 3.5	RSq! = (IXO - Xo) ^ 2 + ((IYO - Yo) * YFactor!) ^ 2: R = SQR(RSq!): IXF = XH + R	Slope! = (IYF - IYO) * YFactor! / (IXF - IXO): A! = 1 + Slope! ^ 2: D! = IXO * Slope! - (Yv + (IYO - Yv) * YFactor!)RETURNSetup6:	DEF FNY6 (X, U!) = VScale * (U! - X / HScale) / (1 + X / HScale): DEF FNU6! (X, Y) = (X / HScale) + (Y / VScale) + ((X / VScale) * (Y / HScale))	DEF FNX6! (Y, U!) = HScale * (U! - Y / VScale) / (1 + Y / VScale)RETURNSetup7:	DEF FNY7 (X, U!) = VScale / (X / HScale - U!): DEF FNU7! (X, Y) = X / HScale - VScale / Y	DEF FNX7! (Y, U!) = HScale * (U! + VScale / Y)'***Fnx and Fny are numbers of points on the screen***RETURNSetup8:	DEF FNY8 (X, U!) = U! * HScale * VScale / X: DEF FNU8! (X, Y) = (X / HScale) * (Y / VScale)	DEF FNX8! (Y, U!) = U! * HScale * VScale / YRETURNSetup9:	DEF FNY9 (X, U!) = VScale * (U! - X / HScale): DEF FNU9! (X, Y) = X / HScale + Y / VScale	DEF FNX9! (Y, U!) = HScale * (U! - Y / VScale)RETURNSetup10:	DEF FNY0 (X, U!) = VScale * (U! - X / HScale) / (2 + X / HScale): DEF FNU0! (X, Y) = X / HScale + 2 * Y / VScale + ((X / HScale) * (Y / VScale))	DEF FNX0! (Y, U!) = HScale * (U! - 2 * Y / VScale) / (1 + Y / VScale)RETURN	'****Additional Utility functions can be added in the same way*******'EVENT ON'************************************************************HelpMenu:	: FKeysOff	D1 = D1OLDEST'***returns D1 to the value for the current tool***	Mes$(1) = "1:Instructions": Mes$(2) = "2:Help": Mes$(3) = "3:Controls"	Mes$(4) = "4:Projects": Mes$(5) = "0:Cancel": NMes = 5: GOSUB Message	ON Choice GOSUB INSTRUCTION, HELP, Controls, PROJECTS	IF Choice <> 0 THEN PrintText TITLE$, Text$'***reads and prints the help file	EVENT ON	: FKeysOn'***reactivates function keys***RETURN	  	'**********************************************************	'**************These are the Alternatives on the Help Menu*********EVENT OFFINSTRUCTION:	TITLE$ = "Instructions": Text$ = "Instruct.bid"RETURNHELP:	TITLE$ = "Help": Text$ = TextScr$(D1) + ".bid"	IF LFlag AND D1 = 1 THEN Text$ = "helpBL24.bid"RETURNControls:	TITLE$ = "Controls": Text$ = "controls.bid"RETURNPROJECTS:	TITLE$ = "Projects": Text$ = "Projects.bid"RETURNEVENT ON	'************************************************************	'****************These are the tools******************BLine:   '***budget line tool***'        IF NOT BRestart THEN GOSUB Checkins '***But not if returning from changing locks!***     '  IF LABELFLAG THEN D0 = 0: I(1) = I(1) - 1: GOSUB BLineLabel: I(1) = I(1) + 1: RETURN	GOSUB SetCursor	GOSUB PutMouse	IF LABELFLAG THEN D0 = 0: I(1) = I(1) - 1: GOSUB BLineLabel: I(1) = I(1) + 1: RETURN	RATED! = Rate!: GOSUB LOCKV	Xa = BLineX(I(1)): Ya = Yo: Xb = Xo: Yb = BLineY(I(1))	'IF BRESTART THEN MOUSE(1) = Xa - 15: MOUSE(2) = Yb	IF NOT LFlag THEN GOSUB XYgdsMessage	D0 = 0	WHILE D0 <> 1 '***Until another tool chosen***	IF NOT BRestart THEN GOSUB Checkins '***But not if returning from changing locks!***		'IF BRestart THEN GOSUB BLINESET ELSE GOSUB NEWSTART		GOSUB NewStart	WEND   '***end of outer loop***	GOSUB PutMouse:	IF BRestart THEN XBLCRT = Xa: YBLCRT = Yb'***store for redraw***RETURN		'***final return; back to Ouroboros***NewStart:		VMouse M: Xa = Mouse(1) + X16: Yb = Mouse(2): IF Yb >= Yo THEN Yb = Yo - 1	GOSUB PriceSetIF I(1) <= 50 AND D0 <> 1 THEN GOSUB BLINESET	IF I(1) = 50 THEN GOSUB RunOutofLines: D = 0	'PRINT "I(1)="; I(1);  '!!!!!!!!!!!RETURNBLINESET:	XaOld = Xa: YbOld = Yb: M = 0	WHILE M <> 2 AND D0 <> 1'***drag until CR or new tool***		VMouse M: GOSUB ChkBSpace		IF ScrollUp THEN GOSUB ScrollVarsUp		IF ScrollDown THEN GOSUB ScrollVarsDown		IF (M = 1) AND LineOn THEN LineXor XaOld, Ya, Xb, YbOld:		Xa = Mouse(1) + X16: IF Xa <= Xo THEN Xa = Xo + 1		Yb = Mouse(2): IF Yb >= Yo THEN Yb = Yo - 1		IF (M = 1) THEN			LineXor Xa, Ya, Xb, Yb: LineOn = True			XaOld = Xa: YbOld = Yb		END IF		GOSUB PriceSet	WEND	BLineX(I(1)) = Xa: BLineY(I(1)) = Yb	IF D0 = 1 THEN		IF D1 = 1 THEN BRestart = True ELSE BRestart = False:		IF (D1 > 1 AND LineOn) THEN LineXor XaOld, Ya, Xb, YbOld: LineOn = False:	RETURN	END IF	IF LineOn THEN Xa = XaOld: Yb = YbOld '***B Line where button last pressed	IF LineOn THEN LineXor Xa, Ya, Xb, Yb: LineOn = False:	LINE (Xa, Ya)-(Xb, Yb), BColor: LINE (Xa + 1, Ya)-(Xb + 1, Yb), BColor'***Draws B line***	BRestart = False: LineOn = False: GOSUB BLineLabel: I(1) = I(1) + 1RETURNBLineLabel: '***Budget Line Label Subroutine***	LABEL2FLAG = -1'***in label subroutine; F3 will not change lock***	IF (LABELFLAG <> -1) AND (NOT mMouse) THEN GOSUB PutMouse	IF Yb > Yo - 20 OR Xa < Xo + 24 THEN GOSUB LabelAbort: RETURN'Too close for label	LABEL$ = "I": VALUE! = INC!	IF LockSwitch = 2 THEN LABEL$ = "Px": VALUE! = Px!	IF LockSwitch = 3 THEN LABEL$ = "Py": VALUE! = Py!	IF LFlag THEN LABEL$ = "W": VALUE! = Px!	GOSUB MakeBLLabel	LX! = Xo + 2: LY! = Yb - Y5:	: HideCursor:	PUT (LX!, LY!), CursrM: ShowCursor	BLSLPE! = (Yo - Yb) / (Xa - Xo):	IF mMouse THEN M = 2: WHILE M = 2: VMouse M: WEND	M = 0: D = 0	: ClearQeue	WHILE K$ <> CR$ AND D0 <> 1 AND M <> 2	   IF mMouse THEN	      : VMouse M: GOSUB ChkBSpace	      IF M = 1 THEN		 DLX = (Mouse(1) - LX!) / 10: DLY = (Mouse(2) - LY!) / 10	      ELSE		 DLX = 0: DLY = 0	      END IF	   ELSE	      CALL ClearQeue: TMse! = TIMER:	      WHILE (K$ = "") AND (TIMER >= TMse!) AND (TIMER < TMse! + .15)		 K$ = INKEY$:		 GOSUB ChkBSpace	      WEND'***Should I add provision for other cursor keys? Check it. ***	      DLX = (LtWd / 2) * ((K$ = lft$) - (K$ = rght$))	      DLY = (LtHt / 4) * ((K$ = up$) - (K$ = down$))	   END IF	   : HideCursor:	   PUT (LX!, LY!), CursrM: ShowCursor	   LX! = LX! + DLX + DLY / BLSLPE!: LY! = LY! + DLY + DLX * BLSLPE!	   IF LX! > XH - X24 OR LX! < Xo + 2 THEN LX! = Xo + 2: LY! = Yb - Y5	   IF LY! >= Yo - Y20 OR LY! < Yv THEN LY! = Yo - Y20: LX! = Xo + 2 + (Yo - Yb - Y15) / BLSLPE!	   : HideCursor:	   PUT (LX!, LY!), CursrM: ShowCursor	WEND	: HideCursor:	PUT (LX!, LY!), CursrM: ShowCursor	I = I(1): BLabl$(I) = LABEL$: BVal!(I) = VALUE!	IF K$ = CR$ OR M = 2 THEN	   : HideCursor:	   PUT (LX!, LY!), CursrM, PSET: ShowCursor:	   LX(I) = LX!: LY(I) = LY!	ELSE BVal!(I) = 0	END IF	GOSUB SetCursor	D = 0: IF (LABELFLAG <> -1) AND (NOT mMouse) THEN GOSUB PutMouse	LABEL2FLAG = 0'***no longer in label (F3 shifts lock again)***	IF D1 = 11 THEN LABELFLAG = -1 ELSE LABELFLAG = 0RETURNLabelAbort: '***aborts label if Bline is too close to the axis	BVal!(I(1)) = 0	IF LABELFLAG <> -1 THEN GOSUB PutMouseRETURNMakeBLLabel: '***subroutine to create budget line label***	IF LEN(LABEL$) = 1 THEN DI = 4 ELSE DI = 0	IF (VALUE! >= 9.5 AND VALUE! < 99.5) THEN DI = DI + 4: DV = LtWd ELSE DV = 0	IF (VALUE! > 9.899999) THEN F$ = "###" ELSE F$ = "#.#"	GOSUB ClrMessage: LOCATE 3, 6: PRINT LABEL$: GET (X40, Y16)-(X56, Y23), CursrM	GOSUB ClrMessage: LOCATE 4, 5: PRINT USING F$; VALUE!: PUT (X36 + DI, Y15), CursrM	LINE (X26 + DV, Y13)-(X58, Y32), , B: GET (X26 + DV, Y13)-(X58, Y32), CursrM: GOSUB ClrMessageRETURNEVENT OFFXYgdsMessage: '***message for xygoods case only***	LOCATE 2, 2: PRINT "F3 changes": LOCATE 3, 2: PRINT "which variable"	LOCATE 4, 2: PRINT "is locked"RETURNRunOutofLines: '***Routine to print the message about running out of lines.***	GOSUB ClrMessage	LOCATE 2, 2: PRINT "You have run out": LOCATE 3, 2: PRINT "of lines."	LOCATE 4, 2: PRINT "Erase some before"	LOCATE 5, 2: PRINT "drawing any more."RETURNPriceSet:	: FKeysStop: ON LockSwitch GOSUB ILOCKED, PXLOCKED, PYLOCKED	GOSUB UpdateBLVars: FKeysOnRETURNILOCKED:	Px! = INC! * HScale / (HNUMBER * (Xa - Xo)): Py! = INC! * VScale / (VNUMBER * (Yo - Yb))RETURNPXLOCKED:	INC! = HNUMBER * Px! * (Xa - Xo) / HScale: Py! = INC! * VScale / (VNUMBER * (Yo - Yb))RETURNPYLOCKED:	INC! = VNUMBER * Py! * (Yo - Yb) / VScale: Px! = INC! * HScale / (HNUMBER * (Xa - Xo))RETURNUpdateBLVars: 'update values	IF INC! > 999.9 THEN INC! = 999.9: GOSUB ILOCKED	IF Px! > 99.9 THEN Px! = 99.9: GOSUB PXLOCKED	IF Py! > 99.9 THEN Py! = 99.9: GOSUB PYLOCKED	K$ = INKEY$	LOCATE 10, 5: PRINT USING "#####.#"; INC!	LOCATE 11, 6: PRINT USING "####.#"; Px!	LOCATE 12, 5: IF NLFLAG THEN PRINT USING "#####.#"; Py!: RETURN	A! = INC! - 24 * Px!: PRINT USING "#####.#"; A!'***prints endowment***RETURN	'***********These are the lock subroutine for the budget line**********LOCKV:	IF LFlag THEN RETURN	LINE (X88, Y72)-(X112, Y95), 0, BF	LOCATE (9 + LockSwitch), 12: PRINT "***"RETURN	'***Ends Budget line tool***EVENT ON	'***Begins Indifference Curve Tool***ICurve:	IF IChoice = -1 THEN FKeysOff: GOSUB SETUPMENU: FKeysOn	GOSUB SetCursor  '***Replaces previous line when MMouse goes in***	GOSUB PutMouse	M = 0: D0 = 0: I = I(D1): DOld = D1:	WHILE D0 <> 1: M = 0   '***Outer loop--waits for a new tool***		WHILE M <> 2 AND D0 <> 1 '***Next loop--waits for a double click***			VMouse M: GOSUB ChkBSpace:			IF M > 0 THEN			MX = Mouse(1) + 2: MY = Mouse(2) + ICurveDy			IF I(2) < 50 AND D0 <> 1 THEN GOSUB IDRAW			IF I(2) = 50 THEN GOSUB OutOfCurves: D = 0			END IF		WEND		I(2) = I	WEND	GOSUB PutMouseRETURNEVENT OFFIDRAW:	: HideCursor: FKeysOff	ON IChoice GOSUB I1DRAW, I2DRAW, I1DRAW, I1DRAW, I2DRAW	IF IChoice > 5 THEN GOSUB I6DRAW	: ShowCursor: FKeysOn	WHILE ((M = 1) AND (ds = 0)): VMouse M: WEND	IF M = 2 AND D1 = 2 THEN MXI(I) = MX: MYI(I) = MY: I = I + 1IDraw2:	: HideCursor: FKeysOff	ON IChoice GOSUB I1DRAW, I2DRAW, I1DRAW, I1DRAW, I2DRAW	IF IChoice > 5 THEN GOSUB I6DRAW	: ShowCursor: FKeysOn	IF M < 2 THEN LINE (X7, Y112)-(X125, Y119), 0, BFRETURNI1DRAW:	RSq! = (MX - XI) ^ 2 + ((MY - YI) * YFactor!) ^ 2: R = SQR(RSq!)	GOSUB I12DRAWRETURNI2DRAW:	MYP = Yv + (MY - Yv) * YFactor!	B2! = MX + Slope! * (MYP + D!): C! = MX ^ 2 + (MYP + D!) ^ 2 - RSq!	XI = (B2! + SQR(B2! * B2! - A! * C!)) / A!	YI = (Yv + (IYO - Yv) * YFactor!) + Slope! * (XI - IXO)	YI = Yv + (YI - Yv) / YFactor!	L1Sq! = (XI - Xo) ^ 2 + ((YI - Yv) * YFactor!) ^ 2	L2Sq! = (XI - XH) ^ 2 + ((YI - Yo) * YFactor!) ^ 2	GOSUB I12DRAWRETURNI12DRAW:	IF RSq! < L1Sq! THEN GOSUB FindAngle11 ELSE GOSUB FindAngle12	IF RSq! < L2Sq! THEN GOSUB FindAngle13 ELSE GOSUB FindAngle14	STARTANGLE = 180 + ANGLE2: ARCANGLE = 90 - (ANGLE1 + ANGLE2)	IndCurve(0) = YI - R / YFactor!: IndCurve(1) = XI - R	IndCurve(2) = YI + R / YFactor!: IndCurve(3) = XI + R	GOSUB FrameArcRETURNFindAngle11:	TANANG! = (Yv - YI) * YFactor! / SQR(RSq! - ((Yv - YI) * YFactor!) ^ 2)	ANGLE1 = ATN(TANANG!) * 180 / PI!RETURNFindAngle12:	TANANG! = SQR(RSq! - (XI - Xo) ^ 2) / (XI - Xo): ANGLE1 = ATN(TANANG!) * 180 / 3.1415RETURNFindAngle13:	TANANG! = (XI - XH) / SQR(RSq! - (XI - XH) ^ 2): ANGLE2 = ATN(TANANG!) * 180 / 3.1415RETURNFindAngle14:	TANANG! = SQR(RSq! - ((Yo - YI) * YFactor!) ^ 2) / (YFactor! * (Yo - YI))	ANGLE2 = ATN(TANANG!) * 180 / 3.1415RETURNI6DRAW:	ON IM5 GOSUB DefUFn6, DefUFn7, DefUFn8, DefUFn9, DefUFn0: GOSUB PRINTU	IF Xmax! > (XH - Xo) THEN Xmax6 = XH - Xo ELSE Xmax6 = Xmax!	IF M = 2 THEN		Xb = XMin + Xo + 6		ON IM5 GOSUB DefY6, DefY7, DefY8, DefY9, DefY0:		XbOld = Xb: YbOld = Yb	END IF	FOR Xb = XMin + Xo + 6 TO Xmax6 + Xo STEP 6		Xa = Xb - 6: ON IM5 GOSUB DefY6, DefY7, DefY8, DefY9, DefY0:IF M < 2 THEN	LineXor Xa, Ya, Xb, YbELSE       LINE (Xa, Ya)-(Xb, Yb), IColorEND IF	NEXT Xb	IF IX <> Xmax6 + Xo THEN Xb = Xmax6 + Xo: ON IM5 GOSUB DefYB6, DefYB7, DefYB8, DefYB9, DefYB0:    LineXor Xa, Ya, Xb, YbRETURNDefUFn6:	U! = FNU6!((MX - Xo), (Yo - MY))	XMin = .5 + FNX6!((Yo - Yv), U!): IF XMin <= 0 THEN XMin = 1	Xmax! = FNX6!(1, U!): IY = Yo - FNY6(XMin, U!): RETURNRETURNDefUFn7:	U! = FNU7!((MX - Xo), (Yo - MY))	XMin = .5 + FNX7!((Yo - Yv), U!): IF XMin <= 0 THEN XMin = 1	Xmax! = FNX7!(1, U!): IY = Yo - FNY7(XMin, U!): RETURNRETURNDefUFn8:	U! = FNU8!((MX - Xo), (Yo - MY))	XMin = .5 + FNX8!((Yo - Yv), U!): IF XMin <= 0 THEN XMin = 1	Xmax! = FNX8!(1, U!): IY = Yo - FNY8(XMin, U!): RETURNRETURNDefUFn9:	U! = FNU9!((MX - Xo), (Yo - MY))	XMin = .5 + FNX9!((Yo - Yv), U!): IF XMin <= 0 THEN XMin = 1	Xmax! = FNX9!(1, U!): IY = Yo - FNY9(XMin, U!): RETURNRETURNDefUFn0:	U! = FNU0!((MX - Xo), (Yo - MY))	XMin = .5 + FNX0!((Yo - Yv), U!): IF XMin <= 0 THEN XMin = 1	Xmax! = FNX0!(1, U!): IY = Yo - FNY0(XMin, U!): RETURNRETURNDefY6:	Ya = Yo - FNY6((Xb - Xo - 6), U!): Yb = Yo - FNY6((Xb - Xo), U!)RETURNDefY7:	Ya = Yo - FNY7((Xb - Xo - 6), U!): Yb = Yo - FNY7((Xb - Xo), U!)RETURNDefY8:	Ya = Yo - FNY8((Xb - Xo - 6), U!): Yb = Yo - FNY8((Xb - Xo), U!)RETURNDefY9:	Ya = Yo - FNY9((Xb - Xo - 6), U!): Yb = Yo - FNY9((Xb - Xo), U!)RETURNDefY0:	Ya = Yo - FNY0((Xb - Xo - 6), U!): Yb = Yo - FNY0((Xb - Xo), U!)RETURNDefYB6:	Yb = Yo - FNY6(Xmax6, U!)RETURNDefYB7:	Yb = Yo - FNY7(Xmax6, U!)RETURNDefYB8:	Yb = Yo - FNY8(Xmax6, U!)RETURNDefYB9:	Yb = Yo - FNY9(Xmax6, U!)RETURNDefYB0:	Yb = Yo - FNY0(Xmax6, U!)RETURNPRINTU:	: FKeysStop: LOCATE 15, 2: PRINT "U=";	PRINT USING "###.#"; U!: FKeysOn'***reactivates function keys***RETURNEVENT ON	'***Ends Indifference Curve Tool***	'***Starts Axis Tool***AxisTool:	GOSUB SetCursor  '***Replaces previous line when MMouse goes in***	GOSUB PutMouse:	D0 = 0: I = I(3):	WHILE D0 <> 1: M = 0  '***Outer loop--waits for a button press***		WHILE M <> 2 AND D0 <> 1: D = 0'***Next loop--waits for a double click***			WHILE (D0 <> 1) AND (M = 0)				VMouse M: GOSUB ChkBSpace				MX = Mouse(1) + X15: MY = Mouse(2) + 1				XVAL! = (MX - Xo) * HNUMBER / HScale: YVal! = (Yo - MY) * VNUMBER / VScale				: FKeysStop: LOCATE 18, 4: PRINT USING "###.#"; XVAL!				LOCATE 19, 4: PRINT USING "###.#"; YVal!: FKeysOn			WEND			MX = Mouse(1) + X15: MY = Mouse(2) + 1			IF (I(3) < 50) AND (D0 <> 1) THEN GOSUB Axislines			IF I(3) = 50 THEN GOSUB RunOutofLines		WEND		'i(3) = i	WEND	LINE (X4, Y127)-(X153, Y153), 0, B	GOSUB PutMouseRETURNAxislines:	: LineXor Xo, MY, MX, MY: LineXor MX, Yo, MX, MY	WHILE M = 1: VMouse M: WEND'***waits for release*	LINE (X25, Y136)-(X152, Y152), 0, BF	IF M = 2 THEN		MXA(I) = MX: MYA(I) = MY: I = I + 1: I(3) = I		WHILE M = 2: VMouse M: WEND		RETURN	END IF	LineXor MX, Yo, MX, MY: LineXor Xo, MY, MX, MY:RETURN	'***End of Axis Tool***	'***Beginning of three marking tools***MMark:	D0 = 0: DMK = D1 - 3:	ON DMK GOSUB DefMkCursor4, DefMkCursor5, DefMkCursor6:	GOSUB SetCursor	GOSUB PutMouse	WHILE D0 <> 1: D = 0'***Outer loop--waits for a button press***		WHILE M = 0 AND D0 <> 1			VMouse M: GOSUB ChkBSpace:		WEND		IF I(D1) < 41 AND D0 <> 1 THEN GOSUB Mark		GOSUB Checkins:		IF I(D1) = 41 THEN GOSUB OutOfMarks		WHILE M > 0: VMouse M: WEND'***waits for button up**	WEND	GOSUB PutMouseRETURNEVENT OFFOutOfMarks: '***Routine to print the message about running out of marks.***	GOSUB ClrMessage	LOCATE 2, 2: PRINT "You have run out": LOCATE 3, 2: PRINT "of that mark."	LOCATE 4, 2: PRINT "Erase some before"	LOCATE 5, 2: PRINT "drawing any more." RETURN	'***Starts Cursor definition subroutines for MMK***DefMkCursor4: GET (X33, Y162)-(X42, Y166), CursrM: RETURNDefMkCursor5: GET (X80, Y163)-(X86, Y165), CursrM: RETURNDefMkCursor6: GET (X130, Y164 - 3)-(X142, Y164 + 3), CursrM: RETURNMark:	I = I(DMK + 3): MarkX(DMK, I) = Mouse(1): MarkY(DMK, I) = Mouse(2)	I(DMK + 3) = I(DMK + 3) + 1	IF mMouse THEN		: HideCursor:		PUT (Mouse(1), Mouse(2)), CursrM, PSET: ShowCursor	ELSE		PUT (Mouse(1), Mouse(2)), CursrM:		PUT (Mouse(1), Mouse(2)), CursrM, OR		 Mouse(1) = Mouse(1) + 2: PUT (Mouse(1), Mouse(2)), CursrM	END IFRETURNEVENT ON	'***Ends Marking Tools***	'***Begins line drawing tool***DLine:	GOSUB SetCursor	GOSUB PutMouse	RATED! = Rate! * 3: D0 = 0:	WHILE D0 <> 1		M = 0		WHILE M = 0 AND D0 <> 1 AND NOT LRestart			VMouse M: GOSUB ChkBSpace:		WEND		WHILE M = 1: VMouse M: GOSUB ChkBSpace: WEND		IF NOT LRestart THEN X = Mouse(1): Y = Mouse(2) + 4		IF I(D1) < 20 AND D0 <> 1 THEN GOSUB LineDraw		IF I(D1) = 20 THEN GOSUB RunOutofLines	WEND	GOSUB PutMouseRETURNLineDraw:	: HideCursor	IF NOT LRestart THEN PSetXor X, Y: XNew = X: YNew = Y: LPT1FLAG = -1	: ShowCursor	'***LPT1FLAG is true if we are still drawing the line, not pulling it.*	M = 0: D = 0'***Disables the hairtrigger, here and elsewhere***	WHILE M = 0 AND D0 <> 1 AND LPT1FLAG		: LineXor X, Y, XNew, YNew		VMouse M: GOSUB ChkBSpace:		XNew = Mouse(1): YNew = Mouse(2) + 4		: LineXor X, Y, XNew, YNew	WEND	IF D1 < 10 THEN LPT1FLAG = 0	WHILE M = 1: VMouse M: WEND	WHILE (M <> 2 AND D0 <> 1)		VMouse M: GOSUB ChkBSpace:		MX = Mouse(1): MY = Mouse(2) + 4		IF M = 1 THEN GOSUB MOVEND	WEND	'***LRESTART is true if we are restarting after file or help***	IF D1 > 9 THEN LRestart = -1: RETURN ELSE LRestart = 0	LineX1(I(7)) = X: LineY1(I(7)) = Y: LineX2(I(7)) = XNew: LineY2(I(7)) = YNew	I(7) = I(7) + 1	: HideCursor	LineXor X, Y, XNew, YNew	IF M = 2 THEN	LINE (X, Y)-(XNew, YNew)	END IF	: ShowCursorRETURNMOVEND:	DELTAXL = MX - X: DELTAYL = MY - Y	DELTAXR = MX - XNew: DELTAYR = MY - YNew	DISTL! = DELTAXL ^ 2 + 4 * (DELTAYL ^ 2): DISTR! = DELTAXR ^ 2 + 4 * (DELTAYR ^ 2)	IF DISTL! < DISTR! AND DISTL! < 3000 THEN GOSUB MoveLt ELSE GOSUB TESTRTRETURN '**Moves left end of line if cursor is close to it, otherwise checks right endTESTRT:	IF DISTR! < 3000 THEN GOSUB MOVERT 'if cursor close to end, move right endRETURN '**Moves right end of line if cursor is close to itMOVERT:	: LineXor X, Y, XNew, YNew	XNew = XNew + DELTAXR * RATED!	IF XNew > XH THEN XNew = XH ELSE IF XNew < Xo THEN XNew = Xo	YNew = YNew + DELTAYR * RATED!	IF YNew < Yv THEN YNew = Yv ELSE IF YNew > Yo THEN YNew = Yo	: LineXor X, Y, XNew, YNew:RETURN  '**Moves right end of lineMoveLt:	LineXor X, Y, XNew, YNew: '**Moves left end of line	X = X + DELTAXL * RATED!: Y = Y + DELTAYL * RATED!	IF X > XH THEN X = XH ELSE IF X < Xo THEN X = Xo	IF Y < Yv THEN Y = Yv ELSE IF Y > Yo THEN Y = Yo	: LineXor X, Y, XNew, YNew'**Moves left end of lineRETURN	'***End of Line Drawing Tool***EVENT OFF	'***Beginning of curve drawing tool***DCurve:	M = 0: D0 = 0	'***the next line announces if no more curves are available***	 ' IF CNBR=CMAX THEN GOSUB MOVEND:WHILE D0<>1:WEND:DOLD=D1:GOSUB ExtendLine2:RETURN	GOSUB SetCursor  '***Replaces previous line when MMouse goes in***	GOSUB PutMouse	WHILE D0 <> 1: D = 0		IF CNbr = CMAX THEN GOSUB OutOfCurves'***message that curves are used up***		WHILE M = 0 AND D0 <> 1 AND M <> 2			VMouse M: GOSUB ChkBSpace:		WEND		IF CRESTART THEN GOSUB Restart ELSE GOSUB StartCurve		M = 0	WEND	GOSUB PutMouse:RETURNRestart:	I = I(8 + CNbr): X! = XC(CNbr, I): Y! = YC(CNbr, I)	IF D0 <> 1 THEN GOSUB CurveDrawRETURNStartCurve:	IF CNbr = CMAX THEN RETURN	X! = Mouse(1): Y! = Mouse(2)	IF D0 = 1 THEN RETURN	Xa = X!: Ya = Y!: I = 0: CRESTART = -1	XC(CNbr, 0) = X!: YC(CNbr, 0) = Y!: GOSUB CurveDrawRETURNCurveDraw:	WHILE D0 <> 1 AND M <> 2  '***Start of Outer Loop***		WHILE (M = 0) AND (D0 <> 1) 'AND M <> 2'***Button Up***			VMouse M: GOSUB ChkBSpace: 'GOSUB MouseDelay		WEND		WHILE M = 1 ' AND M <> 2     '***Button Down***			VMouse M: GOSUB ChkBSpace:			MX = Mouse(1): MY = Mouse(2): 'CST = HFMWT: GOSUB MouseDelay			DeltaX = MX - X!: DeltaY = MY - Y!:			Test = (DeltaX > RateB2) OR (DeltaX < -RateB2) OR (DeltaY > RateB2) OR (DeltaY < -RateB2)			IF Test THEN GOSUB ExtendLine		WEND	WEND  '***end of outer loop***	I(8 + CNbr) = I: IF D0 <> 1 THEN CRESTART = 0: GOSUB SolidCurve: CNbr = CNbr + 1RETURNExtendLine:	X! = X! + DeltaX * RateBInv!: Y! = Y! + DeltaY * RateBInv!	IF X! < Xo THEN X! = Xo ELSE IF X! > XH THEN X! = XH	IF Y! > Yo THEN Y! = Yo ELSE IF Y! < Yv THEN Y! = Yv	Px = X!: Py = Y!	IF I >= CLTH THEN GOSUB MaxCveLgth: RETURN	IF (Px = XC(CNbr, I) AND Py = YC(CNbr, I)) THEN RETURN	PSetXor Px, PyExtendLine2:   '***Probably surplus label***	I = I + 1: I(8 + CNbr) = I: XC(CNbr, I) = X!: YC(CNbr, I) = Y!RETURNOutOfCurves: '***Routine to print the message about running out of curves.***	GOSUB ClrMessage	LOCATE 2, 2: PRINT "You have run out": LOCATE 3, 2: PRINT "of curves."	LOCATE 4, 2: PRINT "Erase some before"	LOCATE 5, 2: PRINT "drawing any more." RETURNMaxCveLgth: '***Routine to print the message about reaching max curvelength.***	GOSUB ClrMessage	LOCATE 2, 2: PRINT "You cannot make": LOCATE 3, 2: PRINT "this curve any"	LOCATE 4, 2: PRINT "longer."	IF FRSTIME = 0 THEN LOCATE 5, 2: PRINT "Life is like that.": FRSTIME = 1 '      POKE &H18, 0 RETURN 'EVENT ON	'***End of Curve Drawing Tool***	'    *****************End of Tools*******************	'    ************This is the reverse button*************Reverse:	: FKeysOff	IF D1Old <> 8 THEN I(D1Old) = I(D1Old) - 1: DOld = 0	IF D1Old = 8 AND CRESTART THEN GOSUB Revcurve: FKeysOn: RETURN	IF D1Old = 8 THEN CNbr = CNbr - 1	LINE (Xo, Yv - Y5)-(XH + X9, Yo), 0, BF: GOSUB Redraw: D1 = D1Old: FKeysOn RETURNRevcurve:	D1 = 8: IF I(8 + CNbr) = 0 THEN CRESTART = 0: RETURN	'   IF I(8)=0 AND CNBR=0 THEN CRESTART=0:RETURN	I(8 + CNbr) = I(8 + CNbr) - 1: I = I(8 + CNbr)	: PSetXor XC(CNbr, I + 1), YC(CNbr, I + 1)RETURNSolidCurve: 'solid curve drawing	PSET (XC(CNbr, 0), YC(CNbr, 0))	FOR I = 1 TO I(8 + CNbr)	LINE -(XC(CNbr, I), YC(CNbr, I))	NEXT I RETURN	'**********************************************************	'*************************Axis*****************************	'***Draws in an axis; (xo,yo) is the origin. HScale is the number of dots per***	'***mark, Hnumber the number by which each mark increments quantity.****Axis:	NHORIZ = (XH - Xo) / HScale: NVERT = (Yo - Yv) / VScale: Y = Yo: X = Xo	XSCALE = Xo + 1 - LtWd: YSCALE = Yo + LtHt / 2: XSCALE2 = Xo - 3: YSCALE2 = Yo + 1	'         ***Next four lines draw and label the marks on the axes****	FOR I = 0 TO NVERT STEP 2		LOCATE (Y + Y5) / LtHt, (XSCALE - X24) / LtWd: PRINT USING "###"; VNUMBER * I; :		LINE (XSCALE, Y)-(XSCALE2, Y + 1), , B: Y = Y - 2 * VScale	NEXT I	FOR I = 0 TO NHORIZ STEP 2		LOCATE (YSCALE + Y12) / LtHt, (X - X4) / LtWd: PRINT HNUMBER * I;		LINE (X, YSCALE)-(X - 1, YSCALE2), , B: X = X + 2 * HScale	NEXT I	IF LFlag THEN GOSUB AxisLabelLL ELSE GOSUB AxisLabelXY	LINE (Xo - 2, Yv)-(Xo, Yo), , BF: LINE (Xo - 2, Yo)-(XH, Yo + 1), , BF'***Draw axes***RETURNAxisLabelLL: '***label axes for labor/leisure choice***	LOCATE (Yo + Y13) / LtHt, (Xo + XH - X64) / (2 * LtWd): PRINT "Leisure";	XPt = Xo / LtWd - 2: YPt = Yv / LtHt + 9	  SELECT CASE S(ScNbr)	  CASE 2		LOCATE YPt + 2, XPt: PRINT "c"; : LOCATE YPt + 3, XPt: PRINT "o"		LOCATE YPt + 4, XPt: PRINT "m"; : LOCATE YPt + 5, XPt: PRINT "e";	  CASE 3        'Hercules		YPt = YPt - 2		LOCATE YPt + 2, XPt: PRINT "c"; : LOCATE YPt + 4, XPt: PRINT "o"		LOCATE YPt + 5, XPt: PRINT "m"; : LOCATE YPt + 6, XPt: PRINT "e"	  CASE 4        'DCGA		LOCATE YPt + 2, XPt: PRINT "c"; : LOCATE YPt + 3, XPt: PRINT "o"		LOCATE YPt + 4, XPt: PRINT "m"; : LOCATE YPt + 5, XPt: PRINT "e";	    'LOCATE YPt + 1, XPt: PRINT "c"; : LOCATE YPt + 2, XPt: PRINT "o"	    'LOCATE YPt + 6, XPt: PRINT "m"; : LOCATE YPt + 7, XPt: PRINT "e"	  CASE 9 TO 10  'EGA		YPt = YPt - 2		LOCATE YPt + 2, XPt: PRINT "c"; : LOCATE YPt + 4, XPt: PRINT "o"		LOCATE YPt + 5, XPt: PRINT "m"; : LOCATE YPt + 6, XPt: PRINT "e"	  CASE 11 TO 12 'VGA and equivalent		LOCATE YPt + 3, XPt: PRINT "c"; : LOCATE YPt + 4, XPt: PRINT "o"		LOCATE YPt + 6, XPt: PRINT "m"; : LOCATE YPt + 7, XPt: PRINT "e"	  CASE ELSE	  END SELECT		LOCATE YPt, XPt: PRINT "I"; : LOCATE YPt + 1, XPt: PRINT "n"RETURNAxisLabelXY:  '***label axes for two goods, X and Y***	LOCATE (Yo + Y13) / LtHt, (XH + X16) / LtWd: PRINT "X";	LOCATE (Yv) / LtHt, (Xo) / LtWd: PRINT "Y";RETURN	'***********************************************************	'**********************************************************Patience:	GOSUB ClrMessage: LOCATE 3, 7: PRINT "PATIENCE"RETURNClrMessage: '***Clears Message Area***	LINE (2, 2)-(X153, Y39), 0, BFRETURNEVENT ONDefFKeys: 'Defines function keys	ON KEY(1) GOSUB ToHelpMenu: ON KEY(2) GOSUB ToFileMenu: ON KEY(3) GOSUB ToBLineTool	ON KEY(4) GOSUB ToICveTool: ON KEY(5) GOSUB ToAxisTool: ON KEY(6) GOSUB ToXTool	ON KEY(6) GOSUB ToXTool: ON KEY(7) GOSUB ToBlkTool: ON KEY(8) GOSUB ToCircleTool	ON KEY(9) GOSUB ToLineTool: ON KEY(10) GOSUB ToCveTool:RETURNEVENT OFF	'*****Subroutines for reacting to tool choices********ToFileMenu: D1OLDER = D1: D1 = 10: D0 = 1: RETURN'***sends it to file menu***ToHelpMenu: D1OLDEST = D1: D1 = 11: D0 = 1: RETURN'***sends it to help menu***	ToBLineTool:	Test = (D1 = 1 AND NLFLAG AND NOT LABEL2FLAG)	IF Test THEN LockSwitch = LockSwitch + 1 + (LockSwitch = 3) * 3: GOSUB LOCKV	IF D1 = 1 THEN D0 = 1: RETURN'  ***back to Budget line tool***'        IF D1 = 1 THEN M = 2: RETURN'***Budget line tool***LdToBLine:	D1 = 1: D0 = 1: '***If not already in BLine, go there***RETURNToICveTool:'     IF D1 = 2 THEN M = 2: RETURN'***Indifference curve tool***LdToICve:	D1 = 2: D0 = 1:RETURNToAxisTool:'     IF D1 = 3 THEN M = 2: RETURNLdToAxis:	D1 = 3: D0 = 1:RETURN    '***axis coordinates tool***ToXTool: D0 = 1: D1 = 4: RETURN    '***X tool***ToBlkTool: D0 = 1: D1 = 5: RETURN    '***Block tool***ToCircleTool: D0 = 1: D1 = 6: RETURN    '***circle tool***ToLineTool: D0 = 1: D1 = 7: RETURN    '***Line drawing tool***ToCveTool: '    IF D1 = 8 THEN M = 2: RETURN'***Curve drawing tool***LdToCve:	D0 = 1: D1 = 8:RETURNScrollVarsUp: DELP! = .1: GOSUB RecalcIPxPy: ScrollUp = False: RETURN'***Scrolls up***ScrollVarsDown: DELP! = -.1: GOSUB RecalcIPxPy: ScrollDown = False: RETURN'***Scrolls down***ChkBSpace:	IF HandFlag THEN		IF NOT OldHandFlag THEN GOSUB SetCursor		IF HandM > 0 THEN GOSUB ChkForToolClick	ELSE		IF OldHandFlag THEN GOSUB SetCursor:	END IF	IF BackSpace THEN BackSpace = False: GOSUB BSpaceSetupRETURNChkForToolClick:	SELECT CASE Mouse(2)	CASE Y46 TO Y56		IF (MouseX > X7) AND (MouseX < X66) THEN ButtonFlash: GOSUB ToHelpMenu		IF (MouseX > X85) AND (MouseX < X146) THEN ButtonFlash: GOSUB ToFileMenu	CASE Y64 TO Y72		IF (MouseX > X125) AND (MouseX <= X145) THEN ButtonFlash: GOSUB ToBLineTool	CASE Y105 TO Y112		IF (MouseX > X125) AND (MouseX <= X145) THEN ButtonFlash: GOSUB ToICveTool	CASE Y127 TO Y136		IF (MouseX > X125) AND (MouseX <= X145) THEN ButtonFlash: GOSUB ToAxisTool	CASE Y157 TO Y170		SELECT CASE MouseX		CASE X31 TO X43			: ButtonFlash: GOSUB ToXTool			CASE X72 TO X88			: ButtonFlash: GOSUB ToBlkTool		CASE X125 TO X142			: ButtonFlash: GOSUB ToCircleTool		CASE ELSE		END SELECT	CASE Y176 TO Y184		IF (MouseX >= X34) AND (MouseX <= X51) THEN ButtonFlash: GOSUB ToLineTool  'D1 = 7		IF (MouseX >= X108) AND (MouseX <= X136) THEN ButtonFlash: GOSUB ToCveTool  'D1 = 8	CASE Y191 TO Y199		IF (MouseX >= X19) AND (MouseX <= X137) THEN ButtonFlash: BackSpace = True	CASE ELSE	END SELECTRETURNBSpaceSetup: '***setup for backspace****	GOSUB ClrMessage: IF (D1 < 8 AND I(D1) = 0) THEN GOSUB RevPastZero: RETURN	IF D1 = 8 AND CNbr = 0 AND NOT CRESTART THEN GOSUB RevPastZero: RETURN	IF D1 = 8 AND CNbr = 0 AND CRESTART AND I(8) = 0 THEN CRESTART = 0: GOSUB RevPastZero: RETURN	IF D1 <> 9 THEN D1Old = D1: D1 = 9: D0 = 1 ELSE D1 = D1OldRETURNRevPastZero: ' message for reversing past zero	LOCATE 2, 2: PRINT "You cannot": LOCATE 3, 2: PRINT "erase what is"	LOCATE 4, 2: PRINT "not there" RETURNFrameArc: '***Framearc subroutine--corresponds to Macintosh toolbox call***	ACTRX = (IndCurve(1) + IndCurve(3)) / 2: ACTRY = (IndCurve(0) + IndCurve(2)) / 2	XRAD = ABS(IndCurve(3) - IndCurve(1)) / 2: YRAD = ABS(IndCurve(2) - IndCurve(0)) / 2	IF XRAD > YRAD THEN ArcStep = 800 / XRAD ELSE ArcStep = 800 / YRAD	IF ArcStep < 1 THEN ArcStep = 1	IF M = 2 THEN		'ARCSTEP = ARCSTEP / 2:		FI = STARTANGLE * RaDegree!		PXOld = ACTRX + XRAD * SIN(FI / 100)		PYOld = ACTRY - YRAD * COS(FI / 100)	END IF	FOR FI = STARTANGLE * RaDegree! TO (STARTANGLE + ARCANGLE) * RaDegree! STEP ArcStep		Px = ACTRX + XRAD * SIN(FI / 100): Py = ACTRY - YRAD * COS(FI / 100):		IF M < 2 THEN			: PSetXor Px, Py		ELSE			LINE (Px, Py)-(PXOld, PYOld), IColor:			PXOld = Px: PYOld = Py		END IF	NEXT FI:RETURNRecalcIPxPy: '***starts recalculation of I,Px,Py***	ON LockSwitch GOSUB NewInc, NewPx, NewPy: GOSUB PriceSet'***Scrolls I,Px,Py***RETURNNewInc:	INC! = INC! + DELP!: IF INC! < .1 THEN INC! = .1 ELSE IF INC! > 999.9 THEN INC! = 999.9RETURNNewPx:	Px! = Px! + DELP!: IF Px! < .1 THEN Px! = .1 ELSE IF Px! > 99.9 THEN Px! = 99.9RETURNNewPy:	Py! = Py! + DELP!: IF Py! < .1 THEN Py! = .1 ELSE IF Py! > 99.9 THEN Py! = 99.9RETURNPutMouse: '***start and end icon to scrn***	IF mMouse THEN		IF CursorFlag = -1 THEN ShowCursor ELSE HideCursor		IF (CursorFlag < -1) OR (CursorFlag > 0) THEN BEEP: CLS : PRINT "CursorFlag"; CursorFlag: END	ELSE		PUT (Mouse(1), Mouse(2)), CursrM:	END IFRETURNEVENT ONMessage: '***message and choice routine***	: ClearQeue: WID = 32'***wid ends up as the width of the longest line	FOR IMES = 1 TO NMes		IF LEN(Mes$(IMES)) > WID THEN WID = LEN(Mes$(IMES))	NEXT IMES: WID = WID + 1	XWA = (Xo + XH) / 2 - LtWd * WID / 2: XWB = (Xo + XH) / 2 + LtWd * WID / 2 + 4	YWA = Y99 - LtHt * (NMes + 6) / 2: YWB = Y104 + LtHt * (NMes + 6) / 2	XLOC = XWA / LtWd + 2: YLOC = YWA / LtHt + 1	: GetScreen	LINE (XWA, YWA)-(XWB, YWB), , B: LINE (XWA + 1, YWA + 1)-(XWB - 1, YWB - 1), 0, BF	FOR IMES = 1 TO NMes - 1: LOCATE YLOC + IMES, XLOC: PRINT Mes$(IMES): NEXT IMES	LOCATE YLOC + NMes + 1, XLOC: PRINT Mes$(NMes)'***cancel message***	Choice = 12: ClearQeue	'***The next line is a fix for I-curve choice problems***	IF IFLAG THEN NMESLESSONE = 9 ELSE NMESLESSONE = NMes - 1	WHILE (I$ <> "0" AND Choice = 0) OR (Choice > NMESLESSONE)		LOCATE YLOC + NMes + 3, XLOC: PRINT "[Select by striking appropriate"		LOCATE YLOC + NMes + 4, XLOC: PRINT "number (not function) key.]"		I$ = INPUT$(1): Choice = VAL(I$)'***chooses one alternative***		IF I$ = "h" OR I$ = "H" THEN Choice = 11	WEND	: PutScreenRETURN	'*************Filter subroutine ends**************FileNameLimit: '***subroutine to limit file name to 8.3***	I = 0: F$ = "": DOT = 0: COLON = 0: CR$ = CHR$(13): ClearQeue	WHILE K$ <> CR$ '***until a carriage return is entered***		LOCATE 5, 2: PRINT F$		K$ = "": WHILE K$ = "": K$ = INKEY$: WEND'***wait for a key press***		A = ASC(K$)		Test = ((A > 47 AND A < 58) OR (A > 64 AND A < 91) OR (A > 96 AND A < 123)) AND I < 8		IF Test THEN F$ = F$ + K$: I = I + 1'***adding a new letter***		IF K$ = "." AND I > 0 AND NOT DOT THEN F$ = F$ + K$: I = 5: DOT = -1'***adding .***		IF K$ = ":" AND NOT (DOT OR COLON) AND I = 1 THEN F$ = F$ + K$: I = 0: COLON = -1		IF A = 8 AND I > 0 THEN GOSUB BackSpacing'***backspacing***	WENDRETURNBackSpacing: 'subroutine for backspacing	l = LEN(F$): K$ = RIGHT$(F$, 1): F$ = LEFT$(F$, l - 1)	IF K$ = "." THEN I = l - 1: DOT = 0 ELSE I = I - 1	IF K$ = ":" THEN I = 1: COLON = 0	LOCATE 5, 2: PRINT "			 "'**erases backspaced letter**RETURNStudtNameLimit: '***subroutine to limit student name to 12***	I = 0: F$ = "": DOT = 0: CR$ = CHR$(13): ClearQeue	WHILE K$ <> CR$ '***until a carriage return is entered***		LOCATE 5, 2: PRINT F$		K$ = "": WHILE K$ = "": K$ = INKEY$: WEND'***wait for a key press***		A = ASC(K$)		Test = ((A > 47 AND A < 58) OR (A > 64 AND A < 91) OR (A > 96 AND A < 123)) AND I < 17		IF Test OR A = 32 THEN F$ = F$ + K$: I = I + 1'***adding a new letter***		IF A = 8 AND I > 0 THEN GOSUB BackSpacing'***backspacing***	WENDRETURNSUB ButtonFlash STATICSHARED MouseX, Mouse(), ACursr()HideCursorPUT (MouseX - 3, Mouse(2) - 3), ACursrT! = TIMERWHILE (TIMER >= T!) AND TIMER < (T! + .2)WENDPUT (MouseX - 3, Mouse(2) - 3), ACursrShowCursorEND SUBDEFSNG A-ZFUNCTION ChooseOneF% (NMesF%)DEFINT A-ZSHARED TextF$(), LtWd, LtHt, Xo, XH, Ymax   WID = 32'***wid becomes width of longest line   FOR IMES = 0 TO NMesF      IF LEN(TextF$(IMES)) > WID THEN WID = LEN(TextF$(IMES))   NEXT IMES: WID = WID + 1   XWA = (Xo + XH - 4 * LtWd) / 2 - (LtWd * WID) / 2: XWB = (Xo + XH - 4 * LtWd) / 2 + (LtWd * WID) / 2 + 6   aYWA = ((Ymax + 1) / 2) - (LtHt / 2) * (NMesF + 5): aYWB = (Ymax + 1) / 2 + (LtHt / 2) * (NMesF + 6)   XLOC = XWA / LtWd + 2: YLOC = aYWA / LtHt + 1.51   LINE (XWA, aYWA)-(XWB, aYWB), , B: LINE (XWA + 1, aYWA + 1)-(XWB - 1, aYWB - 1), 0, BF   FOR IMES = 0 TO NMesF: LOCATE YLOC + IMES, XLOC + 1: PRINT TextF$(IMES): NEXT IMES   WHILE INKEY$ <> "": WEND'***clears the typeahead buffer***   ChoiceF = 11   WHILE (I$ <> "0" AND ChoiceF = 0) OR ChoiceF >= NMesF      LOCATE YLOC + NMesF + 2, XLOC + 1: PRINT "[select by striking appropriate"      LOCATE YLOC + NMesF + 3, XLOC + 1: PRINT "number (not function) key]"      I$ = INPUT$(1): ChoiceF = VAL(I$)'***chooses one alternative***   WEND      : PutScreen      : ChooseOneF = ChoiceFEND FUNCTION	 '***Clears keyboard queue***SUB ClearQeueSHARED K$ReadAgn: K$ = INKEY$: IF K$ <> "" THEN GOTO ReadAgnEND SUBSUB FKeysOffSHARED X153, Y46, Y56'        LINE (2, Y46)-(X153, Y56), 0, BF	FOR F = 1 TO 10: KEY(F) OFF: NEXT F: ' KEY(14) OFFEND SUBSUB FKeysOn	FOR F = 1 TO 10: KEY(F) ON: NEXT F: ' KEY(14) ON'        LOCATE 7, 2: PRINT "F1:Help   F2:Menu"END SUBSUB FKeysStopSHARED X153, Y46, Y56'        LINE (2, Y46)-(X153, Y56), 0, BF	FOR F = 1 TO 10: KEY(F) STOP: NEXT F: 'KEY(14) STOPEND SUBSUB GetScreenSHARED Scren#(), Xmax, Ymax	GET (0, 0)-(Xmax, Ymax), Scren#END SUBSUB HideCursor STATICSHARED inregs AS Registers, outregs AS Registers, CursorFlag, mMouse	IF NOT mMouse THEN EXIT SUB	inregs.ax = 2	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = CursorFlag - 1END SUBSUB LimitMouse (mXmin, mYmin, mXmax, mYmax) STATICSHARED inregs AS Registers, outregs AS Registers ' Limit Horizontal Motion	inregs.ax = 7	inregs.cx = mXmin    'Xo+2	inregs.dx = mXmax     'XH+2		  CALL INTERRUPT(&H33, inregs, outregs)'   Limit Vertical Motion	inregs.ax = 8	inregs.cx = mYmin   'Yv	inregs.dx = mYmax    'YMax-Y17	CALL INTERRUPT(&H33, inregs, outregs)END SUBSUB LineXor (Xa, Ya, Xb, Yb)EVENT OFF	: FKeysOff    IF Xa > Xb THEN STEPX = -6: STEP2X = -5 ELSE STEPX = 6: STEP2X = 5	IF Ya > Yb THEN STEPY = -3: STEP2Y = -4 ELSE STEPY = 3: STEP2Y = 4	: HideCursor	IF Yb = Ya THEN FOR Px = Xa TO Xb STEP STEPX: PSetXor Px, Yb: NEXT Px: ShowCursor: FKeysOn: EXIT SUB	IF Xb = Xa THEN FOR Py = Ya TO Yb STEP STEPY: PSetXor Xb, Py: NEXT Py: ShowCursor: FKeysOn: EXIT SUB	SLP! = (Yb - Ya) / (Xb - Xa)'***XOR line routine***	IF ABS(SLP!) < 1 THEN FOR Px = Xa TO Xb STEP STEP2X: PSetXor Px, (Ya + SLP! * (Px - Xa)): NEXT Px: ShowCursor: FKeysOn: EXIT SUB	SLP! = 1 / SLP!	FOR Py = Ya TO Yb STEP STEP2Y: PSetXor (Xa + SLP! * (Py - Ya)), Py: NEXT Py    : ShowCursor: FKeysOnEVENT ONEND SUB'***********************PrintText*************************SUB PrintText (TITLE$, Text$)'                       ***Reads text from disk and prints it***DIM line$(21, 15)EVENT OFF:SHARED ScNbr, DFct!, viewflag, CursorFlag, Xmax, Ymax, S()'  ,Scren#() ***Check this removal***SHARED Xo, X7, Yv, XH, Yo, K$, DownRt$, DownLft$, UpRt$, UpLft$: FKeysOff: ClearQeue'***deactivates the Fkeys, clears Queue***CR$ = CHR$(13): LF$ = CHR$(10)IF viewflag THEN VIEW '***if clipped, undoes clipping***CFlag = CursorFlag: IF CFlag = 0 THEN HideCursor 'if on, turn cursor offSCREEN 0:LineNumber = 1: PageNumber = 1: CharsRead = 0: LineLth = 0: SLth = 0: S$ = ""MaxLines = 21: CharBite = 200: LongestLine = 79OPEN Text$ FOR INPUT AS #1 LEN = 2048'        OPEN "d:Instruct.ncr" FOR INPUT AS #1 LEN = 2048FLength = LOF(1)DO WHILE CharsRead < FLength - CharBite    S$ = S$ + INPUT$(CharBite, #1):        'Read Charbite Chars, add to S$    SLth = SLth + CharBite:                'Increase length of S and    CharsRead = CharsRead + CharBite       'Characters read accordingly    GOSUB GetLines                         'Extract lines, add to Line$ arrayLOOPS$ = S$ + INPUT$(FLength - CharsRead - 1, #1): 'Get remaining Chars, add to S$SLth = SLth + FLength - CharsRead:  GOSUB GetLinesWHILE LEFT$(S$, 1) = LF$                   'Clean LF's from start of S$   SLth = SLth - 1: S$ = RIGHT$(S$, SLth)WENDline$(LineNumber, PageNumber) = S$         'Put last partial line into Line$LineNumber = LineNumber + 1WHILE LineNumber <= MaxLines   line$(LineNumber, PageNumber) = "":   'Blank out rest of last page   LineNumber = LineNumber + 1WENDMaxPage = PageNumber:PageNumber = 1:K$ = ""WHILE K$ <> "q" AND K$ <> "Q"   CLS : ClearQeue   IF PageNumber = 1 THEN      LOCATE 1, (40 - LEN(TITLE$) / 2): PRINT TITLE$:  '**centers title   ELSE      LOCATE 1, (33 - LEN(TITLE$) / 2): PRINT TITLE$ + "  ---  Page"; PageNumber: ' **centers title   END IF   LOCATE 3, 1   FOR LineNumber = 1 TO MaxLines      PRINT " " + line$(LineNumber, PageNumber)   NEXT LineNumber   h = 31: NXT$ = "": PREV$ = ""   IF PageNumber > 1 THEN PREV$ = " P for Previous page,": h = h - 11   IF PageNumber < MaxPage THEN NXT$ = " N for next page,": h = h - 9   LOCATE 25, h: PRINT "[Strike" + NXT$ + PREV$ + " Q to Quit.]";   WHILE K$ <> "q" AND K$ <> "Q" AND K$ <> "N" AND K$ <> "n" AND K$ <> "P" AND K$ <> "p" AND K$ <> UpRt$ AND K$ <> UpLft$ AND K$ <> DownRt$ AND K$ <> DownLft$      K$ = INKEY$   WEND   SELECT CASE K$      CASE "N", "n", DownRt$	 PageNumber = PageNumber + 1	 IF PageNumber > MaxPage THEN PageNumber = MaxPage: BEEP      CASE "P", "p", UpRt$	 PageNumber = PageNumber - 1	 IF PageNumber < 1 THEN PageNumber = 1: BEEP      CASE UpLft$	 PageNumber = 1      CASE DownLft$	 PageNumber = MaxPage   END SELECTWENDCLOSE : SCREEN S(ScNbr):: PutScreenIF viewflag THEN VIEW SCREEN (Xo, Yv - 3)-(XH + 10, Ymax - 9)'***restores clip*CALL FKeysOn   '***enables the function keys***: LimitMouse Xo + 2, Yv%, XH + 2, YmxMinus17%IF CFlag = 0 THEN   : LimitMouse X7, Yv, XH + 2, Ymax - 7   : SetCursorPosn ((Xo + Xmax) / 2), ((Yo + Yv) / 2)   : ShowCursorEND IFEVENT ONEXIT SUBGetLines:   LineLth = INSTR(S$, CR$) - 1   WHILE LineLth >= 0      IF LineLth > LongestLine THEN  'breaking at last space instead of CR	 K$ = "": Offset = LongestLine	 DO UNTIL K$ = " " OR Offset = 0	    K$ = MID$(S$, Offset, 1): Offset = Offset - 1	 LOOP	 IF Offset = 0 THEN LineLth = LongestLine ELSE LineLth = Offset      END IF      line$ = LEFT$(S$, LineLth):      LineTmp = LineLth    'Used in next two lines only      IF LEFT$(line$, 1) = LF$ THEN LineTmp = LineTmp - 1: line$ = RIGHT$(line$, LineTmp)      IF LEFT$(line$, 1) = " " THEN LineTmp = LineTmp - 1: line$ = RIGHT$(line$, LineTmp)      line$(LineNumber, PageNumber) = line$      LineNumber = LineNumber + 1      IF LineNumber > MaxLines THEN LineNumber = 1: PageNumber = PageNumber + 1      SLth = SLth - LineLth - 1: S$ = RIGHT$(S$, SLth)      LineLth = INSTR(S$, CR$) - 1:   WENDRETURN:END SUBSUB PSetXor (Px, Py) STATICEVENT OFFSHARED PCursr()'       IF POINT(PX, PY) = 0 THEN PSET (PX, PY) ELSE PRESET (PX, PY)	PUT (Px, Py), PCursrEVENT ONEND SUBSUB PutScreenSHARED Scren#()	PUT (0, 0), Scren#, PSET    'Should be (0,0)END SUBSUB ResetMouse STATICSHARED inregs AS Registers, outregs AS Registers, CursorFlag	inregs.ax = 0	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = -1'***Keeps track of visible (0) or invisible (not 0)***END SUBSUB SetCursorPosn (mXPosn, mYPosn) STATICSHARED inregs AS Registers, outregs AS Registers	inregs.ax = 4	inregs.cx = mXPosn	inregs.dx = mYPosn	CALL INTERRUPT(&H33, inregs, outregs)END SUBSUB ShowCursor STATICSHARED inregs AS Registers, outregs AS Registers, CursorFlag, mMouse	IF NOT mMouse THEN EXIT SUB	inregs.ax = 1	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = CursorFlag + 1END SUBSUB VMouse (M) STATIC:EVENT OFFSHARED K$, deltamax, DelX, XH, Xo, Xb, Yo, Yv, Ymax, Y17, Mouse(), CursrM(), ALIns, dsSHARED CR$, up$, down$, lft$, rght$, UpRt$, DownRt$, UpLft$, DownLft$ ', BSpace$SHARED ScrollUp, ScrollDown, BackSpace, mMouse, HandFlag, OldHandFlag'True, False, '***currently constants***SHARED inregs AS Registers, outregs AS Registers, MouseX, HandM, Bidr   M = 0: GOSUB checkshift   K$ = INKEY$: ShftFnKey = 0   EVENT ON   KEY(15) ON: KEY(16) ON: KEY(17) ON: KEY(18) ON:   TMse! = TIMER   WHILE K$ = "" AND TIMER >= TMse! AND TIMER < TMse! + .12      IF ShftFnKey = 0 THEN K$ = INKEY$   WEND   KEY(15) OFF: KEY(16) OFF: KEY(17) OFF: KEY(18) OFF: ' ShftFnKey = 0   EVENT OFF   IF mMouse THEN GOSUB MMouseSub: EXIT SUB   IF K$ <> "" THEN ds = ds + 1: 'IF ds > deltamax THEN ds = deltamax   delt = ds   SELECT CASE K$      CASE up$	 IF ScrollLock THEN	    ScrollUp = True	 ELSE	    IF dy < 0 THEN ds = 1	    dx = 0: dy = 1	 END IF      CASE "8"	 IF dy < 0 THEN ds = 1	 dx = 0: dy = 1: M = 1      CASE down$	 IF ScrollLock THEN	    ScrollDown = True	 ELSE	    IF dy > 0 THEN ds = 1	    dx = 0: dy = -1	 END IF      CASE "2"	 IF dy > 0 THEN ds = 1	 dx = 0: dy = -1: M = 1      CASE rght$	 IF dx < 0 THEN ds = 1	 dx = DelX: dy = 0      CASE "6"	 IF dx < 0 THEN ds = 1	 dx = DelX: dy = 0: M = 1      CASE lft$	 IF dx > 0 THEN ds = 1	 dx = -DelX: dy = 0      CASE "4"	 IF dx > 0 THEN ds = 1	 dx = -DelX: dy = 0: M = 1      CASE DownLft$	 IF dy > 0 OR dx > 0 THEN ds = 2	 dy = -1: dx = -DelX: delt = .7 * ds      CASE "1"	 IF dy > 0 OR dx > 0 THEN ds = 2	 dy = -1: dx = -DelX: delt = .7 * ds: M = 1      CASE UpRt$	 IF dy < 0 OR dx < 0 THEN ds = 2	 dy = 1: dx = DelX: delt = .7 * ds      CASE "9"	 IF dy < 0 OR dx < 0 THEN ds = 2	 dy = 1: dx = DelX: delt = .7 * ds: M = 1      CASE DownRt$	 IF dy > 0 OR dx < 0 THEN ds = 2	 dy = -1: dx = DelX: delt = .7 * ds      CASE "3"	 IF dy > 0 OR dx < 0 THEN ds = 2	 dy = -1: dx = DelX: delt = .7 * ds: M = 1      CASE UpLft$	 IF dy < 0 OR dx > 0 THEN ds = 2	 dy = 1: dx = -DelX: delt = .7 * ds      CASE "7"	 IF dy < 0 OR dx > 0 THEN ds = 2	 dy = 1: dx = -DelX: delt = .7 * ds: M = 1      CASE "5"	 ds = 0: dx = 0: dy = 0: M = 1      CASE "0"	 ds = 0: dx = 0: dy = 0: M = 1      CASE BSpace$	 BackSpace = True	 dx = 0: dy = 0: ds = 0      CASE ELSE	 IF K$ = CR$ THEN M = 2:	 ds = 0: delt = 0:   END SELECT      IF ScrollUp OR ScrollDown THEN TMse! = TIMER: EXIT SUB      FOR iMse = 0 TO delt	 PUT (Mouse(1), Mouse(2)), CursrM	 IF delt > 0 THEN Mouse(1) = Mouse(1) + dx: Mouse(2) = Mouse(2) - dy	 IF Mouse(1) > (XH + 2) THEN Mouse(1) = XH + 2	 IF Mouse(1) < Xo + 2 THEN Mouse(1) = Xo + 2	 IF Mouse(2) > Ymax - Y17 THEN Mouse(2) = Ymax - Y17	 IF Mouse(2) < Yv THEN Mouse(2) = Yv	 PUT (Mouse(1), Mouse(2)), CursrM, XOR      NEXT iMse      WHILE TIMER >= TMse! AND TIMER < TMse! + .1: WEND      TMse! = TIMER: ClearQeueEXIT SUBcheckshift:   inregs.ax = &H200: 'AH = 2   CALL INTERRUPT(&H16, inregs, outregs)   AL = outregs.ax AND &HFF   IF ((AL AND 1) = 1) OR ((AL AND 2) = 2) OR ((AL AND 64) = 64) OR ((AL AND 128) = ALIns) THEN      M = 1:   ELSE      M = 0   END IF   IF (AL AND 16) = 16 THEN      ScrollLock = True   ELSE      ScrollLock = False: ScrollUp = False: ScrollDown = False   END IFRETURNMMouseSub:   inregs.ax = 3   CALL INTERRUPT(&H33, inregs, outregs)   M = outregs.bx:   IF M > 2 THEN M = 2'***Left is 1, right is 2, both are 3***   Mouse(1) = outregs.cx: Mouse(2) = outregs.dx   IF NOT Bidr THEN RETURN  '***skip this for other two programs***   OldHandFlag = HandFlag:   IF Mouse(1) < (Xo + 2) THEN      MouseX = Mouse(1): Mouse(1) = Xo + 2:      HandFlag = -1     'Turn hand on      HandM = M: M = 0  'Tools ignore button out of tool region   ELSE      HandFlag = 0      'Hand is off   END IF   IF Mouse(2) > Yo THEN      M = 0   END IF   IF K$ = BSpace$ THEN BackSpace = True ELSE BackSpace = False   IF K$ = up$ THEN ScrollUp = True   IF K$ = down$ THEN ScrollDown = TrueRETURNEVENT ONEND SUB