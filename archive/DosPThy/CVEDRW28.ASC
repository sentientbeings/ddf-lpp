'     To Do'Too many hide/show cursors? Only when cursor already visible?'     Next Version'Mouse selection of alternativesDECLARE SUB Delay (YTime!)DECLARE SUB Axis (VLABEL$, VNUMBERRT!)DECLARE FUNCTION ChooseOne% (IMES%, STMES%, MESMAX%)DECLARE FUNCTION ChooseOneF% (NMesF%)DECLARE SUB ClearQeue ()DECLARE SUB FKeysOn ()DECLARE SUB FKeysOff ()DECLARE SUB GetScreen ()DECLARE SUB HideCursor ()DECLARE SUB LimitMouse (mXmin%, mYmin%, mXmax%, mYmax%)DECLARE SUB Message (MLeft%, N%)DECLARE SUB PrintText (TITLE$, Text$)DECLARE SUB PutScreen ()DECLARE SUB ResetMouse ()DECLARE SUB SetCursorPosn (mXPosn%, mYPosn%)DECLARE SUB ShowCursor ()DECLARE SUB VMouse (M%)DECLARE FUNCTION YesOrNo! (NMes%)TYPE Registersax AS INTEGERbx AS INTEGERcx AS INTEGERdx AS INTEGERbP AS INTEGERSI AS INTEGERDI AS INTEGERflags AS INTEGERds AS INTEGERes AS INTEGEREND TYPEDIM inregs AS Registers, outregs AS RegistersDECLARE SUB INTERRUPT (Intnum AS INTEGER, inregs AS Registers, outregs AS Registers)    '       *******CurveDraw Program V1.09PC********  '*********Copyright David Friedman, May 12, 1991*****************DEFINT A-X, Z:ScNbr = -1MainProgramCve:	DEF SEG = &H0	GOSUB ScreenType: GOSUB CheckForMouse:	GOSUB Initialize	'choice = 0: D1 = 1: PREFIX$ = "C"	GOSUB DefineFKeys: FKeysOn'  ***Defines and Activitates Function keys***Ouroboros: '***This Whole Fershlugginer program is one endless loop***	GOSUB ModuleChoiceM: GOSUB SetupMtext: GOSUB ChooseSome	FixedCost = 0: ON MCHOICE GOSUB SetupCost, SetupRevenue, SetupValue: GOSUB CDrawMain	GOTO OuroborosEND    '*******************************************************    '       ***Subroutines for the Main Program Start Here***    '****************************************************    '****************Initialize*************************EVENT OFFInitialize:	DIM y(710), Y1(710), Y2(710), Y3(710):	DIM Mouse(3)	DIM TEXTSCR$(7), Text$(10), TextF$(10), Scn$(6), ScNbr(6), S(7)	DIM STYLE(3), DFLAG(3), CMOD$(3), MTEXT$(5), PFIX$(3), c$(3, 3), NBR$(3)	CONST True = -1, False = 0, CveDraw = True, Bidr = False, DMV = False	KEY 15, CHR$(&H82) + CHR$(&H48): ON KEY(15) GOSUB ShftUp	KEY 16, CHR$(&H82) + CHR$(&H50): ON KEY(16) GOSUB ShftDown	KEY 17, CHR$(&H82) + CHR$(&H4B): ON KEY(17) GOSUB ShftLeft	KEY 18, CHR$(&H82) + CHR$(&H4D): ON KEY(18) GOSUB ShftRight	RESTORE NewData	FOR I = 1 TO 3: FOR j = 1 TO 3: READ c$(I, j): NEXT j: READ PFIX$(I): NEXT INewData:   DATA TC,MC,AC,C,TR,MR,D,R,TV,MV,AV,V	NBR$(1) = "1:": NBR$(2) = "2:": NBR$(3) = "3:"	STYLE(1) = &HFFFF: STYLE(2) = &HCCCC: STYLE(3) = &HAAAA'***Line patterns***	CMOD$(1) = "Cost": CMOD$(2) = "Revenue": CMOD$(3) = "Value"	FOR I = 1 TO 5: READ TEXTSCR$(I): NEXT I    DATA Mod,CChce,FCost,Draw,Revue	VNUMBERRT! = .5  '***MC and AC numbers***	Label$ = "Quantity": '***Setting**	delta = 1: deltamax = 10: dx = 0: dy = 0: RATE! = .04'      ***rate for dragging***	CR$ = CHR$(13): LF$ = CHR$(10)	upL$ = CHR$(24): downL$ = CHR$(25): leftL$ = CHR$(27)	up$ = CHR$(0) + CHR$(72): down$ = CHR$(0) + CHR$(80):	lft$ = CHR$(0) + CHR$(75): rght$ = CHR$(0) + CHR$(77)	UpRt$ = CHR$(0) + CHR$(73): DownRt$ = CHR$(0) + CHR$(81):	UpLft$ = CHR$(0) + CHR$(71): DownLft$ = CHR$(0) + CHR$(79)	BSpace$ = CHR$(8)	Scn$(0) = ":CGA      (640x200)": Scn$(1) = ":Hercules (720x348)"	Scn$(2) = ":DCGA     (640x400) Color"	Scn$(3) = ":EGA      (640x350) Mono+": Scn$(4) = ":EGA      (640x350) Color":	Scn$(5) = ":VGA/MCGA (640x480)": Scn$(6) = ":VGA      (640x480) Color":ReInitialize:	DIM Scren#(2025 * DFct!)  '***To Photo Screen requires ah compile option	DIM SCREEN2(400 * DFct!), SCREEN3(400 * DFct!)	DIM SPRKLR(40 * DFct!), CursrM(40 * DFct!)	GOSUB PutFKMenu	LINE (2, (4 + 3 * LtHt))-(3 + 14 * LtWd, Ymax - 2), , B:	LINE (3, 5 + 3 * LtHt)-(2 + 14 * LtWd, Ymax - 3), , B'***frames controls***	LINE (6 + 14 * LtWd, 4 + 3 * LtHt)-(Xmax - 1, Ymax - 2), , B:	LINE (7 + 14 * LtWd, 5 + 3 * LtHt)-(Xmax - 2, Ymax - 3), , B'***Graph area**	HScale = 6 * LtWd: VScale = 3 * LtHt: HNUMBER = 10: VNUMBER = 10'*axis parameters*	MCFACTOR! = VNUMBER * HScale / (VNUMBERRT! * HNUMBER)'***MC and AC scale***	choice = 0: D1 = 1: PREFIX$ = "C"RETURNCheckIns:	inregs.ax = &H200	CALL INTERRUPT(&H16, inregs, outregs)	AL = outregs.ax AND &HFF	ALIns = 128 - (AL AND 128)RETURN    '***********************************************************ShftUp:	K$ = up$: ShftFnKey = 1: M = 1:RETURNShftDown:	K$ = down$: ShftFnKey = 1:  M = 1RETURNShftRight:K$ = rght$: ShftFnKey = 1: M = 1RETURNShftLeft:K$ = lft$: ShftFnKey = 1: M = 1RETURNPutFKMenu:   LOCATE 5, 2: PRINT "F1:Help": LOCATE 6, 2: PRINT "F2:Menu"RETURNClearFKMenu:   LOCATE 5, 2: PRINT "       ": LOCATE 6, 2: PRINT "       "RETURNEVENT ONEVENT OFFControl:	: FKeysOff: ' GOSUB ClearFKMenu    '***deactivates function keys. Erase F1,F2***	NMesF = 5	TextF$(0) = "1:Quit": TextF$(1) = "2:Start Over"	TextF$(2) = "3:Change Programs": TextF$(3) = "4:Change Graphics": TextF$(4) = "":	TextF$(5) = "0:Cancel":	IF GrModesNbr = 1 THEN TextF$(3) = "": TextF$(4) = "0:Cancel": NMesF = 4	ChoiceF = ChooseOneF(NMesF)	ON ChoiceF GOSUB Quit, StartOver, ChangeProgram, ChangeGraphics	'GOSUB PutFKMenu:	FKeysOn         '***reactivates function keys***RETURN  '***Goes to a selection on Main Menu***HelpMenu:	: FKeysOff  '***deactivates function keys***	TextF$(0) = "1:Instructions": TextF$(1) = "2:Help"	TextF$(2) = "3:Controls": TextF$(3) = "4:Projects": TextF$(4) = ""	TextF$(5) = "0:Cancel":	ON ChooseOneF(5) GOSUB Instruction, HELP, Controls, PROJECTS	: FKeysOn  '***reactivates function keys***RETURN    '**********************************************************    '**************These are the Alternatives on the Help Menu*********Instruction:	CALL PrintText("Instructions", "instruct.cve")RETURNHELP:	CALL PrintText("Help", PREFIX$ + "H" + TEXTSCR$(D1) + ".cve")RETURNControls:	CALL PrintText("Controls", "controls.cve")RETURNPROJECTS:	CALL PrintText("Projects", PREFIX$ + "Prjcts.cve")RETURNEVENT ONEVENT OFF    '************************************************************    '************These Are the Alternatives on the Main Menu*************ChangeProgram:	RUN "control.exe"RETURNStartOver:	RUNRETURNQuit:	ENDRETURNChangeGraphics:	GOSUB EraseWarning: IF YNFlag = 0 THEN RETURN ELSE PutScreen	CALL FKeysOff   '***deactivates function keys***	FOR iGr = 0 TO GrModesNbr - 1		TextF$(iGr) = STR$(iGr + 1) + Scn$(ScNbr(iGr))		IF ScNbr(iGr) = ScNbr THEN Select$ = STR$(iGr + 1): TextF$(iGr) = TextF$(iGr) + " (X)"	NEXT iGr	TextF$(GrModesNbr) = "":	TextF$(GrModesNbr + 1) = "Option" + Select$ + " is currently selected."	ChoiceF = ChooseOneF(GrModesNbr + 1)	IF ScNbr(ChoiceF - 1) = ScNbr THEN RETURN'***This is the old Bidr version, which should work***	ON ScNbr(ChoiceF - 1) GOSUB Scn3, Scn4, Scn10, Scn9, Scn11, Scn12	GOSUB Scn2	RETURNEraseWarning: '***warns that changing graphics erases everything***	: PutScreen	LINE (XWa, aYWa + Y16)-(XWb - X16, aYWa + Y86), 0, BF'***erases message area***	LINE (XWa, aYWa + Y16)-(XWb - X16, aYWa + Y86), , B'***boxes message area***	XSTART = (XWa / LtWd) + 2: YSTART = (aYWa / LtHt) + 3.5: XCTR = (XWa + XWb - X16) / (2 * LtWd) - 3	: ClearQeue	LOCATE YSTART, XCTR: PRINT "WARNING";	LOCATE YSTART + 2, XSTART: PRINT "Making this change will erase";	LOCATE YSTART + 3, XSTART: PRINT "what you have done so far.";	LOCATE YSTART + 6, XSTART: PRINT "Is this what you want?(Y/N)";	LOCATE YSTART + 7, XSTART: T$ = "(strike Y for yes, N for no)": PRINT T$;EVENT ONChangeYN:	YN$ = "": WHILE YN$ = "": YN$ = INKEY$: WEND	IF YN$ = "Y" OR YN$ = "y" THEN YNFlag = -1: RETURN	IF YN$ = "N" OR YN$ = "n" THEN YNFlag = 0: PutScreen: RETURN	BEEP: LOCATE YSTART + 7, XSTART: PRINT "!" + T$ + "!";	I! = TIMER: WHILE (TIMER < I! + 1) AND (TIMER >= I!): WEND'***delay***	LOCATE YSTART + 7, XSTART: PRINT SPACE$(32)	GOTO ChangeYNEVENT OFFScn2: RUN 42: RETURNScn3: RUN 43: RETURNScn4: RUN 44: RETURNScn9: RUN 49: RETURNScn10: RUN 50: RETURNScn11: RUN 51: RETURNScn12: RUN 52: RETURN42 : ScNbr = 0: GOTO MainProgramCve43 : ScNbr = 1:  GOTO MainProgramCve44 : ScNbr = 2:  GOTO MainProgramCve49 : ScNbr = 4:  GOTO MainProgramCve50 : ScNbr = 3:  GOTO MainProgramCve51 : ScNbr = 5:  GOTO MainProgramCve52 : ScNbr = 6:  GOTO MainProgramCve    '**********************************************************ModuleChoiceM:  '**This sets up the module choice menu*********	D1 = 1  '***Changes help screen***	GOSUB EraseLCtrlA              '***erases screen***	LOCATE 8, 2: PRINT "Which kind of": LOCATE 9, 2: PRINT "curves do you"	LOCATE 10, 2: PRINT "wish to draw?"	Text$(0) = "1:Cost": Text$(1) = "2:Revenue"	Text$(2) = "3:Value": MCHOICE = ChooseOne(2, 3, 3):	PREFIX$ = PFIX$(MCHOICE)	D1 = 2   '***Changes Help Screen***	GOSUB EraseLCtrlA: LOCATE 9, 2: PRINT "Which do you"   'erases lower control area	LOCATE 10, 2: PRINT "wish to draw?": IMES = 1: MESMAX = 2	FOR I = 1 TO 3: Text$(I - 1) = NBR$(I) + c$(MCHOICE, I): NEXT I	IF MCHOICE = 3 THEN IMES = 1: MESMAX = 2 ELSE IMES = 2: MESMAX = 3	choice = ChooseOne(IMES, 3, MESMAX): CCHOICE = choice: CVNAME$ = MTEXT$(CCHOICE)	GOSUB EraseLCtrlA              '***erases screen***RETURN: '******************************************************************ChooseSome: '***Multiple selection subroutine***	GOSUB EraseLCtrlA  'erases control area	FOR I = 1 TO 3: DFLAG(I) = 0: NEXT I'zeros draw flags	LOCATE 8, 2: PRINT "Which shall": LOCATE 9, 2: PRINT "I draw?"	: ClearQeue                          '***clears keyboard queue***	IEND = 10 + IMES: MTEXT$(IMES) = ""	LOCATE 1, 80: PRINT "X": GET (Xmax + 1 - LtWd, 0)-(Xmax, LtHt - 1), SCREEN3'***Get Y mark	LINE (Xmax + 1 - LtWd, 0)-(Xmax, LtHt - 1), 0, BF'***Remove the evidence***	FOR I = 0 TO IMES: LOCATE 11 + I, 3: PRINT MTEXT$(I): NEXT I	LOCATE IEND + 2, 2: PRINT "Choose which": LOCATE IEND + 3, 2	PRINT "you want.": LOCATE IEND + 5, 2: PRINT "<ENTER> when"	LOCATE IEND + 6, 2: PRINT "done."	LINE (2 + 14 * LtWd, 4 + 3 * LtHt)-(3 + 14 * LtWd, Ymax - 2), , B: LINE (6 + 14 * LtWd, 4 + 3 * LtHt)-(7 + 14 * LtWd, Ymax - 2), , B	choice = -1: K$ = ""'***setting up for selection***EVENT ON	WHILE K$ <> CR$		K$ = "": WHILE K$ = "": K$ = INKEY$: WEND		choice = VAL(K$)		TEST = (choice = 0) OR (choice > MESMAX)		IF TEST THEN choice = -1		IF choice > 0 THEN GOSUB SelectOrDe	WEND	GOSUB EraseLCtrlA: '***clears control area***RETURN     '***Filters out wrong key presses***	Text$(0) = "Press a number key from 1 to " + STR$(MESMAX) + "select or"	Text$(0) = Text$(0) + "deselect an alternative."	Text$(1) = "Press return when you are done."	CALL Message(1, 2): choice = -1RETURNSelectOrDe: '***Selects or deselects an alternative***	YHT = (9 + choice) * LtHt: YBT = YHT + LtHt - 1	IF DFLAG(choice) THEN LINE (LtWd, YHT)-(2 * LtWd - 1, YBT), 0, BF ELSE PUT (LtWd, YHT), SCREEN3	IF DFLAG(choice) THEN DFLAG(choice) = 0 ELSE DFLAG(choice) = -1RETURNEVENT OFF     '*******************************************************************SetupCost: '***Setup for cost curves***	IF CCHOICE = 1 THEN DFLAG(3) = DFLAG(2): DFLAG(2) = DFLAG(1)	IF CCHOICE = 2 THEN DFLAG(3) = DFLAG(2)	DFLAG(CCHOICE) = -1	VLABEL$ = "TC": VLABELRT$ = "MC AC"	GOSUB FixedCostSub       '***sets fixed cost***RETURNSetupRevenue: '***Setup for Revenue curves***	IF CCHOICE = 1 THEN DFLAG(3) = DFLAG(2): DFLAG(2) = DFLAG(1)	IF CCHOICE = 2 THEN DFLAG(3) = DFLAG(2)	DFLAG(CCHOICE) = -1: VLABEL$ = "TR": VLABELRT$ = "MR P"RETURNSetupValue:   '***Setup for value curves***	IF CCHOICE = 1 THEN DFLAG(2) = DFLAG(1)	DFLAG(3) = 0: DFLAG(CCHOICE) = -1	VLABEL$ = "TV": VLABELRT$ = " MV"RETURN	'**************************************************************SetupMtext:  'sets up Mtext$***	IF CCHOICE = 1 THEN K = 2 ELSE K = 1	FOR I = 1 TO 2		MTEXT$(I - 1) = NBR$(I) + c$(MCHOICE, K): K = K + 1		IF CCHOICE = K THEN K = K + 1	NEXT I	STMES = 8: IF MCHOICE = 3 THEN MESMAX = 1: IMES = 1 ELSE MESMAX = 2: IMES = 2RETURNEVENT ON     '*************************************************************CDrawMain: ' ********Main curve drawing program*****	D1 = 4                                '***changes help screen***	GOSUB SparklerInit: '    Sets colored sparkler and colored cursor	CALL Axis(VLABEL$, VNUMBERRT!)'***draws axis***	GOSUB CheckIns '***Checks the insert key	GOSUB LineDisplay: GOSUB MakeCurve      '***This is it--the actual curve drawing***	IF Abort = 1 THEN GOSUB EraseDrawA: RETURN	GOSUB LabelCvesSeeDif:  Text$(0) = "Do you want to see a different selection of the curves?"	Text$(1) = "Answer yes or no (y/n).": NMes = 2: MLeft = 10	CALL Message(MLeft, NMes): ClearQeue                 '***clears keyboard queue, prints message	D1 = 5                                '***changes help screen***	YESNO = YesOrNo(2): GOSUB EraseMsge     '***gets yes or no, clears message area***	IF YESNO = 2 THEN GOSUB EraseDrawA: RETURN	CALL Axis(VLABEL$, VNUMBERRT!)'***redraws the axis***	FOR I = 1 TO 3: MTEXT$(I - 1) = NBR$(I) + c$(MCHOICE, I): NEXT I	IMES = 3 + (MCHOICE = 3): MESMAX = IMES: GOSUB ChooseSome'***chooses lines to redraw	VIEW SCREEN (Xo, Yv)-(XH + 10, Ymax - 9)'***clips drawing***	IF DFLAG(1) THEN GOSUB DrawTotal	IF DFLAG(2) THEN GOSUB DrawMarginal	IF DFLAG(3) THEN GOSUB DrawAvge	VIEW: GOSUB LabelCves: GOSUB LineDisplay'**unclips, labels curves, shows line types	GOTO SeeDif '***loops back to look at another selection***     '************************************************************     '************************************************************EVENT OFFDrawTotal:  'Draws Total curve	FOR I = Xo + 4 TO Xmx STEP 4		LINE (I - 4, Y1(I - 4))-(I, Y1(I)), 1, , STYLE(1)	NEXT IRETURNDrawMarginal: 'Draws Marginal curve	FOR I = Xo + 4 TO Xmx STEP 4		LINE (I - 4, Y2(I - 4))-(I, Y2(I)), 2, , STYLE(2)	NEXT IRETURNDrawAvge: 'Draws Average curve	FOR I = Xo TO Xmx - 1 STEP 2		PSET (I, Y3(I)), 3	NEXT IRETURN     '**************************************************************LabelCves: 'Labels all curves	Text$ = c$(MCHOICE, 1): XLBL = Xo + 1: YLBL = Y1(XLBL): GOSUB ClipLabel	IF DFLAG(1) THEN GOSUB Label                    '***Labels y1	Text$ = c$(MCHOICE, 2): XLBL = (Xo + Xmx) / 2: YLBL = Y2(XLBL): GOSUB ClipLabel	IF DFLAG(2) THEN GOSUB Label '                   ***labels y2	Text$ = c$(MCHOICE, 3): XLBL = Xmx - 1: YLBL = Y3(XLBL): GOSUB ClipLabel	IF DFLAG(3) THEN GOSUB Label                    '***labels y3**	RETURNClipLabel:  'clips labelling	IF YLBL < Yv THEN YLBL = Yv ELSE IF YLBL > Ymax - (LtHt + 10) THEN YLBL = Ymax - 9 - (LtHt + 1)RETURN     '********************Clear Screen Subroutines*******************EraseMsge:   'erases message area	LINE (0, 0)-(XH, 3 * LtHt - 1), 0, BFRETURNEraseDrawA:  'erases drawing area	LINE (15 * LtWd, (3 * LtHt) + 5)-(Xmax - 3, Ymax - 4), 0, BF	GOSUB EraseMsgeRETURNEraseLCtrlA: 'erases lower control area	LINE (LtWd, 6 * LtHt + 1)-(1 + 14 * LtWd, Ymax - 4), 0, BFRETURN     '****************************************************************     '****************************************************************LineDisplay: 'Displays the different kinds of line	FOR K = 1 TO 3		YLN = (7 + 3 * K) * LtHt + 2: LOCATE 7 + 3 * K, 7		IF DFLAG(K) THEN PRINT c$(MCHOICE, K)		LINE (LtWd, YLN)-(4 + 13 * LtWd, YLN), K, , STYLE(K)	NEXT KRETURNEVENT ON     '****************************************************************FixedCostSub: 'FixedCost:		D1 = 3'***Change Help Screen***	cwt! = .2:		S$ = "####": LOCATE 24, 5: PRINT USING S$; FixedCost;	  LOCATE 22, 7: PRINT "FC"; : LINE (4 * LtWd - 2, 23 * LtHt - 2)-(9 * LtWd + 4, 24 * LtHt + 2), , B		'IF IQ > 0 AND MCHOICE <> 3 THEN RETURN	Text$(0) = "You must now set fixed cost. Press " + upL$ + " to increase it,"	Text$(1) = downL$ + " key to decrease it. Press <ENTER> when satisfied."	  CALL Message(2, 2): ClearQeue	WHILE K$ <> CR$:	FixedCost = FixedCost - (K$ = up$) + (K$ = down$)	IF FixedCost > 40 THEN FixedCost = 40	IF FixedCost < -20 THEN FixedCost = -20	LOCATE 24, 5: PRINT USING S$; FixedCost; : LINE (4 * LtWd - 2, 23 * LtHt - 2)-(9 * LtWd + 4, 24 * LtHt + 2), , B		GOSUB FCDelay'**accelerating delay***	WENDRETURNScreenType:	j = 0: S(0) = 2: S(1) = 3: S(2) = 4: S(3) = 10:	S(4) = 9: S(5) = 11: S(6) = 12: S(7) = 0EVENT ONON ERROR GOTO wrongscreen	FOR I = 0 TO 6		SCREEN S(I)		IF I < 7 THEN ScNbr(j) = I: j = j + 1:	NEXT ION ERROR GOTO 0EVENT OFF	IF j = 0 THEN		SCREEN 0		CLS : LOCATE 20, 10: PRINT "This Machine Has No Graphics Capability"		LOCATE 20, 12: PRINT " and Therefor Cannot Run this Software,"		LOCATE 20, 14: PRINT "   since it requires at least CGA"		END	ELSE		GrModesNbr = j:  'Number of graphics modes this computer supports	END IF	IF ScNbr = -1 THEN ScNbr = ScNbr(j - 1)	Xo = 168: Xmax = 639: W = 25: LtWd = 8	SELECT CASE S(ScNbr):   '***Assigns parameters according to the screen***		CASE 2			Ymax = 199: DelX = 2: LtHt = 8: SNumber = 1: : DFct! = 1:		CASE 3			Xo = 189: Ymax = 347: Xmax = 719: DelX = 2: LtHt = 14: LtWd = 9: SNumber = 2: DFct! = 1.96:		CASE 4			Ymax = 399: DelX = 1: LtHt = 16: SNumber = 3: DFct! = 2		CASE 9 TO 10			Ymax = 349: DelX = 1: LtHt = 14: SNumber = 3: DFct! = 7			IF S(ScNbr) = 10 THEN SNumber = 4: DFct! = 3.5:		CASE 11 TO 12			Ymax = 479: DelX = 1: LtHt = 16: SNumber = 5: DFct! = 2.4: W = 30			IF S(ScNbr) = 12 THEN SNumber = 6: DFct! = 9.6:		CASE ELSE			CLS : BEEP: PRINT "OOPS"	END SELECT	XH = Xmax - (7 * LtWd - 1): Yo = 17.5 * LtHt - 2: Yv = 5 * LtHt: W = 25:	X16 = 2 * LtWd: X86 = 11 * LtWd - 2	Y16 = 2 * LtHt: Y17 = 2 * LtHt + 1: Y86 = 11 * LtHt - 2	IF S(ScNbr) > 10 THEN Yo = Yo + 3 * LtHt	'IF S(ScNbr) = 11 THEN PALETTE 1, 4144959:	'WIDTH , W: CLS :	SCREEN S(ScNbr):RETURNwrongscreen:	I = I + 1RESUMECheckForMouse:	mMouse = 0	MSEG = 256 * PEEK(51 * 4 + 3) + PEEK(51 * 4 + 2)	MOUSE1 = 256 * PEEK(51 * 4 + 1) + PEEK(51 * 4) + 2	IF MSEG OR (MOUSE1 - 2) THEN			DEF SEG = MSEG		IF PEEK(MOUSE1 - 2) <> 207 THEN			mMouse = -1:			: ResetMouse: Yv% = Yv: YmxMinus17% = Ymax - Y17			: LimitMouse Xo + 2, Yv%, XH + 2, YmxMinus17%'***Check that limits are right for this program***			: SetCursorPosn ((Xo + Xmax) / 2), ((Yo + Yv) / 2)		END IF	END IFRETURNEVENT ONEVENT OFF     '*****************This Starts the Subprograms*******************     '**********************************************************     '***********************Label****************************Label: 'SUB Label(Text$,x,y,font,size,face)STATIC	L = LEN(Text$): XRT = (L + 74) * LtWd: LOCATE 3, 75: PRINT Text$	GET (74 * LtWd - 1, 2 * LtHt - 1)-(XRT, 3 * LtHt - 1), SCREEN2'***photo label***	LINE (74 * LtWd, 2 * LtHt)-(XRT, 3 * LtHt - 1), 0, BF	PUT (XLBL, YLBL - LtHt / 2 - 1), SCREEN2, PSET	LINE (XLBL - 2, YLBL - 2 - LtHt / 2)-(XLBL + LtWd * L + 2, YLBL + LtHt / 2), , BRETURN	'**********************************************************     '***********************Make3Curves*************************     '*** Uses mouse to draw y1,y2,y3=Total,Marginal,Average****MakeCurve:	CVNAME$ = c$(MCHOICE, CCHOICE)	IF mMouse THEN		Text$(0) = "Draw " + CVNAME$ + " by pressing the left mouse button;"		Text$(1) = "the curve will grow towards the cursor. Press "		Text$(2) = "the right mouse button when you are finished."	ELSE		Text$(0) = "Draw " + CVNAME$ + " by pressing Shift or Insert; the curve will grow"		Text$(1) = "towards the cursor. Move the cursor with the cursor keys."		Text$(2) = "Press <ENTER> when you are finished."	END IF	CALL Message(2, 3)	M = 0: D = 0: GOSUB Cursorinit: GOSUB PutMouseEVENT ON	WHILE M = 0'***button is up***		VMouse M:	WENDEVENT OFF	Abort = 0: IF M = 2 THEN Abort = 1: RETURN	ViewFlag = -1: VIEW SCREEN (Xo, Yv - 3)-(XH + 10, Ymax - 9)	Yv% = Yv	GOSUB StartCurve: GOSUB CurveDraw:	GOSUB PutMouse	CALL Message(MLeft, 0)	VIEW: ViewFlag = 0: VIEWRETURNStartCurve:	x = Xo: FC = Yo - FixedCost * VScale / VNUMBER: M = 0	IF CCHOICE = 1 THEN y(Xo) = FC ELSE y(Xo) = Mouse(2)'***sets y intercept	IF CCHOICE = 1 THEN Y2(Xo) = Yo + (Mouse(2) - FC) * MCFACTOR! / (Mouse(1) - Xo)	 Y1(Xo) = FC: Y3(Xo) = Yo - 200 * SGN(FixedCost)	IF CCHOICE = 2 THEN Y2(Xo) = y(Xo)	IF FixedCost = 0 AND CCHOICE = 3 THEN Y3(Xo) = Mouse(2)	IF CCHOICE = 3 THEN y(Xo) = Y3(Xo): GOSUB SetMCof0	y = y(Xo): Y1! = FC: Y1(Xo) = Y1!	TEST = y(Xo) < Ymax - 12 AND y(Xo) > Yv	IF TEST THEN PUT (Xo, y(Xo) - 2), SPRKLR'***initial sparkle***RETURNCurveDraw:	WHILE M <> 2    '***Start of Outer Loop***		WHILE M = 0'***button is up***			VMouse M:			TEST = y(Xo) < Ymax - 12 AND y(Xo) > Yv			IF TEST THEN PUT (x, y(x) - 2), SPRKLR: PUT (x, y(x) - 2), SPRKLR '***Needs HideCursor?*		WEND		WHILE M = 1       '***Button Down***			VMouse M: MX = Mouse(1): MY = Mouse(2)			DELTAX! = MX - x: DELTAY! = MY - y			TEST = DELTAX! > 5 AND (DELTAY! >= 0 OR MCHOICE <> 2 OR CCHOICE <> 3)			IF TEST THEN GOSUB ExtendLine3		WEND	WEND  '***end of outer loop***	Xmx = xRETURN     '**********************************************************ExtendLine3:	increment = ABS(DELTAX!) * RATE!: IF increment = 0 THEN RETURN	increment = 4 * increment     ' !!!!test change	XOLD = x: XOLDP = x + 1: YOLD = y	FOR I = 0 TO increment		x = x + 1: y = y + (DELTAY! / DELTAX!)	  TEST = (x > XH)		IF TEST THEN x = x - 1: y = y(x): I = increment ELSE y(x) = y	NEXT I '***Calculate next point***		IF x <> XOLD THEN ON CCHOICE GOSUB TCDraw, MCDraw, ACDraw ELSE RETURN	: HideCursor	FOR I = XOLDP TO x		IF y(I - 1) < Ymax - 12 AND y(I - 1) > Yv THEN PUT (I - 1, y(I - 1) - 2), SPRKLR	  IF y(I) < Ymax - 12 AND y(I) > Yv THEN PUT (I, y(I) - 2), SPRKLR	NEXT I	FOR I = XOLD TO x - 3 STEP 4		IRT = I + 4		IF DFLAG(1) THEN LINE (I, Y1(I))-(IRT, Y1(IRT)), 1, , STYLE(1)		IF DFLAG(2) THEN LINE (I, Y2(I))-(IRT, Y2(IRT)), 2, , STYLE(2)	NEXT I	IF DFLAG(3) THEN FOR I = XOLDP TO x STEP 2: PSET (I, Y3(I)), 3: NEXT I	: ShowCursorRETURNEVENT ONEVENT OFFTCDraw:	FOR I = XOLDP TO x		Y1(I) = y(I): Y3(I) = Yo + MCFACTOR! * (y(I) - Yo) / (I - Xo)	NEXT I	Y2! = Yo + DELTAY! * MCFACTOR! / DELTAX!	FOR I = XOLD + 1 TO x: Y2(I) = Y2!: NEXT IRETURNMCDraw:	FOR I = XOLD + 1 TO x		Y1! = Y1! - (Yo - y(I)) / MCFACTOR!: Y1(I) = Y1!: Y2(I) = y(I)		Y3(I) = Yo + MCFACTOR! * (Y1(I) - Yo) / (I - Xo)	NEXT IRETURNACDraw:	FOR I = XOLD + 1 TO x		Y1(I) = Yo - ((Yo - y(I)) * (I - Xo) / MCFACTOR!): Y3(I) = y(I)	NEXT I	Y2! = Yo + ((Yo - YOLD) * (XOLD - Xo) - (Yo - y) * (x - Xo)) / (x - XOLD)	Y2(x) = Y2!	IF XOLD = Xo THEN FOR I = XOLD TO x: Y2(I) = Y2(x): NEXT I: RETURN	SLOPE! = (Y2(x) - Y2(XOLD)) / (x - XOLD): Y2! = Y2(XOLD)	FOR I = XOLDP TO x: Y2! = Y2! + SLOPE!: Y2(I) = Y2!: NEXT IRETURNSetMCof0:   'Sets MC(0) if we are drawing AC	IF FixedCost = 0 THEN Y2(Xo) = ((Mouse(2) - FC) / (Mouse(1) - Xo)) + Yo: RETURN	SLOPE! = (Mouse(2) - Y3(Xo)) / (Mouse(1) - Xo - 1)	Y2(Xo) = Y3(Xo) + 2 * SLOPE!RETURN     '*******************************************EVENT ON'    4660   ???DefineFKeys: 'Defines function keys	ON KEY(1) GOSUB HelpMenu: ON KEY(2) GOSUB Control    ':ON KEY(10) GOSUB    '*******************************************RETURNEVENT OFF     '************************PutMouse: '***start and end icon to scrn***	IF mMouse THEN		IF CursorFlag = -1 THEN ShowCursor ELSE HideCursor		IF (CursorFlag < -1) OR (CursorFlag > 0) THEN BEEP: CLS : PRINT "CursorFlag"; CursorFlag: END	ELSE		PUT (Mouse(1), Mouse(2)), CursrM:	END IFRETURNCursorinit:	IF mMouse THEN		: SetCursorPosn Xo + 4 + 2 * LtWd, 25 * LtHt / 2	ELSE		Mouse(1) = Xo + 4 + 2 * LtWd: Mouse(2) = 25 * LtHt / 2'***sets initial cursor position	END IF	'cwt! = .2: T! = TIMER: TPlus! = T! + cwt!RETURNSparklerInit:    'defines sparkler to mark line being drawn	LINE (620, 5)-(626, 5), CCHOICE: LINE (621, 3)-(625, 7), CCHOICE	LINE (621, 7)-(625, 3), CCHOICE	GET (620, 3)-(626, 7), SPRKLR: LINE (620, 3)-(626, 7), 0, BF	IF NOT mMouse THEN		SELECT CASE S(ScNbr)   'Drawing Cursor			CASE 2 TO 3				IF CCHOICE = 1 THEN DRAW "bm200,100 C1 H1 L1 H1 L1 H1 L1 H1 D3 U3 R7"				IF CCHOICE = 2 THEN DRAW "bm200,100 C2 H1 L1 H1 L1 H1 L1 H1 D3 U3 R7"				IF CCHOICE = 3 THEN DRAW "bm200,100 C3 H1 L1 H1 L1 H1 L1 H1 D3 U3 R7"			CASE 9 TO 12				IF CCHOICE = 1 THEN DRAW "bm200,100 C1 h5 d3 u3 r3"				IF CCHOICE = 2 THEN DRAW "bm200,100 C2 h5 d3 u3 r3"				IF CCHOICE = 3 THEN DRAW "bm200,100 C3 h5 d3 u3 r3"			CASE ELSE				CLS : LOCATE 20, 10: PRINT "what screen? ScNbr is "; ScNbr: END		END SELECT		GET (193, 93)-(200, 100), CursrM: LINE (192, 92)-(201, 101), 0, BF	END IFRETURNEVENT ONFCDelay:  'This is the Fixed Cost delay routine--accelerating	TPlus! = TPlus! + cwt! '***cwt is current waiting time***	T! = TIMER: TCT! = TIMER: K$ = ""	WHILE (TCT! >= T!) AND (TCT! < (T! + cwt!))		TCT! = TIMER		fk$ = INKEY$		IF fk$ <> "" THEN K$ = fk$	WEND	IF cwt! > .1 THEN cwt! = cwt! - .02 ELSE cwt! = .1	IF K$ = "" THEN cwt! = .2: ' T! = TIMER:RETURNEVENT OFFEVENT ON  '***Draws axis; (xo,yo) is origin. HScale is  dots per***  '***mark, Hnumber the number by which each mark increments quantity.****SUB Axis (VLABEL$, VNUMBERRT!)EVENT OFFSHARED VLABELRT$, LtHt, LtWd, Ymax, Xmax, Scren#(), Xo, Yo, XH, Yv, HScale, VScale, HNUMBER, VNUMBER	LINE (15 * LtWd, (3 * LtHt) + 6)-(Xmax - 3, Ymax - 4), 0, BF	NHORIZ = (XH - Xo) / HScale: NVert = (Yo - Yv) / VScale:	XSCALE = Xo - LtWd: YScale = Yo + 4: XSCALE2 = Xo - 3: YSCALE2 = Yo - 4	XSCALE3 = XH + 3: XSCALE4 = XH + LtWd: NVertD = (Ymax - (3.5 * LtHt + Yo)) / VScale	y = Yo + NVertD * VScale: x = Xo + HScale'        ***Next four lines draw and label the marks on the axes****	FOR I = -NVertD TO NVert		LOCATE (y / LtHt) + 1, (XSCALE / LtWd) - 3:		PRINT USING "###"; VNUMBER * I; : LINE (XSCALE, y)-(XSCALE2, y + 1), , B:		IF VNUMBERRT! > 0 THEN			LOCATE (y / LtHt) + 1, 2 + XSCALE4 / LtWd:			PRINT USING "##.#"; VNUMBERRT! * I; :			LINE (XSCALE3, y)-(XSCALE4, y + 1), , B		END IF		y = y - VScale	NEXT I	y = Yo + VScale: LINE (XSCALE, y)-(XSCALE2, y + 1), , B	FOR I = 1 TO NHORIZ - 1		LOCATE 19, (x - LtWd) / LtWd: PRINT HNUMBER * I;		LINE (x, YScale)-(x - 1, YSCALE2), , B: x = x + HScale	NEXT I	GET (Xo + HScale - LtWd, 18 * LtHt)-(x - HScale + LtWd, 19 * LtHt), Scren#	LINE (Xo + HScale - LtWd, 18 * LtHt)-(x - HScale + LtWd + 1, 19 * LtHt), 0, BF	PUT (Xo + HScale - LtWd, Yo + 5), Scren#	LINE (Xo - 3, Yv)-(Xo, Yo + 2 * LtHt + NVertD * VScale), 1, BF	LINE (Xo, Yo)-(XH, Yo + 1), , B'**Draws Axes***	IF VNUMBERRT! > 0 THEN		LINE (XH, Yv)-(XH + 3, Yo + 2 * LtHt + NVertD * VScale), 3, BF'***draws RH axis***		LOCATE Yv / LtHt, (XH - LtWd + 3) / LtWd: PRINT VLABELRT$;	END IF     '              *** Next lines label the axes***	LOCATE (Yo - 3) / LtHt, (Xo + XH) / (2 * LtWd) - 2: PRINT "Quantity";	LOCATE Yv / LtHt, (Xo / LtWd): PRINT VLABEL$;EVENT ONEND SUBFUNCTION ChooseOne (IMES, STMES, MESMAX) : ' ****Message and choice Function***EVENT OFFSHARED LtWd, LtHt, Text$(), Ymax, CursorFlag, SCREEN3()	: ClearQeue:	CFlag = CursorFlag: IF CFlag = 0 THEN HideCursor                '***clears keyboard queue***	LINE (LtWd, (9 + STMES) * LtHt)-(1 + 13 * LtWd, 20 * LtHt), 0, BF'***Erases the message area***	IEND = 9 + IMES + STMES: IF (IEND > 17) THEN GET (LtWd, 20 * LtHt - 3)-(105, Ymax - 8), SCREEN3	FOR I = 0 TO IMES: LOCATE 9 + I + STMES, 2: PRINT Text$(I): NEXT I	LOCATE IEND + 2, 2: PRINT "Select one.": LOCATE IEND + 3, 2: PRINT "Use number"	LOCATE IEND + 4, 2: PRINT "(Not F#) key"	LINE (2 + 14 * LtWd, 4 + 3 * LtHt)-(3 + 14 * LtWd, Ymax - 2), , B	LINE (6 + 14 * LtWd, 4 + 3 * LtHt)-(7 + 14 * LtWd, Ymax - 2), , BEVENT ON	choice = 0:	WHILE choice = 0 OR choice > MESMAX: choice = VAL(INKEY$): WEND	: ChooseOne = choice	IF IEND > 17 THEN PUT (LtWd, 20 * LtHt - 3), SCREEN3	LINE (LtWd, 11 * LtHt)-(105, 20 * LtHt), 0, BF	IF CFlag = 0 THEN ShowCursorEND FUNCTION     '******************************************************************FUNCTION ChooseOneF (NMesF)EVENT OFFSHARED TextF$(), LtWd, LtHt, Xo, XH, Ymax, CursorFlag, ViewFlag, YvSHARED Scren#(), XWa, XWb, aYWa, aYWb	CFlag = CursorFlag: IF CFlag = 0 THEN HideCursor	: GetScreen	LINE (LtWd, 4 * LtHt)-(13 * LtWd + 7, 6 * LtHt - 1), 0, BF'***erases F1,F2 on control***	WID = 32'***wid becomes width of longest line	FOR IMES = 0 TO NMesF	IF LEN(TextF$(IMES)) > WID THEN WID = LEN(TextF$(IMES))	NEXT IMES: WID = WID + 1	XWa = (Xo + XH - 4 * LtWd) / 2 - (LtWd * WID) / 2: XWb = (Xo + XH - 4 * LtWd) / 2 + (LtWd * WID) / 2 + 6	aYWa = ((Ymax + 1) / 2) - (LtHt / 2) * (NMesF + 5)	aYWb = (Ymax + 1) / 2 + (LtHt / 2) * (NMesF + 6)	XLOC = XWa / LtWd + 2: YLOC = aYWa / LtHt + 1.51	LINE (XWa, aYWa)-(XWb, aYWb), , B: LINE (XWa + 1, aYWa + 1)-(XWb - 1, aYWb - 1), 0, BF	FOR IMES = 0 TO NMesF: LOCATE YLOC + IMES, XLOC + 1: PRINT TextF$(IMES): NEXT IMES	: ClearQeue:EVENT ON	ChoiceF = 11	WHILE (I$ <> "0" AND ChoiceF = 0) OR ChoiceF >= NMesF	LOCATE YLOC + NMesF + 2, XLOC + 1: PRINT "[select by striking appropriate"	LOCATE YLOC + NMesF + 3, XLOC + 1: PRINT "number (not function) key]"	I$ = INPUT$(1): ChoiceF = VAL(I$)'***chooses one alternative***	WEND	VIEW	: PutScreen:	IF ViewFlag THEN VIEW SCREEN (Xo, Yv - 3)-(XH + 10, Ymax - 9)'***restores clip*	: ChooseOneF = ChoiceF	IF CFlag = 0 THEN ShowCursorEND FUNCTIONSUB ClearQeueSHARED K$'***Clears keyboard queue***ReadAgn: K$ = INKEY$: IF K$ <> "" THEN GOTO ReadAgnEND SUBSUB Delay (YTime)	T! = TIMER	WHILE TIMER < (T! + YTime) AND TIMER > T!: Junk$ = INKEY$: WENDEND SUBSUB FKeysOff 'deactivates function keys	FOR FI = 1 TO 2: KEY(FI) OFF: NEXT FIEND SUBSUB FKeysOn 'activates function keys	FOR FI = 1 TO 2: KEY(FI) ON: NEXT FIEND SUBSUB GetScreenSHARED Scren#(), Xmax, Ymax       GET (0, 0)-(Xmax, Ymax), Scren#'      GET (0, 0)-(10, 10), Scren#END SUBSUB HideCursor STATICEVENT OFFSHARED inregs AS Registers, outregs AS Registers, CursorFlag, mMouse	IF NOT mMouse THEN EXIT SUB	inregs.ax = 2	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = CursorFlag - 1EVENT ONEND SUBSUB LimitMouse (mXmin, mYmin, mXmax, mYmax) STATICSHARED inregs AS Registers, outregs AS Registers ' Limit Horizontal Motion	inregs.ax = 7	inregs.cx = mXmin    'Xo+2	inregs.dx = mXmax     'XH+2		CALL INTERRUPT(&H33, inregs, outregs)'   Limit Vertical Motion	inregs.ax = 8	inregs.cx = mYmin   'Yv	inregs.dx = mYmax    'YMax-Y17	CALL INTERRUPT(&H33, inregs, outregs)END SUBSUB Message (MLeft, N)SHARED Xmax, LtHt, LtWd, Text$()	: HideCursor	LINE (0, 0)-(Xmax, 3 * LtHt - 1), 0, BF	LENMAX = 0	FOR I = 0 TO N - 1		LOCATE 1 + I, MLeft: PRINT Text$(I): L = LEN(Text$(I))		IF L > LENMAX THEN LENMAX = L	NEXT I	: ShowCursorEND SUB   '***********************PrintText*************************SUB PrintText (TITLE$, Text$)'                       ***Reads text from disk and prints it***DIM line$(21, 15)EVENT OFFSHARED ScNbr, DFct!, ViewFlag, CursorFlag, Xmax, Ymax, S()SHARED Xo, Yv%, XH, YmxMinus17%, K$, DownRt$, DownLft$, UpRt$, UpLft$: FKeysOff: ClearQeue'***deactivates the Fkeys, clears Queue***	CR$ = CHR$(13): LF$ = CHR$(10)	IF ViewFlag THEN VIEW '***if clipped, undoes clipping***	CFlag = CursorFlag: IF CFlag = 0 THEN HideCursor 'if on, turn cursor off	SCREEN 0:LineNumber = 1: PageNumber = 1: CharsRead = 0: LineLth = 0: SLth = 0: S$ = ""MaxLines = 21: CharBite = 200: LongestLine = 79     OPEN Text$ FOR INPUT AS #1 LEN = 2048'        OPEN "d:Instruct.ncr" FOR INPUT AS #1 LEN = 2048FLength = LOF(1)DO WHILE CharsRead < FLength - CharBite    S$ = S$ + INPUT$(CharBite, #1):        'Read Charbite Chars, add to S$    SLth = SLth + CharBite:                'Increase length of S and    CharsRead = CharsRead + CharBite       'Characters read accordingly    GOSUB GetLines                         'Extract lines, add to Line$ arrayLOOPS$ = S$ + INPUT$(FLength - CharsRead - 1, #1): 'Get remaining Chars, add to S$SLth = SLth + FLength - CharsRead:  GOSUB GetLinesWHILE LEFT$(S$, 1) = LF$                   'Clean LF's from start of S$   SLth = SLth - 1: S$ = RIGHT$(S$, SLth)WENDline$(LineNumber, PageNumber) = S$         'Put last partial line into Line$LineNumber = LineNumber + 1WHILE LineNumber <= MaxLines   line$(LineNumber, PageNumber) = "": LineNumber = LineNumber + 1WENDMaxPage = PageNumber:PageNumber = 1:K$ = ""WHILE K$ <> "q" AND K$ <> "Q"   CLS : ClearQeue   IF PageNumber = 1 THEN      LOCATE 1, (40 - LEN(TITLE$) / 2): PRINT TITLE$:  '**centers title   ELSE      LOCATE 1, (33 - LEN(TITLE$) / 2): PRINT TITLE$ + "  ---  Page"; PageNumber: ' **centers title   END IF   LOCATE 3, 1   FOR LineNumber = 1 TO MaxLines      PRINT " " + line$(LineNumber, PageNumber)   NEXT LineNumber		h = 31: NXT$ = "": PREV$ = ""		IF PageNumber > 1 THEN PREV$ = " P for Previous page,": h = h - 11		IF PageNumber < MaxPage THEN NXT$ = " N for next page,": h = h - 9		LOCATE 25, h: PRINT "[Strike" + NXT$ + PREV$ + " Q to Quit.]";   WHILE K$ <> "q" AND K$ <> "Q" AND K$ <> "N" AND K$ <> "n" AND K$ <> "P" AND K$ <> "p" AND K$ <> UpRt$ AND K$ <> UpLft$ AND K$ <> DownRt$ AND K$ <> DownLft$      K$ = INKEY$   WEND   SELECT CASE K$      CASE "N", "n", DownRt$	 PageNumber = PageNumber + 1	 IF PageNumber > MaxPage THEN PageNumber = MaxPage: BEEP      CASE "P", "p", UpRt$	 PageNumber = PageNumber - 1	 IF PageNumber < 1 THEN PageNumber = 1: BEEP      CASE UpLft$	 PageNumber = 1      CASE DownLft$	 PageNumber = MaxPage   END SELECTWEND	CLOSE : SCREEN S(ScNbr):	VIEW:	PutScreen	IF ViewFlag THEN VIEW SCREEN (Xo, Yv% - 3)-(XH + 10, Ymax - 9)'***restores clip*	CALL FKeysOn   '***enables the function keys***	: LimitMouse Xo + 2, Yv%, XH + 2, YmxMinus17%	IF CFlag = 0 THEN ShowCursor'If cursor was on, turn it back onEXIT SUBGetLines:    LineLth = INSTR(S$, CR$) - 1    WHILE LineLth >= 0       IF LineLth > LongestLine THEN  'breaking at last space instead of CR	  K$ = "": Offset = LongestLine	  DO UNTIL K$ = " " OR Offset = 0	     K$ = MID$(S$, Offset, 1): Offset = Offset - 1	  LOOP	  IF Offset = 0 THEN LineLth = LongestLine ELSE LineLth = Offset       END IF       line$ = LEFT$(S$, LineLth):       LineTmp = LineLth    'Used in next two lines only       IF LEFT$(line$, 1) = LF$ THEN LineTmp = LineTmp - 1: line$ = RIGHT$(line$, LineTmp)       IF LEFT$(line$, 1) = " " THEN LineTmp = LineTmp - 1: line$ = RIGHT$(line$, LineTmp)       line$(LineNumber, PageNumber) = line$       LineNumber = LineNumber + 1       IF LineNumber > MaxLines THEN LineNumber = 1: PageNumber = PageNumber + 1       SLth = SLth - LineLth - 1: S$ = RIGHT$(S$, SLth)       LineLth = INSTR(S$, CR$) - 1:    WENDRETURN:EVENT ONEND SUB '                       ***Reads text from disk and prints it***SUB PutScreenSHARED Scren#()	PUT (0, 0), Scren#, PSETEND SUBSUB ResetMouse STATICSHARED inregs AS Registers, outregs AS Registers, CursorFlag	inregs.ax = 0	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = -1'***Keeps track of visible (0) or invisible (not 0)***END SUBSUB SetCursorPosn (mXPosn, mYPosn) STATICSHARED inregs AS Registers, outregs AS Registers	inregs.ax = 4	inregs.cx = mXPosn	inregs.dx = mYPosn	CALL INTERRUPT(&H33, inregs, outregs)END SUBSUB ShowCursor STATICEVENT OFFSHARED inregs AS Registers, outregs AS Registers, CursorFlag, mMouse	IF NOT mMouse THEN EXIT SUB	inregs.ax = 1	CALL INTERRUPT(&H33, inregs, outregs)	CursorFlag = CursorFlag + 1EVENT ONEND SUBSUB VMouse (M) STATIC:SHARED K$, deltamax, DelX, XH, Xo, Xb, Yo, Yv, Ymax, Y17, Mouse(), CursrM(), ALIns, dsSHARED CR$, up$, down$, lft$, rght$, UpRt$, DownRt$, UpLft$, DownLft$, BSpace$SHARED ScrollUp, ScrollDown, BackSpace, mMouse, HandFlag, OldHandFlagSHARED inregs AS Registers, outregs AS Registers, MouseX, HandM'True,False,Bidr	M = 0: GOSUB checkshift	K$ = INKEY$: ShftFnKey = 0	KEY(15) ON: KEY(16) ON: KEY(17) ON: KEY(18) ON:	TMse! = TIMER	WHILE K$ = "" AND TIMER >= TMse! AND TIMER < TMse! + .12		IF ShftFnKey = 0 THEN K$ = INKEY$	WEND	KEY(15) OFF: KEY(16) OFF: KEY(17) OFF: KEY(18) OFF: ' ShftFnKey = 0EVENT OFF	IF mMouse THEN GOSUB MMouseSub: EXIT SUBIF K$ <> "" THEN ds = ds + 1: 'IF ds > deltamax THEN ds = deltamax	delt = ds	SELECT CASE K$		CASE up$			IF ScrollLock THEN				ScrollUp = True			ELSE				IF dy < 0 THEN ds = 1				dx = 0: dy = 1			END IF		CASE "8"			IF dy < 0 THEN ds = 1			dx = 0: dy = 1: M = 1		CASE down$			IF ScrollLock THEN				ScrollDown = True			ELSE				IF dy > 0 THEN ds = 1				dx = 0: dy = -1			END IF		CASE "2"			IF dy > 0 THEN ds = 1			dx = 0: dy = -1: M = 1		CASE rght$			IF dx < 0 THEN ds = 1			dx = DelX: dy = 0		CASE "6"			IF dx < 0 THEN ds = 1			dx = DelX: dy = 0: M = 1		CASE lft$			IF dx > 0 THEN ds = 1			dx = -DelX: dy = 0		CASE "4"			IF dx > 0 THEN ds = 1			dx = -DelX: dy = 0: M = 1		CASE DownLft$			IF dy > 0 OR dx > 0 THEN ds = 2			dy = -1: dx = -DelX: delt = .7 * ds		CASE "1"			IF dy > 0 OR dx > 0 THEN ds = 2			dy = -1: dx = -DelX: delt = .7 * ds: M = 1		CASE UpRt$			IF dy < 0 OR dx < 0 THEN ds = 2			dy = 1: dx = DelX: delt = .7 * ds		CASE "9"			IF dy < 0 OR dx < 0 THEN ds = 2			dy = 1: dx = DelX: delt = .7 * ds: M = 1		CASE DownRt$			IF dy > 0 OR dx < 0 THEN ds = 2			dy = -1: dx = DelX: delt = .7 * ds		CASE "3"			IF dy > 0 OR dx < 0 THEN ds = 2			dy = -1: dx = DelX: delt = .7 * ds: M = 1		CASE UpLft$			IF dy < 0 OR dx > 0 THEN ds = 2			dy = 1: dx = -DelX: delt = .7 * ds		CASE "7"			IF dy < 0 OR dx > 0 THEN ds = 2			dy = 1: dx = -DelX: delt = .7 * ds: M = 1		CASE "5"			ds = 0: dx = 0: dy = 0: M = 1		CASE "0"			ds = 0: dx = 0: dy = 0: M = 1		CASE BSpace$			BackSpace = True		CASE ELSE			IF K$ = CR$ THEN M = 2:			ds = 0: delt = 0:	END SELECT	IF ScrollUp OR ScrollDown THEN TMse! = TIMER: EXIT SUB	FOR iMse = 0 TO delt		PUT (Mouse(1), Mouse(2)), CursrM		IF delt > 0 THEN Mouse(1) = Mouse(1) + dx: Mouse(2) = Mouse(2) - dy		IF Mouse(1) > (XH + 2) THEN Mouse(1) = XH + 2		IF Mouse(1) < Xo + 2 THEN Mouse(1) = Xo + 2		IF Mouse(2) > Ymax - Y17 THEN Mouse(2) = Ymax - Y17		IF Mouse(2) < Yv THEN Mouse(2) = Yv		PUT (Mouse(1), Mouse(2)), CursrM, XOR	NEXT iMse	WHILE TIMER >= TMse! AND TIMER < TMse! + .1: WEND	TMse! = TIMER: ClearQeueEXIT SUBcheckshift:	inregs.ax = &H200: 'AH = 2	CALL INTERRUPT(&H16, inregs, outregs)	AL = outregs.ax AND &HFF	IF ((AL AND 1) = 1) OR ((AL AND 2) = 2) OR ((AL AND 64) = 64) OR ((AL AND 128) = ALIns) THEN	M = 1:	ELSE M = 0	END IF	IF (AL AND 16) = 16 THEN		ScrollLock = True	ELSE		ScrollLock = False: ScrollUp = False: ScrollDown = False	END IFRETURNMMouseSub:	inregs.ax = 3	CALL INTERRUPT(&H33, inregs, outregs)	M = outregs.bx:	IF M > 2 THEN M = 2'***Left is 1, right is 2, both are 3***	Mouse(1) = outregs.cx: Mouse(2) = outregs.dx	IF NOT Bidr THEN RETURN  '***skip this for other two programs***	OldHandFlag = HandFlag:	IF Mouse(1) < (Xo + 2) THEN		MouseX = Mouse(1): Mouse(1) = Xo + 2:		HandFlag = -1     'Turn hand on		HandM = M: M = 0  'Tools ignore button out of tool region	ELSE		HandFlag = 0      'Hand is off	END IF	IF Mouse(2) > Yo THEN		M = 0	END IF	IF K$ = BSpace$ THEN BackSpace = True ELSE BackSpace = FalseRETURNEVENT ONEND SUB     '***accepts key press***FUNCTION YesOrNo (NMes)SHARED Text$()StartYN:	YN$ = "": WHILE YN$ = "": YN$ = INKEY$: WEND	IF YN$ = "Y" OR YN$ = "y" THEN YesOrNo = 1: GOTO YesOrNoBot	IF YN$ = "N" OR YN$ = "n" THEN YesOrNo = 2: GOTO YesOrNoBot	FOR I = NMes TO 1 STEP -1: Text$(I) = Text$(I - 1): NEXT I	Text$(0) = "Strike y or n key for yes or no": ClearQeue	: Message 2, 1:     FOR I = 0 TO NMes - 1: Text$(I) = Text$(I + 1): NEXT I	BEEP: Delay 3	: Message 2, NMes: GOTO StartYNYesOrNoBot:END FUNCTION